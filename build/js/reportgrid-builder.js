
define('lib/util/dispatcher',[
  "jquery"
],
function($) {

  function applyon(dispatcher, handler) {
    return handler.__handler || (handler.__handler = function() {
      handler.apply(dispatcher, $.makeArray(arguments).slice(1));
    });
  }

  function bind(dispatcher, method, type, handler) {
    if(handler) {
      $(dispatcher)[method](type, applyon(this, handler));
      return dispatcher;
    } else {
      return $.Deferred(function(dfd) {
        $(dispatcher)[method](type, function() {
          dfd.resolve($.makeArray(arguments).slice(1));
        });
      }).promise();
    }
  }

  return function() {
    var dispatcher = {
      on : function(type, handler) {
        return bind(this, "on", type, handler);
      },
      one : function(type, handler) {
        return bind(this, "one", type, handler);
      },
      when : function() {
        var types = [];
        for(var i = 0; i < arguments.length; i++) {
          types.push(this.on(arguments[i]));
        }
        return $.when.apply($, types);
      },
      off : function(type, handler) {
        $(dispatcher).off(type, handler && (handler.__handler || handler));
        return dispatcher;
      },
      trigger : function(type) {
        var args = $.makeArray(arguments).slice(1);
        $(dispatcher).trigger(type, args);
        return dispatcher;
      }
    };
    return dispatcher;
  };
});

define('modules/context',[
  "lib/util/dispatcher"
],
function(createDispatcher) {
  var logger = window.console || {info:function(){}};
  var log = function() {
        logger.group(arguments[0]);
        logger.info.apply(logger, [new Date().toLocaleTimeString()].concat($.makeArray(arguments).slice(1)));
        logger.groupEnd(arguments[0])
      };

  return function(debug) {
    var ctx = createDispatcher();

    ctx.debug = debug;

    // DEBUG
    if(debug) {
      var trigger = ctx.trigger;
      ctx.counter = {};
      ctx.trigger = function() {
        var type = arguments[0];
        ctx.counter[type] = (ctx.counter[type] || 0) + 1;
        log.apply(window, arguments);
        trigger.apply(ctx, arguments);
      };
      ctx.log = function() {
        log.apply(window, arguments);
      };
    } else {
      ctx.log = function() {};
    }

    return ctx;
  };
});

define('lib/util/store',[

],

function() {
  return function(name, defaults, engine) {
    var data,
        storage = engine || window.localStorage,
        timer;
    var api = {
      has : function(key) {
        return "undefined" !== typeof data[key];
      },
      getData : function() {
        var s = storage.getItem(name);
        if(s)
          return JSON.parse(s);
        else
          return defaults || {};
      },
      setData : function(newdata) {
        data = newdata;
      },
      get : function(key) {
        return data[key];
      },
      set : function(key, value) {
        data[key] = value;
      },
      remove : function(key) {
        delete data[key];
      },
      keys : function() {
        var result = [];
        for(key in data) {
          if(data.hasOwnProperty(key))
            result.push(key);
        }
        return result;
      },
      empty : function() {
        return this.keys().length > 0;
      },
      restore : function() {
        data = this.getData();
      },
      commit : function() {
        storage.setItem(name, JSON.stringify(data));
      },
      delayedCommit : function(delay) {
        delay = delay || 0;
        clearTimeout(timer);
        timer = setTimeout(this.commit, delay);
      },
      destroy : function() {
        storage.removeItem(name);
      },
      destroyAll : function() {
        storage.clear();
      }
    };
    api.restore();
    return api;
  };
});
define('modules/model/config',[
  "lib/util/store"
],

function(createStore) {
  var STORE_NAME = "RGBUILDER:CONFIG",
      defaults = {
        theme : "gray"
      },
      store = createStore(STORE_NAME, defaults);

  return function(ctx) {
    /*
    store.monitor.bind("theme", function(theme) {
      ctx.trigger("theme.change", theme);
    });
    */
    ctx.on("modules.ready", function() {
      var theme = store.get("theme");
      ctx.trigger("theme.change", theme);
    });
    ctx.on("theme.changing", function(theme) {
      store.set("theme", theme, true);
      store.commit();
    });
  };
});
define('modules/model/examples',[
    "jquery"
],

function($) {
  var examples = [{
          name : "Olympic Medals 2011",
          src  : "olympic-medals-2011.json",
          fields : [{
              name : "country",
              type : "category" // continuous, discrete, category, time
            }
            , { field : "code", type : "category" }
            , { field : "summers", type : "discrete" }
            , { field : "summerGold", type : "discrete" }
            , { field : "summerSilver", type : "discrete" }
            , { field : "summerBronze", type : "discrete" }
            , { field : "summerTotal", type : "discrete" }
            , { field : "winters", type : "discrete" }
            , { field : "winterGold", type : "discrete" }
            , { field : "winterSilver", type : "discrete" }
            , { field : "winterBronze", type : "discrete" }
            , { field : "winterTotal", type : "discrete" }
            , { field : "games", type : "discrete" }
            , { field : "golds", type : "discrete" }
            , { field : "silvers", type : "discrete" }
            , { field : "bronzes", type : "discrete" }
            , { field : "total", type : "discrete" }
          ]
        }, {
          name : "English Speakers",
          src  : "english-speakers.json",
          fields : [
              { field : "country", type : "category" }
            , { field : "count", type : "discrete" }
          ]
        }, {
          name : "Iris",
          src : "iris.json",
          fields : [
              { field : "sepalLength", type : "continuous" }
            , { field : "sepalWidth", type : "continuous" }
            , { field : "petalLength", type : "continuous" }
            , { field : "petalWidth", type : "continuous" }
            , { field : "category", type : "category" }
          ]
        }, {
          name : "Boulder Weather 2011",
          src  : "boulder-weather-2011.json",
          fields : [
              { name : "day", field:"time:day", type : "time" }
            , { field : "tMax", type : "continuous" }
            , { field : "tMin", type : "continuous" }
            , { field : "tAverage", type : "continuous" }
            , { field : "precipitation", type : "continuous" }
            , { field : "snow", type : "continuous" }
            , { field : "snowCover", type : "continuous" }
          ]
        }, {
          name : "Boulder Weather 2011 - Q1",
          src  : "boulder-weather-2011-1Q.json",
          fields : [
              { name : "day", field:"time:day", type : "time" }
            , { field : "tMax", type : "continuous" }
            , { field : "tMin", type : "continuous" }
            , { field : "tAverage", type : "continuous" }
            , { field : "precipitation", type : "continuous" }
            , { field : "snow", type : "continuous" }
            , { field : "snowCover", type : "continuous" }
          ]
        }, {
          name : "Fictional Movie Clips",
          src  : "fic-clips.json",
          fields : [
              { field : "id", type : "category" }
            , { field : "count", type : "discrete" }
            , { field : "head", type : "category" }
            , { field : "tail", type : "category" }
          ]
        }, {
          name : "Fictional Sales",
          src  : "fic-sales.json",
          fields : [
              { field : "model", type : "category" }
            , { field : "market", type : "category" }
            , { field : "quarter", type : "category" }
            , { field : "value", type : "continuous" }
          ]
        }, {
          name : "Twitter Emoticons - Top 10",
          src  : "top10-emoticons-twitter.json",
          fields : [
              { field : "emoticon", type : "category" }
            , { field : "count", type : "discrete" }
          ]
        }, {
          name : "Twitter Emoticons - Top 20",
          src  : "top20-emoticons-twitter.json",
          fields : [
              { field : "emoticon", type : "category" }
            , { field : "count", type : "discrete" }
          ]
        }, {
          name : "USA - Population Age",
          src  : "usa-agestructure.json",
          fields : [
              { field : "age", type : "category" }
            , { field : "gender", type : "category" }
            , { field : "count", type : "discrete" }
          ]
        }, {
          name : "USA - Death Rate by Gender and Race - full",
          src  : "usa-deathrate-by-gender-and-race-full.json",
          fields : [
              { field : "year", type : "discrete" }
            , { field : "gender", type : "category" }
            , { field : "deathRate", type : "continuous" }
            , { field : "race", type : "category" }
          ]
        }, {
          name : "USA - Death Rate by Gender and Race",
          src  : "usa-deathrate-by-gender-and-race.json",
          fields : [
            { field : "year", type : "discrete" }
            , { field : "gender", type : "category" }
            , { field : "deathRate", type : "continuous" }
            , { field : "race", type : "category" }
          ]
        }, {
          name : "USA - Death Rate by Gender",
          src  : "usa-deathrate-by-gender.json",
          fields : [
            { field : "year", type : "discrete" }
            , { field : "gender", type : "category" }
            , { field : "deathRate", type : "continuous" }
          ]
        }, {
          name : "USA - Death Rate by Race",
          src  : "usa-deathrate-by-race.json",
          fields : [
            { field : "year", type : "discrete" }
            , { field : "deathRate", type : "continuous" }
            , { field : "race", type : "category" }
          ]
        }, {
          name : "USA - Debt",
          src  : "usa-debt.json",
          fields : [
              { field : "country", type : "category" }
            , { field : "date", type : "category" }
            , { field : "value", type : "continuous" }
          ]
        }, {
          name : "USA - Gross Public Debt",
          src  : "usa-gross-public-debt.json",
          fields : [
              { field : "year", type : "discrete" }
            , { field : "grossDebt", type : "continuous" }
            , { field : "publicDebt", type : "continuous" }
          ]
        }, {
          name : "USA - Population and Areas 1790-2000",
          src  : "usa-population-and-area-1790-2000.json",
          fields : [
              { field : "year", type : "discrete" }
            , { field : "population", type : "continuous" }
            , { field : "area", type : "continuous" }
          ]
        }

          /*, {
          name : "",
          src  : "",
          fields : [
              { field : "", type : "" }
            , { field : "", type : "" }
          ]
        }*/]
      root = "/examples", // in the form of /path or empty
      datapath = "data";

  function path() {
    return $.makeArray(arguments).join("/");
  }

  function loadExamples(ctx) {
    $(examples).each(function(i, example) {
      example.src  = path(datapath,example.src);
      example.type = example.type || "url";
      example.path = path(root, example.name);
      for(var i = 0; i < example.fields.length; i++) {
        var field = example.fields[i];
        field.name = field.name || field.field;
      }
      ctx.trigger("data.datasource.add", example);
    });
  }

  return function(ctx) {
    ctx.on("modules.ready", function() {
      ctx.on("response.datasource.localstorage.hasdata", function(hasdata) {
        if(!hasdata)
          loadExamples(ctx);
      });
      ctx.trigger("request.datasource.localstorage.hasdata");
    });
  };
});
define('config/chart/extract/extractor',[
  "jquery"
],

function($) {
  return function(extractors) {
    return function(o, dimensions, options) {
      $.each(extractors, function() {
        this(o, dimensions, options);
      });
    };
  };
});
define('config/chart/extract/allextract',[],

function() {
  return function(o, dimensions, options) {

  };
});
define('config/chart/extract/ensure',[],
function() {
  return function(name, o) {
    return o[name] || (o[name] = {});
  }
});
define('config/chart/extract/svgextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options["label.title"] && options["label.title"]) {
      ensure('label',o).title = options["label.title"];
      if("undefined" !== typeof options.titleontop && !options.titleontop)
        o.titleontop = options.titleontop
    }

    if("undefined" !== typeof options['label.datapointover']) {
      if(false === options['label.datapointover']) {
        ensure('label',o).datapointover = function() {return null;};
      } else if("string" === typeof options['label.datapointover']) {
        ensure('label',o).datapointover = options['label.datapointover'];
      }
    }

    if("undefined" !== typeof options["label.datapoint"]) {
      if(false === options["label.datapoint"]) {
        ensure('label',o).datapoint = function() {return null;};
      } else if("string" === typeof options["label.datapoint"]) {
        ensure('label',o).datapoint = options["label.datapoint"];
      }
    }

    if(options['padding.left']) {
      ensure('padding', o).left = options['padding.left'];
    }

    if(options['padding.right']) {
      ensure('padding', o).right = options['padding.right'];
    }

    if(options['padding.top']) {
      ensure('padding', o).top = options['padding.top'];
    }

    if(options['padding.bottom']) {
      ensure('padding', o).bottom = options['padding.bottom'];
    }

    if(options['width'] && options['width'] !== 500) {
      o.width = options['width'];
    }

    if(options['height'] && options['height'] !== 250) {
      o.height = options['height'];
    }
  };
});
define('config/chart/extract/cartesianextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {

    if("alternating" !== options["cartesian.yscaleposition"]) {
      o.yscaleposition = options["cartesian.yscaleposition"];
    }

    if("undefined" !== typeof options["labelhorizontal"] && !options["labelhorizontal"])
      o.labelhorizontal = options["labelhorizontal"];



    if("undefined" !== typeof options['label.axis']) {
      if(true === options['label.axis']) {
        ensure('label',o).axis = "@humanize(type)";
      } else if("string" === typeof options['label.axis']) {
        ensure('label',o).axis = options['label.axis'];
      }
    }

    if("undefined" !== typeof options['label.tickmark']) {
      if(false === options['label.tickmark']) {
        ensure('label',o).tickmark = function() {return null;};
      } else if("string" === typeof options['label.tickmark']) {
        ensure('label',o).tickmark = options['label.tickmark'];
      }
    }


    if("undefined" !== typeof options["cartesian.displayruleminor"] && options["cartesian.displayruleminor"]) {
      o.displayruleminor = options["cartesian.displayruleminor"];
    }

    if("undefined" !== typeof options["cartesian.displayrulemajor"] && options["cartesian.displayrulemajor"]) {
      o.displayrulemajor = options["cartesian.displayrulemajor"];
    }

    if("undefined" !== typeof options["cartesian.displaytickminor"] && !options["cartesian.displaytickminor"]) {
      o.displaytickminor = options["cartesian.displaytickminor"];
    }

    if("undefined" !== typeof options["cartesian.displaytickmajor"] && !options["cartesian.displaytickmajor"]) {
      o.displaytickmajor = options["cartesian.displaytickmajor"];
    }

    if("undefined" !== typeof options["cartesian.displayticklabel"] && !options["cartesian.displayticklabel"]) {
      o.displayticklabel = options["cartesian.displayticklabel"];
    }

    if("undefined" !== typeof options["cartesian.displayanchorlinetick"] && options["cartesian.displayanchorlinetick"]) {
      o.displayanchorlinetick = options["cartesian.displayanchorlinetick"];
    }

    if("undefined" !== typeof options["cartesian.displayanchorlinerule"] && options["cartesian.displayanchorlinerule"]) {
      o.displayanchorlinerule = options["cartesian.displayanchorlinerule"];
    }

    if("undefined" !== typeof options["cartesian.lengthtickminor"] && options["cartesian.lengthtickminor"] !== 2) {
      o.lengthtickminor = options["cartesian.lengthtickminor"];
    }

    if("undefined" !== typeof options["cartesian.lengthtickmajor"] && options["cartesian.lengthtickmajor"] !== 5) {
      o.lengthtickmajor = options["cartesian.lengthtickmajor"];
    }

    if("undefined" !== typeof options["cartesian.paddingtickminor"] && options["cartesian.paddingtickminor"] !== 1) {
      o.paddingtickminor = options["cartesian.paddingtickminor"];
    }

    if("undefined" !== typeof options["cartesian.paddingtickmajor"] && options["cartesian.paddingtickmajor"] !== 1) {
      o.paddingtickmajor = options["cartesian.paddingtickmajor"];
    }

    if("undefined" !== typeof options["cartesian.paddingticklabel"] && options["cartesian.paddingticklabel"] !== 10) {
      o.paddingticklabel = options["cartesian.paddingticklabel"];
    }
    // displayruleminor false
    // displayrulemajor false
    // displaytickminor true
    // displaytickmajor true
    // displayticklabel true
    // displayanchorlinetick false
    // displayanchorlinerule false
    // lengthtickminor 2
    // lengthtickmajor 5
    // paddingtickminor 1
    // paddingtickmajor 1
    // paddingticklabel 10
  };
});
define('config/chart/extract/segmentextract',[
  "config/chart/extract/ensure"
],

function(ensure) {

  return function(o, dimensions, options) {
    if(dimensions.segment) {
      var segment = o.segment || (o.segment = {});
      segment.on = dimensions.segment[0].name;
    }
  }
});
define('config/chart/extract/barchartextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options["barchart.stacked"])
      o.stacked = options["barchart.stacked"];
    if("undefined" !== typeof options["barchart.horizontal"])
      o.horizontal = options["barchart.horizontal"];

    if("undefined" !== typeof options["barchart.effect"] && options["barchart.effect"] !== "gradient")
      o.effect = options["barchart.effect"];

    if("undefined" !== typeof options["barchart.barpadding"] && options["barchart.barpadding"] != 12)
      o.barpadding = options["barchart.barpadding"];

    if("undefined" !== typeof options["barchart.barpaddingaxis"] && options["barchart.barpaddingaxis"] != 4)
      o.barpaddingaxis = options["barchart.barpaddingaxis"];

    if("undefined" !== typeof options["barchart.barpaddingdatapoint"] && options["barchart.barpaddingdatapoint"] != 2)
      o.barpaddingdatapoint = options["barchart.barpaddingdatapoint"];

    if(options["barchart.startproperty"])
      o.startat = options["barchart.startproperty"];
  }
});
define('config/chart/barchartextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/cartesianextract"
  , "config/chart/extract/segmentextract"
  , "config/chart/extract/barchartextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/applier',[
  "jquery"
],

function($) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(toapply, options, preferences) {
    $.each(toapply, function() {
      this(options, preferences);
    });
  };
});
define('config/chart/options/alloptions',[],

function() {
  return function(options, preferences) {
    preferences = preferences || {};
/*
    options.push({
      name : "colors",
      group : "general",
      weight : -1000,
      editors : [{
        type : "colorlist",
        options : {
          default : "#aaa,#bbb,#fa9,#9af"
        }
      }]
    });

    options.push({
      name : "color",
      group : "general",
      weight : -1000,
      editors : [{
        type : "color",
        options : {
          default : "#fa9"
        }
      }]
    });
*/
  };
});
define('config/chart/options/rgcssoptions',[],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name  : "css",
      group : "aesthetic",
      event : "chart.rgcss.load",
      editors : [{
        type  : "rgcss",
        options : {
          default : ""
        }
      }]
    });
  };
});
define('config/chart/options/svgoptions',[],

function() {
  return function(options, preferences) {
    preferences = preferences || {};
    options.push({
      name  : "title",
      event : "options.chart.label.title",
      group : "general",
      weight : -10,
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "tooltip",
      event : "options.chart.label.datapointover",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "titleontop",
      label : "title on top",
      event : "options.chart.titleontop",
      group : "label",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }],
      condition : {
        event   : "options.chart.title",
        visible : function(value) {
          return value !== '';
        }
      }
    });

    options.push({
      name  : "width",
      label : "size",
      group : "general",
      className : "inline first",
      weight : 10,
      event : "options.chart.width",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          step    : 25,
          default : preferences.width || 500
        }
      }]
    });

    options.push({
      name  : "height",
      label : " x ",
      group : "general",
      className : "inline last",
      weight : 11,
      event : "options.chart.height",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          step    : 25,
          default : preferences.height || 250
        }
      }]
    });
  };
});
define('config/chart/options/cartesianoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    if(!preferences.hidey) {
      var values = [
          { value : "left" }
        , { value : "right" }
      ];
      if(!preferences.singley) {
        values.unshift({ value : "alternating" });
      }
      options.push({
        name : "yscaleposition",
        label : "y position",
        group : "axis",
        event : "options.chart.cartesian.yscaleposition",
        editors : [{
          type : "selection",
          options : {
            selectiontext : false,
            default : values[0],
            values  : values
          }
        }]
      });
    }

    options.push({
      name  : "axis",
      event : "options.chart.label.axis",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "tickmark",
      event : "options.chart.label.tickmark",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "labelhorizontal",
      group : "label",
      label : "horizontal",
      event : "options.chart.labelhorizontal",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "displayrulemajor",
      label : "major",
      group : "rules",
      event : "options.chart.cartesian.displayrulemajor",
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "displayruleminor",
      label : "minor",
      group : "rules",
      event : "options.chart.cartesian.displayruleminor",
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "displaytickmajor",
      label : "major",
      group : "tickmarks",
      event : "options.chart.cartesian.displaytickmajor",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "displaytickminor",
      label : "minor",
      group : "tickmarks",
      event : "options.chart.cartesian.displaytickminor",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "displayticklabel",
      label : "display label",
      group : "axis",
      event : "options.chart.cartesian.displayticklabel",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "displayanchorlinetick",
      label : "border",
      group : "tickmarks",
      event : "options.chart.cartesian.displayanchorlinetick",
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });
/*
    options.push({
      name  : "displayanchorlinerule",
      label : "display anchor line rule",
      group : "tickmarks",
      event : "options.chart.cartesian.displayanchorlinerule",
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }, {
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });
*/
    options.push({
      name  : "lengthtickminor",
      label : "minor tickmarks",
      className : "inline first",
      group : "tickmarks",
      event : "options.chart.cartesian.lengthtickminor",
      weight : 100,
      editors : [{
        type  : "float",
        options : {
          unit : "length",
          default : 2,
          step : 1
        }
      }]
    });

    options.push({
      name  : "paddingtickminor",
      label : "",
      className : "inline last",
      group : "tickmarks",
      event : "options.chart.cartesian.paddingtickminor",
      weight : 101,
      editors : [{
        type  : "float",
        options : {
          unit : "margin",
          default : 1,
          step : 1
        }
      }]
    });


    options.push({
      name  : "lengthtickmajor",
      label : "major tickmarks",
      group : "tickmarks",
      className : "inline first",
      event : "options.chart.cartesian.lengthtickmajor",
      weight : 110,
      editors : [{
        type  : "float",
        options : {
          unit : "length",
          default : 5,
          step : 1
        }
      }]
    });

    options.push({
      name  : "paddingtickmajor",
      label : "",
      group : "tickmarks",
      className : "inline last",
      event : "options.chart.cartesian.paddingtickmajor",
      weight : 111,
      editors : [{
        type  : "float",
        options : {
          unit : "margin",
          default : 1,
          step : 1
        }
      }]
    });

    options.push({
      name  : "paddingticklabel",
      label : "margin label",
      group : "axis",
      event : "options.chart.cartesian.paddingticklabel",
      editors : [{
        type  : "float",
        options : {
          default : 10,
          step : 1
        }
      }]
    });


    options.push({
      name  : "paddingleft",
      label : "padding",
      group : "aesthetic",
      className : "inline first reduce",
      weight : 5,
      event : "options.chart.padding.left",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          max     : 500,
          step    : 10,
          unit    : "L",
          title   : "left",
          default : preferences.height || 0
        }
      }]
    });

    options.push({
      name  : "paddingright",
      label : "",
      group : "aesthetic",
      className : "inline reduce",
      weight : 6,
      event : "options.chart.padding.right",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          max     : 500,
          step    : 10,
          unit    : "R",
          title   : "right",
          default : preferences.height || 0
        }
      }]
    });

    options.push({
      name  : "paddingtop",
      label : "",
      group : "aesthetic",
      className : "inline reduce",
      weight : 7,
      event : "options.chart.padding.top",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          max     : 500,
          step    : 10,
          unit    : "T",
          title   : "top",
          default : preferences.height || 0
        }
      }]
    });

    options.push({
      name  : "paddingbottom",
      label : "",
      group : "aesthetic",
      className : "inline last reduce",
      weight : 8,
      event : "options.chart.padding.bottom",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          max     : 500,
          step    : 10,
          unit    : "B",
          title   : "bottom",
          default : preferences.height || 0
        }
      }]
    });

    // displayticklabel true
    // displayanchorlinetick false
    // displayanchorlinerule false
    // paddingticklabel 10


    /*
     labelOrientation = function(_) return null;
     labelAnchor = function(_) return null;
     labelAngle = function(_) return null;
     */
  }
});
define('config/chart/options/barchartoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};
    options.push({
      name  : "horizontal",
      group : "barchart",
      event : "options.chart.barchart.horizontal",
      editors : [{
        type  : "boolean",
        options : {
          default : false
        }
      }]
    });

    options.push({
      name  : "stacked",
      group : "barchart",
      weight : -10,
      event : "options.chart.barchart.stacked",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "startat",
      label : "start at",
      group : "barchart",
      weight : -10,
      event : "options.chart.barchart.startproperty",
      editors : [{
        type  : "string",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "effect",
      group : "aesthetic",
      weight : 0,
      event : "options.chart.barchart.effect",
      editors : [{
        type  : "selection",
        options : {
          default : "gradient",
          values : [
              { value : "noeffect", label : "none" }
            , { value : "gradient", label : "gradient" }
            , { value : "gradient:1.25", label : "custom gradient", editor : { type : "float", options : { default : 1.25, min : -10, max : 10 } } }
          ]
        }
      }]
    });

    options.push({
      name : "barpadding",
      label : "for bars",
      group : "barpadding",
      weight : 0,
      event : "options.chart.barchart.barpadding",
      editors : [{
        type : "float",
        options : {
          default : 12,
          step : 1,
          min : 0
        }
      }]
    });

    options.push({
      name : "barpaddingdatapoint",
      label : "for data",
      group : "barpadding",
      weight : 0,
      event : "options.chart.barchart.barpaddingdatapoint",
      editors : [{
        type : "float",
        options : {
          default : 2,
          step : 1,
          min : 0
        }
      }]
    });

    options.push({
      name : "barpaddingaxis",
      label : "for axes",
      group : "barpadding",
      weight : 0,
      event : "options.chart.barchart.barpaddingaxis",
      editors : [{
        type : "float",
        options : {
          default : 4,
          step : 1,
          min : 0
        }
      }]
    });
  }
});
define('config/chart/barchartoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/cartesianoptions"
  , "config/chart/options/barchartoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/barchart',[
    "config/chart/barchartextractor"
  , "config/chart/barchartoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "barchart"
    , method : "barChart"
    , label : "Bar Chart"
    , extractOptions : extractor()
    , dimensions : [{
      name : "x",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "y",
      isaxis : true,
      min  : 1,
      max  : null
    }, {
      name : "segment",
      min  : 0,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/linechartextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if(options["linechart.symbol"]) {
      var expr = options["linechart.symbol"];
      if(((/^[a-z]+:=/i).test(expr))) {
        var parts = expr.split(":=");
        o.symbol = "=symbol('"+parts[0]+"',"+parts[1]+")";
      } else if(expr != '[no symbol]') {
        o.symbol = expr;
      }
    }

    if(options["linechart.symbolstyle"]) {
      o.symbolstyle = options["linechart.symbolstyle"];
    }

    if(options["linechart.displayarea"]) {
      o.displayarea = options["linechart.displayarea"];
    }

    if(options["linechart.y0property"]) {
      o.y0property = options["linechart.y0property"];
    }

    if("undefined" !== typeof options["linechart.sensibleradius"] && options["linechart.sensibleradius"] != 100) {
      o.sensibleradius = options["linechart.sensibleradius"];
    }

    if("undefined" !== typeof options["linechart.lineeffect"] && options["linechart.lineeffect"] != "gradient:-1.2,2") {
      o.effect = options["linechart.lineeffect"];
    }

    if("undefined" !== typeof options["linechart.lineinterpolation"] && options["linechart.lineinterpolation"] != "linear") {
      o.interpolation = options["linechart.lineinterpolation"];
    }

  };
});
define('config/chart/linechartextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/cartesianextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/segmentextract"
  , "config/chart/extract/linechartextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/linechartoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    var sizeeditor = { type : "expression", options : { default : "=64", unit : "px²", className : "small" }};
    options.push({
      name : "symbol",
      label : "shape",
      group : "symbol",
      event : "options.chart.linechart.symbol",
      editors : [{
        type : "selection",
        options : {
          default : "",
          values : [
              { value : "",               label : "[no symbol]" }
            , { value : "circle:",        label : "circle",          editor : sizeeditor }
            , { value : "square:",        label : "square",          editor : sizeeditor }
            , { value : "diamond:",       label : "diamond",         editor : sizeeditor }
            , { value : "cross:",         label : "cross",           editor : sizeeditor }
            , { value : "star:",          label : "star",            editor : sizeeditor }
            , { value : "triangleDown:",  label : "triangle down",   editor : sizeeditor }
            , { value : "triangleUp:",    label : "triangle up",     editor : sizeeditor }
            , { value : "arrowUp:",       label : "arrow up",        editor : sizeeditor }
            , { value : "arrowDown:",     label : "arrow down",      editor : sizeeditor }
            , { value : "arrowRight:",    label : "arrow right",     editor : sizeeditor }
            , { value : "arrowLeft:",     label : "arrow left",      editor : sizeeditor }
            , { value : "arrowDownWide:", label : "arrow down wide", editor : sizeeditor }
          ]
        }
      }, {
        type  : "expression",
        options : {
          default : "=symbol('circle',64)"
        }
      }]
    });

    options.push({
      name : "symbolstyle",
      label : "style",
      group : "symbol",
      event : "options.chart.linechart.symbolstyle",
      editors : [{
        type : "template",
        default : ""
      }]
    });

    options.push({
      name : "displayarea",
      label : "area chart",
      group : "linechart",
      event : "options.chart.linechart.displayarea",
      editors : [{
        type : "boolean",
        options :  {
          default : false
        }
      }]
    });

    options.push({
      name : "y0property",
      label : "field for y0",
      group : "linechart",
      event : "options.chart.linechart.y0property",
      editors : [{
        type : "string",
        options : {
          default : ""
        }
      }],
      condition : {
        event   : "options.chart.linechart.displayarea",
        visible : function(value) {
          return !!value;
        }
      }
    });

    options.push({
      name  : "sensibleradius",
      label : "sensible radius",
      group : "linechart",
      weight : 10,
      event : "options.chart.linechart.sensibleradius",
      editors : [{
        type  : "int",
        options : {
          min     : 0,
          step    : 10,
          unit    : "px",
          default : 100
        }
      }]
    });

    options.push({
      name : "lineeffect",
      label : "effect",
      group : "aesthetic",
      event : "options.chart.linechart.lineeffect",
      weight : 10,
      editors : [{
        type : "selection",
        options : {
          default : "gradient:",
          values : [
              { value : "noeffect",    label : "none" }
            , { value : "dropshadow:", label : "shadow",   editor : { type : "string", options : { default : "0.5,0.5,2" } } }
            , { value : "gradient:",   label : "gradient", editor : { type : "string", options : { default : "-1.2,2" } } }
          ]
        }
      }]
    });

    options.push({
      name : "lineinterpolation",
      label : "interpolation",
      group : "linechart",
      event : "options.chart.linechart.lineinterpolation",
      weight : 0,
      editors : [{
        type : "selection",
        options : {
          default : "linear",
          values : [
            { value : "linear" },
            { value : "basis" },
            { value : "cardinal:", label : "cardinal", editor : { type : "float", options : { default : 0.75, step : 0.05  } } },
            { value : "monotone" },
            { value : "step" },
            { value : "stepafter", label : "step after" },
            { value : "stepbefore", label : "step before" }
          ]
        }
      }]
    });
  }
});
define('config/chart/linechartoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/cartesianoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/linechartoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/linechart',[
    "config/chart/linechartextractor"
  , "config/chart/linechartoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "linechart"
    , method : "lineChart"
    , label : "Line Chart"
    , extractOptions : extractor()
    , dimensions : [{
      name : "x",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "y",
      isaxis : true,
      min  : 1,
      max  : null
    }, {
      name : "segment",
      min  : 0,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/streamgraphextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {

    if("undefined" !== typeof options["streamgraph.effect"] && options["streamgraph.effect"] != "gradientv:0.75") {
      o.effect = options["streamgraph.effect"];
    }
    
    if("undefined" !== typeof options["streamgraph.lineinterpolation"] && options["streamgraph.lineinterpolation"] != "linear") {
      o.interpolation = options["streamgraph.lineinterpolation"];
    }
  }
});
define('config/chart/streamgraphextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/cartesianextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/segmentextract"
  , "config/chart/extract/streamgraphextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/streamgraphoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "streameffect",
      label : "effect",
      group : "aesthetic",
      event : "options.chart.streamgraph.effect",
      weight : 10,
      editors : [{
        type : "selection",
        options : {
          default : "gradientv:",
          values : [
              { value : "noeffect",   label : "none" }
            , { value : "gradientv:", label : "vertical gradient",   editor : { type : "float", options : { default : 0.75 } } }
            , { value : "gradienth:", label : "horizontal gradient", editor : { type : "float", options : { default : 0.75 } } }
          ]
        }
      }]
    });

    options.push({
      name : "lineinterpolation",
      label : "interpolation",
      group : "streamgraph",
      event : "options.chart.streamgraph.lineinterpolation",
      weight : 0,
      editors : [{
        type : "selection",
        options : {
          default : "cardinal:",
          values : [
            { value : "linear" },
            { value : "basis" },
            { value : "cardinal:", label : "cardinal", editor : { type : "float", options : { default : 0.75, step : 0.05  } } },
            { value : "monotone" },
            { value : "step" },
            { value : "stepafter", label : "step after" },
            { value : "stepbefore", label : "step before" }
          ]
        }
      }]
    });
  }
});
define('config/chart/streamgraphoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/cartesianoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/streamgraphoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options, { hidey : true });
  };
});
define('config/chart/streamgraph',[
    "config/chart/streamgraphextractor"
  , "config/chart/streamgraphoptions"
],

function(extractor, applyOptions) {
  var chart = {
    type  : "streamgraph"
    , method : "streamGraph"
    , label : "Stream Graph"
    , extractOptions : extractor()
    , dimensions : [{
      name : "x",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "y",
      isaxis : true,
      min  : 1,
      max  : null
    }, {
      name : "segment",
      min  : 0,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/funnelchartextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options['label.arrow']) {
      if(false === options['label.arrow']) {
        ensure('label',o).arrow = function() {return null;};
      } else if("string" === typeof options['label.arrow']) {
        ensure('label',o).arrow = options['label.arrow'];
      }
    }

    if("undefined" !== typeof options['funnelchart.segmentpadding'] && options['funnelchart.segmentpadding'] != 2.5)
      o.segmentpadding = options['funnelchart.segmentpadding'];

    if("undefined" !== typeof options['funnelchart.flatness'] && options['funnelchart.flatness'] != 1)
      o.flatness = options['funnelchart.flatness'];

    if("undefined" !== typeof options['funnelchart.arrowsize'] && options['funnelchart.arrowsize'] != 30)
      o.arrowsize = options['funnelchart.arrowsize'];

    if("undefined" !== typeof options["funnelchart.effect"] && options["funnelchart.effect"] !== "gradient")
      o.effect = options["funnelchart.effect"];

    if("undefined" !== typeof options["funnelchart.sort"] && options["funnelchart.sort"])
      o.sort = options["funnelchart.sort"];
  }
});
define('config/chart/funnelchartextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/funnelchartextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/funnelchartoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "sort",
      group : "funnelchart",
      weight : 0,
      event : "options.chart.funnelchart.sort",
      editors : [{
        type : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "arrowsize",
      label : "arrow size",
      group : "funnelchart",
      event : "options.chart.funnelchart.arrowsize",
      editors : [{
        type : "float",
        options : {
          default : 30,
          step : 10,
          min : 0
        }
      }]
    });

    options.push({
      name : "segmentpadding",
      label : "spacing",
      group : "funnelchart",
      event : "options.chart.funnelchart.segmentpadding",
      editors : [{
        type : "float",
        options : {
          default : 2.5,
          step : 1
        }
      }]
    });

    options.push({
      name : "flatness",
      label : "flatness",
      group : "funnelchart",
      event : "options.chart.funnelchart.flatness",
      editors : [{
        type : "float",
        options : {
          default : 1,
          step : 0.05,
          min : 0,
          max : 2
        }
      }]
    });

    options.push({
      name  : "effect",
      group : "aesthetic",
      weight : 0,
      event : "options.chart.funnelchart.effect",
      editors : [{
        type  : "selection",
        options : {
          default : "gradient",
          values : [
            { value : "noeffect", label : "none" }
            , { value : "gradient", label : "gradient" }
            , { value : "gradient:1.25", label : "custom gradient", editor : { type : "float", options : { default : 1.25, min : -10, max : 10 } } }
          ]
        }
      }]
    });

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "arrow",
      group : "label",
      event : "options.chart.label.arrow",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });
  };
});
define('config/chart/funnelchartoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/funnelchartoptions"

],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/funnelchart',[
    "config/chart/funnelchartextractor"
  , "config/chart/funnelchartoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "funnelchart"
    , method : "funnelChart"
    , label : "Funnel Chart"
    , extractOptions : extractor()
    , dimensions : [{
      name : "slice",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "value",
      isaxis : true,
      min  : 1,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/heatgridextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
//    if("undefined" !== typeof options["barchart.stacked"])
//      o.stacked = options["barchart.stacked"];
  }
});
define('config/chart/heatgridextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/cartesianextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/heatgridextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/heatgridoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });
  }
});
define('config/chart/heatgridoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/cartesianoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/heatgridoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options, { singley : true });
  };
});
define('config/chart/heatgrid',[
    "config/chart/heatgridextractor"
  , "config/chart/heatgridoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "heatgrid"
    , method : "heatGrid"
    , label : "Heat Map"
    , extractOptions : extractor()
    , dimensions : [{
      name : "x",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "y",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "value",
      isaxis : true,
      min  : 1,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/htmlextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options['label.datapointover']) {
      if(false === options['label.datapointover']) {
        ensure('label',o).datapointover = function() {return null;};
      } else if("string" === typeof options['label.datapointover']) {
        ensure('label',o).datapointover = options['label.datapointover'];
      }
    }

    if("undefined" !== typeof options["label.datapoint"]) {
      if("string" === typeof options["label.datapoint"] && options["label.datapoint"]) {
        ensure('label',o).datapoint = options["label.datapoint"];
      }
    }
  };
});
define('config/chart/extract/leaderboardextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options["leaderboard.sort"] && options["leaderboard.sort"])
      o.sort = options["leaderboard.sort"];

    if("undefined" !== typeof options["leaderboard.colorscale"] && options["leaderboard.colorscale"])
      o.colorscale = options["leaderboard.colorscale"];

    if("undefined" !== typeof options["leaderboard.usemax"] && options["leaderboard.usemax"])
      o.usemax = options["leaderboard.usemax"];

    if("undefined" !== typeof options["leaderboard.displaybar"] && !options["leaderboard.displaybar"])
      o.displaybar = options["leaderboard.displaybar"];

    if("undefined" !== typeof options['label.rank']) {
      if(false === options['label.rank']) {
        ensure('label',o).rank = function() {return null;};
      } else if("string" === typeof options['label.rank']) {
        ensure('label',o).rank = options['label.rank'];
      }
    }

    if("undefined" !== typeof options['label.value']) {
      if(false === options['label.value']) {
        ensure('label',o).value = function() {return null;};
      } else if("string" === typeof options['label.value']) {
        ensure('label',o).value = options['label.value'];
      }
    }
  }
});
define('config/chart/leaderboardextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/htmlextract"
  , "config/chart/extract/leaderboardextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/htmloptions',[],

function() {
  return function(options, preferences) {
    preferences = preferences || {};
    options.push({
      name  : "tooltip",
      event : "options.chart.label.datapointover",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });
  };
});
define('config/chart/options/leaderboardoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "sort",
      group : "leaderboard",
      weight : 0,
      event : "options.chart.leaderboard.sort",
      editors : [{
        type : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "colorscale",
      label : "use colors",
      group : "leaderboard",
      weight : 0,
      event : "options.chart.leaderboard.colorscale",
      editors : [{
        type : "boolean",
        options : {
          default : false
        }
      }]
    });

    options.push({
      name : "usemax",
      label : "use max",
      group : "leaderboard",
      weight : 0,
      event : "options.chart.leaderboard.usemax",
      editors : [{
        type : "boolean",
        options : {
          default : false
        }
      }]
    });

    options.push({
      name : "displaybar",
      label : "display meter",
      group : "leaderboard",
      weight : 0,
      event : "options.chart.leaderboard.displaybar",
      editors : [{
        type : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "rank",
      event : "options.chart.label.rank",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "value",
      event : "options.chart.label.value",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });
  }
});
define('config/chart/leaderboardoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/htmloptions"
  , "config/chart/options/leaderboardoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/leaderboard',[
    "config/chart/leaderboardextractor"
  , "config/chart/leaderboardoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "leaderboard"
    , method : "leaderBoard"
    , label : "Leaderboard"
    , extractOptions : extractor()
    , dimensions : [{
      name : "label",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "measure",
      isaxis : true,
      min  : 1,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/chart/extract/pivottableextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if(dimensions['columns'].length > 1)
      o.columnaxes = dimensions['columns'].length;

    if(false === options["pivottable.displaytotalcolumns"])
      o.displaycolumntotal = options["pivottable.displaytotalcolumns"];

    if(false === options["pivottable.displaytotalrows"])
      o.displayrowtotal = options["pivottable.displaytotalrows"];

    if(false === options["pivottable.displayheatmap"])
      o.displayheatmap = options["pivottable.displayheatmap"];

    if("undefined" !== typeof options["pivottable.cellclass"] && options["pivottable.cellclass"])
      o.cellclass = options["pivottable.cellclass"];

    if("undefined" !== typeof options["pivottable.valueclass"] && options["pivottable.valueclass"])
      o.valueclass = options["pivottable.valueclass"];

    if("undefined" !== typeof options["pivottable.headerclass"] && options["pivottable.headerclass"])
      o.headerclass = options["pivottable.headerclass"];

    if("undefined" !== typeof options["pivottable.totalclass"] && options["pivottable.totalclass"])
      o.totalclass = options["pivottable.totalclass"];

    if("undefined" !== typeof options["label.axisvalue"]) {
      if(false === options["label.axisvalue"]) {
        ensure('label',o).axisvalue = function() {return null;};
      } else if("string" === typeof options["label.axisvalue"]) {
        ensure('label',o).axisvalue = options["label.axisvalue"];
      }
    }

    if("undefined" !== typeof options["label.axis"]) {
      if(false === options["label.axis"]) {
        ensure('label',o).axis = function() {return null;};
      } else if("string" === typeof options["label.axis"]) {
        ensure('label',o).axis = options["label.axis"];
      }
    }

    if("undefined" !== typeof options["label.total"]) {
      if(false === options["label.total"]) {
        ensure('label',o).total = function() {return null;};
      } else if("string" === typeof options["label.total"]) {
        ensure('label',o).total = options["label.total"];
      }
    }

    if("undefined" !== typeof options["label.totalover"]) {
      if(false === options["label.totalover"]) {
        ensure('label',o).totalover = function() {return null;};
      } else if("string" === typeof options["label.totalover"]) {
        ensure('label',o).totalover = options["label.totalover"];
      }
    }
  }
});
define('config/chart/pivottableextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/htmlextract"
  , "config/chart/extract/pivottableextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/pivottableoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name  : "displaytotalcolumns",
      label : "columns",
      group : "displaytotals",
      event : "options.chart.pivottable.displaytotalcolumns",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "displaytotalrows",
      label : "rows",
      group : "displaytotals",
      event : "options.chart.pivottable.displaytotalrows",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "displayheatmap",
      label : "display colors",
      group : "pivottable",
      event : "options.chart.pivottable.displayheatmap",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });

    options.push({
      name  : "cellclass",
      label : "cell",
      group : "customclasses",
      event : "options.chart.pivottable.cellclass",
      editors : [{
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "valueclass",
      label : "value",
      group : "customclasses",
      event : "options.chart.pivottable.valueclass",
      editors : [{
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "headerclass",
      label : "header",
      group : "customclasses",
      event : "options.chart.pivottable.headerclass",
      editors : [{
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "totalclass",
      label : "total",
      group : "customclasses",
      event : "options.chart.pivottable.totalclass",
      editors : [{
        type  : "expression",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "axisvalue",
      label : "axis",
      event : "options.chart.label.axisvalue",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "total",
      label : "total",
      event : "options.chart.label.total",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "totalover",
      label : "total tooltip",
      event : "options.chart.label.totalover",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name  : "axis",
      label : "header",
      event : "options.chart.label.axis",
      group : "label",
      weight : -10,
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });
/*
    options.push({
      name  : "startcolor",
      label : "low color",
      group : "pivottable",
      event : "options.chart.pivottable.startcolor",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });
*/
  }
});
define('config/chart/pivottableoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/htmloptions"
  , "config/chart/options/pivottableoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/pivottable',[
    "config/chart/pivottableextractor"
  , "config/chart/pivottableoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "pivottable"
    , method : "pivotTable"
    , label : "Pivot Table"
    , extractOptions : extractor()
    , dimensions : [{
      name : "columns",
      isaxis : true,
      min  : 1,
      max  : null
    }, {
      name : "rows",
      isaxis : true,
      min  : 1,
      max  : null
    }, {
      name : "value",
      isaxis : true,
      min  : 1,
      max  : null
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});

// TODO ignoring column/row position;
define('config/chart/extract/scattergraphextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
//    if("undefined" !== typeof options["barchart.stacked"])
//      o.stacked = options["barchart.stacked"];
    if(options["scattergraph.symbol"]) {
      var expr = options["scattergraph.symbol"];
      if(((/^[a-z]+:=/i).test(expr))) {
        var parts = expr.split(":=");
        o.symbol = "=symbol('"+parts[0]+"',"+parts[1]+")";
      } else {
        o.symbol = expr;
      }
    }

    if(options["scattergraph.symbolstyle"]) {
      o.symbolstyle = options["scattergraph.symbolstyle"];
    }
  }
});
define('config/chart/scattergraphextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/cartesianextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/scattergraphextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/scattergraphoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};
    /*
     options.push({
     name  : "horizontal",
     group : "barchart",
     event : "options.chart.barchart.horizontal",
     editors : [{
     type  : "boolean",
     options : {
     default : false
     }
     }]
     });
     */



    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    var sizeeditor = { type : "expression", options : { default : "=64", unit : "px²", className : "small" }};
    options.push({
      name : "symbol",
      label : "shape",
      group : "symbol",
      event : "options.chart.scattergraph.symbol",
      editors : [{
        type : "selection",
        options : {
          values : [
              { value : "circle:",        label : "circle",          editor : sizeeditor }
            , { value : "square:",        label : "square",          editor : sizeeditor }
            , { value : "diamond:",       label : "diamond",         editor : sizeeditor }
            , { value : "cross:",         label : "cross",           editor : sizeeditor }
            , { value : "star:",          label : "star",            editor : sizeeditor }
            , { value : "triangleDown:",  label : "triangle down",   editor : sizeeditor }
            , { value : "triangleUp:",    label : "triangle up",     editor : sizeeditor }
            , { value : "arrowUp:",       label : "arrow up",        editor : sizeeditor }
            , { value : "arrowDown:",     label : "arrow down",      editor : sizeeditor }
            , { value : "arrowRight:",    label : "arrow right",     editor : sizeeditor }
            , { value : "arrowLeft:",     label : "arrow left",      editor : sizeeditor }
            , { value : "arrowDownWide:", label : "arrow down wide", editor : sizeeditor }
          ]
        }
      }, {
        type  : "expression",
        options : {
          default : "=symbol('circle',64)"
        }
      }]
    });

    options.push({
      name : "symbolstyle",
      label : "style",
      group : "symbol",
      event : "options.chart.scattergraph.symbolstyle",
      editors : [{
        type : "template",
        default : ""
      }]
    });
  }
});
define('config/chart/scattergraphoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/cartesianoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/scattergraphoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/scattergraph',[
    "config/chart/scattergraphextractor"
  , "config/chart/scattergraphoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "scattergraph"
    , method : "scatterGraph"
    , label : "Scatter Graph"
    , extractOptions : extractor()
    , dimensions : [{
      name : "x",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "y",
      isaxis : true,
      min  : 1,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});

// missing icon;
define('config/chart/extract/piechartextract',[
  "config/chart/extract/ensure"
],

function(ensure) {
  return function(o, dimensions, options) {
    if("undefined" !== typeof options["piechart.labelradius"] && options["piechart.labelradius"] !== 0.45)
      o.labelradius = options["piechart.labelradius"];

    if("undefined" !== typeof options["piechart.outerradius"] && options["piechart.outerradius"] !== 0.9)
      o.outerradius = options["piechart.outerradius"];

    if("undefined" !== typeof options["piechart.innerradius"] && options["piechart.innerradius"] !== 0.3)
      o.innerradius = options["piechart.innerradius"];

    if("undefined" !== typeof options["piechart.tooltipradius"] && options["piechart.tooltipradius"] !== 0.5)
      o.tooltipradius = options["piechart.tooltipradius"];

    if("undefined" !== typeof options["piechart.overradius"] && options["piechart.overradius"] !== 0.95)
      o.overradius = options["piechart.overradius"];

    if("undefined" !== typeof options["piechart.dontfliplabel"] && !options["piechart.dontfliplabel"])
      o.dontfliplabel = options["piechart.dontfliplabel"];
    
    if("undefined" !== typeof options["piechart.effect"] && options["piechart.effect"] !== "gradient")
      o.effect = options["piechart.effect"];

    if("undefined" !== typeof options["piechart.labelorientation"] && options["piechart.labelorientation"] !== "aligned")
      o.labelorientation = options["piechart.labelorientation"];

    if("undefined" !== typeof options["piechart.sort"] && options["piechart.sort"])
      o.sort = options["piechart.sort"];
  }
});
define('config/chart/piechartextractor',[
    "config/chart/extract/extractor"
  , "config/chart/extract/allextract"
  , "config/chart/extract/svgextract"
  , "config/chart/extract/piechartextract"
],

function(extractor) {
  var extractors = $.makeArray(arguments).slice(1);
  return function() {
    return extractor(extractors);
  };
});
define('config/chart/options/piechartoptions',[

],

function() {
  return function(options, preferences) {
    preferences = preferences || {};

    options.push({
      name : "datapoint",
      group : "label",
      event : "options.chart.label.datapoint",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }, {
        type  : "template",
        options : {
          default : ""
        }
      }]
    });

    options.push({
      name : "labelradius",
      label : "label",
      group : "piechartposition",
      event : "options.chart.piechart.labelradius",
      editors : [{
        type : "float",
        options : {
          default : 0.45,
          step : 0.05,
          min : 0,
          max : 1
        }
      }]
    });

    options.push({
      name : "outerradius",
      label : "external",
      group : "piechartposition",
      event : "options.chart.piechart.outerradius",
      editors : [{
        type : "float",
        options : {
          default : 0.9,
          step : 0.05,
          min : 0,
          max : 1
        }
      }]
    });

    options.push({
      name : "innerradius",
      label : "internal",
      group : "piechartposition",
      event : "options.chart.piechart.innerradius",
      editors : [{
        type : "float",
        options : {
          default : 0.0,
          step : 0.05,
          min : 0,
          max : 1
        }
      }]
    });

    options.push({
      name : "tooltipradius",
      label : "tooltip",
      group : "piechartposition",
      event : "options.chart.piechart.tooltipradius",
      editors : [{
        type : "float",
        options : {
          default : 0.5,
          step : 0.05,
          min : 0,
          max : 1
        }
      }]
    });

    options.push({
      name : "dontfliplabel",
      label : "don't flip",
      group : "label",
      event : "options.chart.piechart.dontfliplabel",
      editors : [{
        type  : "boolean",
        options : {
          default : true
        }
      }]
    });
/*
    options.push({
      name : "overradius",
      label : "over",
      group : "piechartposition",
      event : "options.chart.piechart.overradius",
      editors : [{
        type : "float",
        options : {
          default : 0.95,
          step : 0.05,
          min : 0,
          max : 1
        }
      }]
    });
*/
    options.push({
      name : "labelorientation",
      label : "orientantion",
      group : "label",
      event : "options.chart.piechart.labelorientation",
      editors : [{
        type : "selection",
        options : {
          default : "aligned",
          values : [
              { value : "aligned", label : "aligned" }
            , { value : "orthogonal", label : "orthogonal" }
            , { value : "fixed:0", label : "fixed", editor : { type : "float", options : { default : 0, step : 5} } }
          ]
        }
      }]
    });

    options.push({
      name  : "effect",
      group : "aesthetic",
      weight : 0,
      event : "options.chart.piechart.effect",
      editors : [{
        type  : "selection",
        options : {
          default : "gradient",
          values : [
              { value : "noeffect", label : "none" }
            , { value : "gradient", label : "gradient" }
            , { value : "gradient:1.25", label : "custom gradient", editor : { type : "float", options : { default : 1.25, min : -10, max : 10 } } }
          ]
        }
      }]
    });

    options.push({
      name : "sort",
      group : "piechart",
      weight : 0,
      event : "options.chart.piechart.sort",
      editors : [{
        type : "expression",
        options : {
          default : ""
        }
      }]
    });
  }
});
define('config/chart/piechartoptions',[
    "config/chart/options/applier"
  , "config/chart/options/alloptions"
  , "config/chart/options/rgcssoptions"
  , "config/chart/options/svgoptions"
  , "config/chart/options/piechartoptions"
],

function(applier) {
  var toapply = $.makeArray(arguments).slice(1);
  return function(options) {
    applier(toapply, options);
  };
});
define('config/chart/piechart',[
    "config/chart/piechartextractor"
  , "config/chart/piechartoptions"
],

function(extractor, applyOptions) {
  var chart = {
      type  : "piechart"
    , method : "pieChart"
    , label : "Pie Chart"
    , extractOptions : extractor()
    , dimensions : [{
      name : "label",
      isaxis : true,
      min  : 1,
      max  : 1
    }, {
      name : "measure",
      isaxis : true,
      min  : 1,
      max  : 1
    }],
    options : []
  };
  applyOptions(chart.options);
  return chart;
});
define('config/charts',[
    "jquery"
  , "config/chart/barchart"
  , "config/chart/linechart"
  , "config/chart/streamgraph"
  , "config/chart/funnelchart"
  , "config/chart/heatgrid"
  , "config/chart/leaderboard"
  , "config/chart/pivottable"
  , "config/chart/scattergraph"
  , "config/chart/piechart"
],

  // geo
  // sankey
  // dimensions for pivottable

function($) {
  var charts = $.makeArray(arguments).slice(1);

  var map = {},
      groups = {},
      counter = 0;
  $.each(charts, function() {
    map[this.type] = this;
    this.index = counter++;
  });

  return {
    map : map,
    list : charts
  }
});
define('modules/model/dimensionstyper',[
    "jquery"
  , "config/charts"
],

function($, charts) {
  return function(ctx) {
    function init(_, a2) {
      var type = a2[0];
      signalDimensions(type);
      ctx.on("chart.type.change", signalDimensions);
    }

    function signalDimensions(type) {
      // TODO, this highlights a problem with event handling priority
      setTimeout(function() {
        $(charts.map[type].dimensions).each(function(i, info) {
          ctx.trigger("chart.dimension.add", info);
        });
        $(charts.map[type].options).each(function(i, info) {
          ctx.trigger("chart.option.add", info);
        });
      }, 0);
    }

    ctx.when("app.ready", "chart.type.change").then(init);
  };
});
define('lib/model/loader/ajax',[
  "jquery"
],

function() {
  return function(url) {
    var xhr,
      f = function(success, error, progress) {
        xhr = $.ajax({
          url : url,
          beforeSend : function(xhr) {
            if(xhr.addEventListener && progress) {
              xhr.addEventListener("progress", function(evt) {
                if(evt.lengthComputable) {
                  progress(evt.loaded, evt.total);
                }
              });
            }
          },
          success : function(data, textStatus, xhr) {
            success(data);
          },
          error : function(xhr, textStatus, errorThrown) {
            error(errorThrown || textStatus);
          }
        });
      };
    f.abort = function() {
      if(xhr && xhr.abort) xhr.abort();
    }
    return f;
  };
});
define('lib/model/loader/array',[
  "jquery"
],

function() {
  return function(data) {
    return function(success, error, progress) {
      setTimeout(function() {
        success(data);
      }, 0);
    };
  };
});
define('lib/model/loader/text',[
  "jquery"
],

function() {
  return function(data) {
    var cache;
    return function(success, error, progress) {
      setTimeout(function() {
        if(cache) {
          success(cache);
          return;
        }
        try {
          cache = JSON.parse(data);
          if(!cache instanceof  Array || "object" !== typeof cache[0]) {
            error("data must be an array of objects");
          } else {
            success(cache);
          }
        } catch(e) {
          error("error parsing JSON text: " + e);
        }
      }, 0);
    };
  };
});
define('lib/util/md5',[

],

function() {
    var Md5 = {
        bitOR: function(a,b) { var lsb = a & 1 | b & 1; var msb31 = a >>> 1 | b >>> 1; return msb31 << 1 | lsb; },
        bitXOR: function(a,b) { var lsb = a & 1 ^ b & 1; var msb31 = a >>> 1 ^ b >>> 1; return msb31 << 1 | lsb; },
        bitAND: function(a,b) { var lsb = a & 1 & (b & 1); var msb31 = a >>> 1 & b >>> 1; return msb31 << 1 | lsb; },
        addme: function(x,y) { var lsw = (x & 65535) + (y & 65535); var msw = (x >> 16) + (y >> 16) + (lsw >> 16); return msw << 16 | lsw & 65535; },
        rhex: function(num) { var str = ""; var hex_chr = "0123456789abcdef"; var _g = 0; while(_g < 4) { var j = _g++; str += hex_chr.charAt(num >> j * 8 + 4 & 15) + hex_chr.charAt(num >> j * 8 & 15); } return str; },
        str2blks: function(str) { var nblk = (str.length + 8 >> 6) + 1, blks = [], _g1 = 0, _g = nblk * 16; while(_g1 < _g) { blks[++_g1] = 0; } var i = 0; while(i < str.length) { blks[i >> 2] |= str.charCodeAt(i) << (str.length * 8 + i) % 4 * 8; i++; } blks[i >> 2] |= 128 << (str.length * 8 + i) % 4 * 8; var l = str.length * 8; var k = nblk * 16 - 2; blks[k] = l & 255; blks[k] |= (l >>> 8 & 255) << 8; blks[k] |= (l >>> 16 & 255) << 16; blks[k] |= (l >>> 24 & 255) << 24; return blks; },
        rol: function(num,cnt) { return num << cnt | num >>> 32 - cnt; },
        cmn: function(q,a,b,x,s,t)  { return this.addme(this.rol(this.addme(this.addme(a,q),this.addme(x,t)),s),b); },
        ff: function(a,b,c,d,x,s,t) { return this.cmn(this.bitOR(this.bitAND(b,c),this.bitAND(~b,d)),a,b,x,s,t); },
        gg: function(a,b,c,d,x,s,t) { return this.cmn(this.bitOR(this.bitAND(b,d),this.bitAND(c,~d)),a,b,x,s,t); },
        hh: function(a,b,c,d,x,s,t) { return this.cmn(this.bitXOR(this.bitXOR(b,c),d),a,b,x,s,t); },
        ii: function(a,b,c,d,x,s,t) { return this.cmn(this.bitXOR(c,this.bitOR(b,~d)),a,b,x,s,t); },
        doEncode: function(str) { var x = this.str2blks(str),a = 1732584193,b = -271733879,c = -1732584194,d = 271733878,step,i = 0; while(i < x.length) { var olda = a;var oldb = b;var oldc = c;var oldd = d;step = 0;a = this.ff(a,b,c,d,x[i],7,-680876936);d = this.ff(d,a,b,c,x[i + 1],12,-389564586);c = this.ff(c,d,a,b,x[i + 2],17,606105819);b = this.ff(b,c,d,a,x[i + 3],22,-1044525330);a = this.ff(a,b,c,d,x[i + 4],7,-176418897);d = this.ff(d,a,b,c,x[i + 5],12,1200080426);c = this.ff(c,d,a,b,x[i + 6],17,-1473231341);b = this.ff(b,c,d,a,x[i + 7],22,-45705983);a = this.ff(a,b,c,d,x[i + 8],7,1770035416);d = this.ff(d,a,b,c,x[i + 9],12,-1958414417);c = this.ff(c,d,a,b,x[i + 10],17,-42063);b = this.ff(b,c,d,a,x[i + 11],22,-1990404162);a = this.ff(a,b,c,d,x[i + 12],7,1804603682);d = this.ff(d,a,b,c,x[i + 13],12,-40341101);c = this.ff(c,d,a,b,x[i + 14],17,-1502002290);b = this.ff(b,c,d,a,x[i + 15],22,1236535329);a = this.gg(a,b,c,d,x[i + 1],5,-165796510);d = this.gg(d,a,b,c,x[i + 6],9,-1069501632);c = this.gg(c,d,a,b,x[i + 11],14,643717713);b = this.gg(b,c,d,a,x[i],20,-373897302);a = this.gg(a,b,c,d,x[i + 5],5,-701558691);d = this.gg(d,a,b,c,x[i + 10],9,38016083);c = this.gg(c,d,a,b,x[i + 15],14,-660478335);b = this.gg(b,c,d,a,x[i + 4],20,-405537848);a = this.gg(a,b,c,d,x[i + 9],5,568446438);d = this.gg(d,a,b,c,x[i + 14],9,-1019803690);c = this.gg(c,d,a,b,x[i + 3],14,-187363961);b = this.gg(b,c,d,a,x[i + 8],20,1163531501);a = this.gg(a,b,c,d,x[i + 13],5,-1444681467);d = this.gg(d,a,b,c,x[i + 2],9,-51403784);c = this.gg(c,d,a,b,x[i + 7],14,1735328473);b = this.gg(b,c,d,a,x[i + 12],20,-1926607734);a = this.hh(a,b,c,d,x[i + 5],4,-378558);d = this.hh(d,a,b,c,x[i + 8],11,-2022574463);c = this.hh(c,d,a,b,x[i + 11],16,1839030562);b = this.hh(b,c,d,a,x[i + 14],23,-35309556);a = this.hh(a,b,c,d,x[i + 1],4,-1530992060);d = this.hh(d,a,b,c,x[i + 4],11,1272893353);c = this.hh(c,d,a,b,x[i + 7],16,-155497632);b = this.hh(b,c,d,a,x[i + 10],23,-1094730640);a = this.hh(a,b,c,d,x[i + 13],4,681279174);d = this.hh(d,a,b,c,x[i],11,-358537222);c = this.hh(c,d,a,b,x[i + 3],16,-722521979);b = this.hh(b,c,d,a,x[i + 6],23,76029189);a = this.hh(a,b,c,d,x[i + 9],4,-640364487);d = this.hh(d,a,b,c,x[i + 12],11,-421815835);c = this.hh(c,d,a,b,x[i + 15],16,530742520);b = this.hh(b,c,d,a,x[i + 2],23,-995338651);a = this.ii(a,b,c,d,x[i],6,-198630844);d = this.ii(d,a,b,c,x[i + 7],10,1126891415);c = this.ii(c,d,a,b,x[i + 14],15,-1416354905);b = this.ii(b,c,d,a,x[i + 5],21,-57434055);a = this.ii(a,b,c,d,x[i + 12],6,1700485571);d = this.ii(d,a,b,c,x[i + 3],10,-1894986606);c = this.ii(c,d,a,b,x[i + 10],15,-1051523);b = this.ii(b,c,d,a,x[i + 1],21,-2054922799);a = this.ii(a,b,c,d,x[i + 8],6,1873313359);d = this.ii(d,a,b,c,x[i + 15],10,-30611744);c = this.ii(c,d,a,b,x[i + 6],15,-1560198380);b = this.ii(b,c,d,a,x[i + 13],21,1309151649);a = this.ii(a,b,c,d,x[i + 4],6,-145523070);d = this.ii(d,a,b,c,x[i + 11],10,-1120210379);c = this.ii(c,d,a,b,x[i + 2],15,718787259);b = this.ii(b,c,d,a,x[i + 9],21,-343485551);a = this.addme(a,olda);b = this.addme(b,oldb);c = this.addme(c,oldc);d = this.addme(d,oldd);i += 16; } return this.rhex(a) + this.rhex(b) + this.rhex(c) + this.rhex(d); }
    };
   return function(s) {
       return Md5.doEncode(s);
   };
});
define('lib/model/dataloader',[
    "lib/util/dispatcher"
  , "lib/model/loader/ajax"
  , "lib/model/loader/array"
  , "lib/model/loader/text"
  , "lib/util/md5"
],

function(createDispatcher, createAjax, createArray, createText, md5) {
  var cache = {};
  return function(options) {
    var aborted = false,
        key,
        ds = createDispatcher(),
        loader;

    switch(options.type.toLowerCase()) {
      case "url":
        loader = createAjax(options.src);
        key = "url:"+options.src;
        break;
      case "text":
        loader = createText(options.data);
        key = "array:" + md5(options.data);
        break;
      case "array":
        loader = createArray(options.data);
        key = "array:" + md5(JSON.stringify(options.data));
        break;
      default:
        throw "a datasource of type '" + options.type + "' is not supported (yet)";
    }

    function success(data) {
      if(aborted) {
        error("user cancelled");
        return;
      }
      if(!options.nocache)
        cache[key] = data;
      ds.trigger("success", data);
      ds.trigger("complete");
    }

    function error(message) {
      ds.trigger("error", message);
      ds.trigger("complete");
    }

    ds.load = function() {
      ds.trigger("loading", ds);
      if(!options.nocache && cache[key]) {
        success(cache[key]);
        return;
      }
      loader(
        success,
        error,
        function(current, total) {
          ds.trigger("progress", current, total)
        }
      );
    };

    ds.abort = function() {
      if(aborted) return;
      aborted = true;
      if(loader.abort) loader.abort();
    };
    return ds;
  };
});
define('modules/model/chartbuilder',[
    "config/charts"
  , "lib/model/dataloader"
],

function(charts, createLoader) {
  return function(ctx) {
    var current = {
          type : null,
          datasource : null,
          fieldsmap : {},
          dimensions : {},
          options : {}
        }
      ;

    function extractAxes(type) {
      var axes = [],
          chartDimensions = charts.map[type].dimensions;
      for(var i = 0; i < chartDimensions.length; i++) {
        var dimension = chartDimensions[i],
            counter   = 0;
        if(!dimension.isaxis) continue;
        for(var j = 0; j < (dimension.max || current.dimensions[dimension.name].length); j++) {
          var o = current.dimensions[dimension.name][j];
          if(!o) break;
          var axis = {
                type : o.field.field
              };
          // TODO THIS SHOULD GO IN THE AXIS OPTIONS
          if(i > 0 && ["linechart", "barchart"].indexOf(type) >= 0)
            axis.variable = "dependent";
          axes.push(axis);
          counter++;
        }
        if(counter < dimension.min)
          return null;
      }
      return axes;
    }

    function triggerChart() {
      try {
        var dataloader = createLoader(current.datasource),
            options    = { },
            loader = function(handler) {
              dataloader.on("success", handler);
              dataloader.load();
            };
        var axes = extractAxes(current.type);
        if(axes === null)
          throw "not enough axes to feed the chart";
        charts.map[current.type].extractOptions(options, current.dimensions, current.options);
        ctx.log("CHART OPTIONS", JSON.stringify(options));
        ctx.trigger("chart.render.execute", { type : current.type, loader : loader, datasource : current.datasource, axes : axes, options : options });
      } catch(e) {
        ctx.trigger("chart.render.clear");
      }
    }

    var timer;
    function delayedTriggerChart() {
      clearTimeout(timer);
      timer = setTimeout(triggerChart, 200);
    }

    function changeDataSource(ds) {
      current.datasource = ds;
      current.fieldsmap = {};
      if(ds) {
        for(var i = 0; i < ds.fields.length; i++) {
          current.fieldsmap[ds.fields[i].field] = ds.fields[i];
        }
      }
      delayedTriggerChart();
    }

    function setAxis(types, info) {
      current.dimensions[info.name] = types.map(function(type) {
        return {
          name     : type.field,
          category : type.type,
          field    : current.fieldsmap[type.field]
        }
      });
      delayedTriggerChart();
    }

    function chartType(type) {
      current.type = type;
      current.dimensions = {};
      current.options = {};
      delayedTriggerChart();
    }

    function chartOptionSet(key, value) {
      current.options[key] = value;
      delayedTriggerChart();
    }

    ctx.on("chart.datasource.change", changeDataSource);
    ctx.on("chart.type.change", chartType);
    ctx.on("chart.axis.change", setAxis);
    ctx.on("chart.option.set", chartOptionSet);
  };
});
define('modules/model/datasourcebroker',[

],

function() {

  return function(ctx) {
    var map = {};

    ctx.on("data.datasource.add", function(item) {
      map[item.path] = item;
    });

    ctx.on("data.datasource.removebypath", function(path) {
      if(!map[path]) return;
      ctx.trigger("data.datasource.remove", map[path]);
    });

    ctx.on("data.folder.remove", function(path) {
      if(path.substr(-1) !== '/') path += '/';
      var len = path.length;
      console.log("REMOVE FOLDER", path);
      for(var key in map) {
        if(!map.hasOwnProperty(key)) continue;
        if(key.length >  len && key.substr(0, len) === path) {
          ctx.trigger("data.datasource.removebypath", key);
        }
      }
    });

    ctx.on("data.datasource.remove", function(item) {
      delete map[item.path];
    });

    ctx.on("data.datasource.select", function(path) {
      if(map[path])
        ctx.trigger("data.datasource.selected", map[path]);
    });

    ctx.on("data.datasource.deselect", function(path) {
      if(map[path])
        ctx.trigger("data.datasource.deselected", map[path]);
    });
  }
});
define('lib/util/compare',[

],

function() {
  return function(a, b) {
      return a < b ? -1 : (a > b ? 1 : 0);
  }
});
define('lib/model/filesystem',[
    "jquery"
  , "lib/util/compare"
],

function($, compare) {
  var SPLITTER = ":",
      PATTERN_NAME = /^[a-z]+[a-z0-9 _.-]*$/i;

  function validateName(name) {
    return PATTERN_NAME.test(name);
  }

  function normalize(path) {
    path = path.substr(0, 1) == "/" ? path.substr(1) : path;
    path = path.substr(-1) == "/" ? path.substr(0, path.length - 1) : path;
    return "/" + path;
  }

  function key(path, type) {
    return type + SPLITTER + path;
  }

  function extractNode(key, type) {
    return key.substr(type.length + SPLITTER.length);
  }

  function extractPathType(key) {
    var parts = key.split(SPLITTER);
    return { path : parts[1], type : parts[0] };
  }

  return function(o) {
    o = o || { };
    var types         = o.types || { "folder" : { "container" : ["folder"] } },
        defaultType   = o.defaultType || "folder",
        caseSensitive = "undefined" !== typeof o.caseSensitive ? !!o.caseSensitive : false,
        map           = { },
        cimap         = { }, // case insensitive
        containers    = { };

    var order = 0;
    for(var type in types) {
      if(types.hasOwnProperty(type)) {
        var contents = types[type].container;
        if(contents) {
          for(var i = 0; i < contents.length; i++) {
            var content = contents[i];
            if(!containers[content]) {
              containers[content] = type;
            }
          }
        }
        if("undefined" === typeof types[type].order)
          types[type].order = order++;
      }
    }

    function _isRoot(path, type) {
      return type === defaultType && "/" === path;
    }

    function _has(path, type) {
      if(caseSensitive)
        return !!map[key(path, type)];
      else
        return !!cimap[key(path, type).toLowerCase()];
    }

    function applyToSub(path, f) {
      for(var type in types) {
        if(types.hasOwnProperty(type)) {
          for(var mkey in map) {
            if(map.hasOwnProperty(mkey)) {
              var npath = key(path, type);
              if(path != '/')
                npath += '/';
              if(mkey.substr(0, npath.length) === npath) {
                f(extractNode(mkey, type), type);
              }
            }
          }
        }
      }
    }

    var fs = {
      has : function(path, type) {
        type = type || defaultType;
        return _has(path = normalize(path), type) || _isRoot(path, type);
      },
      validate : function(path, type) {
        type = type || defaultType;
        path = normalize(path)
        if(_has(path, type) || _isRoot(path, type))
          return "node already exists";
        var parts = path.substr(1).split("/"),
            name = parts[parts.length-1];
        if(!validateName(name))
          return "invalid characters in name";
        var parentPath = "/" + parts.slice(0, parts.length - 1).join("/"),
            parentType = this.typeContainerFor(type);
        if(!this.has(parentPath, parentType))
          return "parent node does not exist";
        return null;
      },
      add : function(path, type, recursive) {
        type = type || defaultType;
        recursive = !!recursive;
        if(_has(path = normalize(path), type) || _isRoot(path, type))
            return false;
        var parts = path.substr(1).split("/"),
            name = parts[parts.length-1];
        if(!validateName(name)) throw "invalid path name '"+name+"'";
        var parentPath = "/" + parts.slice(0, parts.length - 1).join("/"),
            parentType = this.typeContainerFor(type);
        if(recursive) {
          this.add(parentPath, parentType, true);
        } else {
          if(!this.has(parentPath, parentType))
            return false;
        }
        map[key(path, type)] = true;
        cimap[key(path, type).toLowerCase()] = true;
        $(fs).trigger("added", [path, type]);
        return true;
      },
      remove : function(path, type) {
        var k;
        type = type || defaultType;
        if(!_has(path = normalize(path), type) || _isRoot(path, type))
          return false;
        if(types[type].container) {
          applyToSub(path, function(cpath, ctype) {
            k = key(cpath, ctype);
            delete map[k];
            delete cimap[k.toLowerCase()];
            $(fs).trigger("removed", [cpath, ctype]);
          });
        }
        k = key(path, type);
        delete map[k];
        delete cimap[k.toLowerCase()];
        $(fs).trigger("removed", [path, type]);
        return true;
      },
      typeIsContainer : function(type) {
        return !!(types[type] && types[type].container);
      },
      typeCanContain : function(parent, child) {
        var t = types[parent];
        return (t && t.container && t.container.indexOf(child) >= 0);
      },
      typeContainerFor : function(type) {
        return containers[type];
      },
      typeOrder : function(type) {
        return types[type].order;
      },
      typeNames : function() {
        var r = [];
        for(var key in types) {
          if(types.hasOwnProperty(key)) {
            r.push(key);
          }
        }
        return r;
      },
      typeChildren : function(type) {
        return types[type].container;
      },
      list : function(path, type) {
        type = type || defaultType;
        if(!_has(path = normalize(path), type) && !_isRoot(path, type))
          return [];
        var r = [],
          len = path.length;
        applyToSub(path, function(cpath, ctype) {
          // skip nested paths
          var p = cpath.substr(len+(path === "/" ? 0 : 1));
          if(p !== "" && (p.indexOf("/") < 0))
            r.push({ path : p, type : ctype });
        });
        return r;
      },
      all : function() {
        type = type || defaultType;
        var r = [];
        for(var key in map) {
          if(map.hasOwnProperty(key)) {
            r.push(extractPathType(key));
          }
        }
        r.sort(function(a, b) {
          var comp = compare(types[a.type].order, types[b.type].order);
          return comp !== 0 ? comp : compare(a.path, b.path);
        });
        return r;
      }
    };
    return fs;
  }
});
define('lib/util/arrays',[

],

function() {
  return {
    diff : function(a1, a2) {
      return a1.filter(function(i) {return !(a2.indexOf(i) > -1);});
    },
    remove : function(arr, el) {
      var index = arr.indexOf(el);
      if(index < 0) return false;
      arr.splice(index, 1);
      return true;
    }
  }
});
define('modules/model/datasourcefilesystem',[
    "lib/model/filesystem"
  , "lib/util/arrays"
],

function(createfs, arrays) {

  return function(ctx) {
    var queue = [],
        fs = createfs({
          types : {
              "folder":     { "container" : ["datasource", "folder"] }
            , "datasource": { "container" : ["discrete", "continuous", "category", "time"] }
            , "category":   { "container" : false }
            , "ordinal":    { "container" : false }
            , "time":       { "container" : false }
            , "discrete":   { "container" : false }
            , "continuous": { "container" : false }
          },
          defaultType : "folder"
        });

    function dequeue() {
      if(!fs) return;
      while(queue.length > 0) {
        addItem(queue.shift());
      }
    }

    function addItem(item) {
      fs.add(item.path, "datasource", true);
      for(var i = 0; i < item.fields.length; i++) {
        var field = item.fields[i];
        fs.add(item.path+"/"+field.name, field.type, true);
      }
    }

    function removeItem(path, type) {
      fs.remove(path, type);
    }

    ctx.on("modules.ready", function() {
      ctx.trigger("data.system.ready", fs);
    });

    ctx.on("data.datasource.add", function(item) {
      queue.push(item);
      dequeue();
    });

    ctx.on("request.datasource.path.validate", function(path) {
      var validation = fs.validate(path, "datasource");
      ctx.trigger("response.datasource.path.validated", path, !validation, validation);
    });

    ctx.on("data.datasource.remove", function(item) {
      if(arrays.remove(queue, item))
        return;
      removeItem(item.path, "datasource");
    });
  };
});
define('modules/model/datasourcelocalstorage',[
  "lib/util/store"
],

function(createStore) {
  var STORE_NAME = "RGBUILDER:DATASOURCES",
      store = createStore(STORE_NAME, { list : [] });

  return function(ctx) {
    ctx.on("request.datasource.localstorage.hasdata", function() {
      var list = store.get("list"),
          initiallyEmpty = list.length === 0;
      for(var i = 0; i < list.length; i++) {
        ctx.trigger("data.datasource.add", list[i]);
      }

      ctx.on("data.datasource.add", function(ds) {
        list.push(ds);
        store.delayedCommit();
      });

      ctx.on("data.datasource.remove", function(ds) {
        for(var i = 0; i < list.length; i++) {
          if(list[i].path === ds.path) {
            list.splice(i, 1);
            store.delayedCommit();
            break;
          }
        }
      });

      ctx.trigger("response.datasource.localstorage.hasdata", !initiallyEmpty);
    });
  };
});
define('modules/model/reportsbroker',[],

function() {

  return function(ctx) {
    var map = {};

    ctx.on("reports.report.add", function(path, item) {
      map[path] = item;
    });

    ctx.on("reports.report.removebypath", function(path) {
      if(!map[path]) return;
      ctx.trigger("reports.report.remove", path, map[path]);
    });

    ctx.on("reports.folder.remove", function(path) {
      if(path.substr(-1) !== '/') path += '/';
      var len = path.length;
      for(var key in map) {
        if(!map.hasOwnProperty(key)) continue;
        if(key.length >  len && key.substr(0, len) === path) {
          ctx.trigger("reports.report.removebypath", key);
        }
      }
    });

    ctx.on("reports.report.remove", function(path, item) {
      delete map[path];
    });

    ctx.on("reports.report.select", function(path) {
      if(map[path])
        ctx.trigger("reports.report.selected", path, map[path]);
    });

    ctx.on("reports.report.deselect", function(path) {
      if(map[path])
        ctx.trigger("reports.report.deselected", path, map[path]);
    });

    ctx.on("reports.report.openpath", function(path) {
      if(!map[path]) return;
      ctx.trigger("chart.state.update", map[path]);
      ctx.trigger("chart.name.set", path.split("/").pop());
    });

    ctx.on("reports.report.exportpath", function(path) {
      if(!map[path]) return;
      ctx.trigger("reports.report.export", map[path], path);
    });
  };
});
define('modules/model/reportsfilesystem',[
    "lib/model/filesystem"
  , "lib/util/arrays"
],

function(createfs, arrays) {

  return function(ctx) {
    var queue = [],
        fs = createfs({
          types : {
              "folder": { "container" : ["report", "folder"] }
            , "report": { "container" : false }
          },
          defaultType : "folder"
        });

    function dequeue() {
      if(!fs) return;
      while(queue.length > 0) {
        addItem(queue.shift());
      }
    }

    function addItem(path) {
      fs.add(path, "report", true);
    }

    function removeItem(path, type) {
      fs.remove(path, type);
    }

    ctx.on("modules.ready", function() {
      ctx.trigger("reports.system.ready", fs);
    });

    ctx.on("reports.report.add", function(path) {
      queue.push(path);
      dequeue();
    });

    ctx.on("request.report.path.validate", function(path) {
      var validation = fs.validate(path, "report");
      ctx.trigger("response.report.path.validated", path, !validation, validation);
    });

    ctx.on("reports.report.remove", function(path) {
      if(arrays.remove(queue, path))
        return;
      removeItem(path, "report");
    });
  };
});
define('modules/model/reportslocalstorage',[
  "lib/util/store"
],

function(createStore) {
  var STORE_NAME = "RGBUILDER:REPORTS",
      store = createStore(STORE_NAME, { map : {} });

  return function(ctx) {
    var map = store.get("map");

    for(var path in map) {
      if(!map.hasOwnProperty(path)) continue;
      ctx.trigger("reports.report.add", path, map[path]);
    }

    ctx.on("reports.report.add", function(path, state) {
      map[path] = state;
      store.delayedCommit();
    });

    ctx.on("reports.report.remove", function(path) {
      delete map[path];
      store.delayedCommit();
    });
  };
});
define('modules/model/chartstate',[

],

function() {

  return function(ctx) {
    var timer,
        state;

    function reset() {
      state = {
        chart : "barchart",
        datasource : null,
        dimensions : {},
        options : {}
      };
    }
    reset();

    function delayed_change() {
      clearTimeout(timer);
      timer = setTimeout(change, 200);
    }

    function update(newstate) {
      unwire();
      state = newstate;

      ctx.trigger("chart.type.change", state.chart);
      ctx.trigger("chart.datasource.change", state.datasource);


      for(var name in state.dimensions) {
        if(!state.dimensions.hasOwnProperty(name)) continue;
        var dim = state.dimensions[name];
        ctx.trigger("chart.axis.change", dim.variable, dim.axis);
      }

      setTimeout(function() {
        for(var name in state.options) {
          if(!state.options.hasOwnProperty(name)) continue;
          ctx.trigger("chart.option.set", name, state.options[name].value, state.options[name].type);
        }

        wire();
        change();
      }, 0);
    }

    function change() {
      ctx.trigger("chart.state.change", state);
    }

    function type_change(chart) {
      state.chart = chart;
      delayed_change();
    }

    function datasource_change(datasource) {
      state.datasource = datasource;
      delayed_change();
    }

    function axis_change(variable, axis) {
      state.dimensions[axis.name] = { variable : variable, axis : axis };
      delayed_change();
    }

    function option_set(name, value, type) {
      state.options[name] = { value : value, type : type };
      delayed_change();
    }

    function wire() {
      ctx.on("chart.type.change", type_change);
      ctx.on("chart.datasource.change", datasource_change);
      ctx.on("chart.axis.change", axis_change);
      ctx.on("chart.option.set", option_set);
    }
    wire();

    function unwire() {
      ctx.off("chart.type.change", type_change);
      ctx.off("chart.datasource.change", datasource_change);
      ctx.off("chart.axis.change", axis_change);
      ctx.off("chart.option.set", option_set);
    }

    ctx.on("chart.state.reset", function() {
      reset();
    });

    ctx.on("chart.state.update", update);
  };
});
define('modules/view/brand',[
  "jquery"
],

function () {
  return function(ctx) {
    function init(el) {
        el.append($('<img src="images/logo.png" alt="ReportGrid - Builder (beta)">'));
    }

    ctx.one("view.main.toolbar-main", init);
  }
});
define('config/themes',[
  "jquery"
],

function($) {
  var themes = [{
    token : "gray",
    name : "gray",
    ui : "gray",
    group : "light"
  }, {
    token : "blue",
    name : "blue",
    ui : "blue",
    group : "light"
  }, {
    token : "dark",
    name : "dark",
    ui : "dark",
    group : "dark"
  }, {
    token : "black",
    name : "black",
    ui : "black",
    group : "dark"
  }];

  var map = {},
      groups = {};
  $.each(themes, function() {
    map[this.token] = this;
    groups[this.group] = groups[this.group] || {};
    groups[this.group][this.token] = this;
  });

  return {
    map : map,
    groups : groups
  }
});
define('modules/view/theme',[
    "jquery"
  , "config/themes"
],

function ($, themes) {
  var UI_BASE_THEME_URL = "css/jquery-ui/";

  function themeUrl(name) {
    return UI_BASE_THEME_URL + name + "/jquery-ui.css";
  }

  function pollCSS(url, callback) {
    function poll() {
      try {
        var sheets = document.styleSheets;
        for(var j=0, k=sheets.length; j<k; j++) {
          if(sheets[j].href == url) {
            sheets[j].cssRules;
          }
        }
        // If you made it here, success!
        setTimeout(callback, 0);
      } catch(e) {
        // Keep polling
        setTimeout(poll, 20);
      }
    };
    poll();
  }

  function setUITheme(name, callback) {
    var url = themeUrl(name),
      cssLink = $('<link href="'+url+'" type="text/css" rel="stylesheet" class="ui-theme" />');
    if($.browser.safari) {
      // no onload event
      pollCSS(url, callback);
    } else {
      cssLink.on("load", callback);
    }
    $("head").append(cssLink);

    if( $("link.ui-theme").size() > 3){
      $("link.ui-theme:first").remove();
    }
  }

  return function(ctx) {
    var current;
    ctx.on("theme.change", function(theme) {
      if(current === theme) return;
      current = theme;
      ctx.trigger("theme.changing", theme);
      setUITheme(themes.map[theme].ui, function() {
        ctx.trigger('view.theme.changed', theme);
      });
    });
  }
});
define('lib/util/dom',[

],

function() {
    return {
        selectText : function(element, start, end) {
            start = start || 0;
            end   = end || $(element).text().length;
            if(element.setSelectionRange) {
                element.focus();
                element.setSelectionRange(start, end);
            } else if(element.createTextRange) {
                var range = element.createTextRange();
                range.collapse(true);
                range.moveEnd('character', end);
                range.moveStart('character', start);
                range.select();
            }
        },
        canSelect : function(element) {
            return !!(element.setSelectionRange || element.createTextRange);
        }
    }
});
/*
 * jQuery Pines Notify (pnotify) Plugin 1.2.0
 *
 * http://pinesframework.org/pnotify/
 * Copyright (c) 2009-2012 Hunter Perrin
 *
 * Triple license under the GPL, LGPL, and MPL:
 *	  http://www.gnu.org/licenses/gpl.html
 *	  http://www.gnu.org/licenses/lgpl.html
 *	  http://www.mozilla.org/MPL/MPL-1.1.html
 */

(function($) {
	var history_handle_top,
		timer,
		body,
		jwindow = $(window),
		styling = {
			jqueryui: {
				container: "ui-widget ui-widget-content ui-corner-all",
				notice: "ui-state-highlight",
				// (The actual jQUI notice icon looks terrible.)
				notice_icon: "ui-icon ui-icon-info",
				info: "",
				info_icon: "ui-icon ui-icon-info",
				success: "ui-state-default",
				success_icon: "ui-icon ui-icon-circle-check",
				error: "ui-state-error",
				error_icon: "ui-icon ui-icon-alert",
				closer: "ui-icon ui-icon-close",
				pin_up: "ui-icon ui-icon-pin-w",
				pin_down: "ui-icon ui-icon-pin-s",
				hi_menu: "ui-state-default ui-corner-bottom",
				hi_btn: "ui-state-default ui-corner-all",
				hi_btnhov: "ui-state-hover",
				hi_hnd: "ui-icon ui-icon-grip-dotted-horizontal"
			},
			bootstrap: {
				container: "alert",
				notice: "",
				notice_icon: "icon-exclamation-sign",
				info: "alert-info",
				info_icon: "icon-info-sign",
				success: "alert-success",
				success_icon: "icon-ok-sign",
				error: "alert-error",
				error_icon: "icon-warning-sign",
				closer: "icon-remove",
				pin_up: "icon-pause",
				pin_down: "icon-play",
				hi_menu: "well",
				hi_btn: "btn",
				hi_btnhov: "",
				hi_hnd: "icon-chevron-down"
			}
		};
	// Set global variables.
	var do_when_ready = function(){
		body = $("body");
		jwindow = $(window);
		// Reposition the notices when the window resizes.
		jwindow.bind('resize', function(){
			if (timer)
				clearTimeout(timer);
			timer = setTimeout($.pnotify_position_all, 10);
		});
	};
	if (document.body)
		do_when_ready();
	else
		$(do_when_ready);
	$.extend({
		pnotify_remove_all: function () {
			var notices_data = jwindow.data("pnotify");
			/* POA: Added null-check */
			if (notices_data && notices_data.length) {
				$.each(notices_data, function(){
					if (this.pnotify_remove)
						this.pnotify_remove();
				});
			}
		},
		pnotify_position_all: function () {
			// This timer is used for queueing this function so it doesn't run
			// repeatedly.
			if (timer)
				clearTimeout(timer);
			timer = null;
			// Get all the notices.
			var notices_data = jwindow.data("pnotify");
			if (!notices_data || !notices_data.length)
				return;
			// Reset the next position data.
			$.each(notices_data, function(){
				var s = this.opts.stack;
				if (!s) return;
				s.nextpos1 = s.firstpos1;
				s.nextpos2 = s.firstpos2;
				s.addpos2 = 0;
				s.animation = true;
			});
			$.each(notices_data, function(){
				this.pnotify_position();
			});
		},
		pnotify: function(options) {
			// Stores what is currently being animated (in or out).
			var animating;

			// Build main options.
			var opts;
			if (typeof options != "object") {
				opts = $.extend({}, $.pnotify.defaults);
				opts.text = options;
			} else {
				opts = $.extend({}, $.pnotify.defaults, options);
			}
			// Translate old pnotify_ style options.
			for (var i in opts) {
				if (typeof i == "string" && i.match(/^pnotify_/))
					opts[i.replace(/^pnotify_/, "")] = opts[i];
			}

			if (opts.before_init) {
				if (opts.before_init(opts) === false)
					return null;
			}

			// This keeps track of the last element the mouse was over, so
			// mouseleave, mouseenter, etc can be called.
			var nonblock_last_elem;
			// This is used to pass events through the notice if it is non-blocking.
			var nonblock_pass = function(e, e_name){
				pnotify.css("display", "none");
				var element_below = document.elementFromPoint(e.clientX, e.clientY);
				pnotify.css("display", "block");
				var jelement_below = $(element_below);
				var cursor_style = jelement_below.css("cursor");
				pnotify.css("cursor", cursor_style != "auto" ? cursor_style : "default");
				// If the element changed, call mouseenter, mouseleave, etc.
				if (!nonblock_last_elem || nonblock_last_elem.get(0) != element_below) {
					if (nonblock_last_elem) {
						dom_event.call(nonblock_last_elem.get(0), "mouseleave", e.originalEvent);
						dom_event.call(nonblock_last_elem.get(0), "mouseout", e.originalEvent);
					}
					dom_event.call(element_below, "mouseenter", e.originalEvent);
					dom_event.call(element_below, "mouseover", e.originalEvent);
				}
				dom_event.call(element_below, e_name, e.originalEvent);
				// Remember the latest element the mouse was over.
				nonblock_last_elem = jelement_below;
			};

			// Get our styling object.
			var styles = styling[opts.styling];

			// Create our widget.
			// Stop animation, reset the removal timer, and show the close
			// button when the user mouses over.
			var pnotify = $("<div />", {
				"class": "ui-pnotify "+opts.addclass,
				"css": {"display": "none"},
				"mouseenter": function(e){
					if (opts.nonblock) e.stopPropagation();
					if (opts.mouse_reset && animating == "out") {
						// If it's animating out, animate back in really quickly.
						pnotify.stop(true);
						animating = "in";
						pnotify.css("height", "auto").animate({"width": opts.width, "opacity": opts.nonblock ? opts.nonblock_opacity : opts.opacity}, "fast");
					}
					if (opts.nonblock) {
						// If it's non-blocking, animate to the other opacity.
						pnotify.animate({"opacity": opts.nonblock_opacity}, "fast");
					}
					// Stop the close timer.
					if (opts.hide && opts.mouse_reset) pnotify.pnotify_cancel_remove();
					// Show the buttons.
					if (opts.sticker && !opts.nonblock) pnotify.sticker.trigger("pnotify_icon").css("visibility", "visible");
					if (opts.closer && !opts.nonblock) pnotify.closer.css("visibility", "visible");
				},
				"mouseleave": function(e){
					if (opts.nonblock) e.stopPropagation();
					nonblock_last_elem = null;
					pnotify.css("cursor", "auto");
					// Animate back to the normal opacity.
					if (opts.nonblock && animating != "out")
						pnotify.animate({"opacity": opts.opacity}, "fast");
					// Start the close timer.
					if (opts.hide && opts.mouse_reset) pnotify.pnotify_queue_remove();
					// Hide the buttons.
					if (opts.sticker_hover)
						pnotify.sticker.css("visibility", "hidden");
					if (opts.closer_hover)
						pnotify.closer.css("visibility", "hidden");
					$.pnotify_position_all();
				},
				"mouseover": function(e){
					if (opts.nonblock) e.stopPropagation();
				},
				"mouseout": function(e){
					if (opts.nonblock) e.stopPropagation();
				},
				"mousemove": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "onmousemove");
					}
				},
				"mousedown": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						e.preventDefault();
						nonblock_pass(e, "onmousedown");
					}
				},
				"mouseup": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						e.preventDefault();
						nonblock_pass(e, "onmouseup");
					}
				},
				"click": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "onclick");
					}
				},
				"dblclick": function(e){
					if (opts.nonblock) {
						e.stopPropagation();
						nonblock_pass(e, "ondblclick");
					}
				}
			});
			pnotify.opts = opts;
			// Create a container for the notice contents.
			pnotify.container = $("<div />", {"class": styles.container+" ui-pnotify-container "+(opts.type == "error" ? styles.error : (opts.type == "info" ? styles.info : (opts.type == "success" ? styles.success : styles.notice)))})
			.appendTo(pnotify);
			if (opts.cornerclass != "")
				pnotify.container.removeClass("ui-corner-all").addClass(opts.cornerclass);
			// Create a drop shadow.
			if (opts.shadow)
				pnotify.container.addClass("ui-pnotify-shadow");

			// The current version of Pines Notify.
			pnotify.pnotify_version = "1.2.0";

			// This function is for updating the notice.
			pnotify.pnotify = function(options) {
				// Update the notice.
				var old_opts = opts;
				if (typeof options == "string")
					opts.text = options;
				else
					opts = $.extend({}, opts, options);
				// Translate old pnotify_ style options.
				for (var i in opts) {
					if (typeof i == "string" && i.match(/^pnotify_/))
						opts[i.replace(/^pnotify_/, "")] = opts[i];
				}
				pnotify.opts = opts;
				// Update the corner class.
				if (opts.cornerclass != old_opts.cornerclass)
					pnotify.container.removeClass("ui-corner-all").addClass(opts.cornerclass);
				// Update the shadow.
				if (opts.shadow != old_opts.shadow) {
					if (opts.shadow)
						pnotify.container.addClass("ui-pnotify-shadow");
					else
						pnotify.container.removeClass("ui-pnotify-shadow");
				}
				// Update the additional classes.
				if (opts.addclass === false)
					pnotify.removeClass(old_opts.addclass);
				else if (opts.addclass !== old_opts.addclass)
					pnotify.removeClass(old_opts.addclass).addClass(opts.addclass);
				// Update the title.
				if (opts.title === false)
					pnotify.title_container.slideUp("fast");
				else if (opts.title !== old_opts.title) {
					if (opts.title_escape)
						pnotify.title_container.text(opts.title).slideDown(200);
					else
						pnotify.title_container.html(opts.title).slideDown(200);
				}
				// Update the text.
				if (opts.text === false) {
					pnotify.text_container.slideUp("fast");
				} else if (opts.text !== old_opts.text) {
					if (opts.text_escape)
						pnotify.text_container.text(opts.text).slideDown(200);
					else
						pnotify.text_container.html(opts.insert_brs ? String(opts.text).replace(/\n/g, "<br />") : opts.text).slideDown(200);
				}
				// Update values for history menu access.
				pnotify.pnotify_history = opts.history;
				pnotify.pnotify_hide = opts.hide;
				// Change the notice type.
				if (opts.type != old_opts.type)
					pnotify.container.removeClass(styles.error+" "+styles.notice+" "+styles.success+" "+styles.info).addClass(opts.type == "error" ? styles.error : (opts.type == "info" ? styles.info : (opts.type == "success" ? styles.success : styles.notice)));
				if (opts.icon !== old_opts.icon || (opts.icon === true && opts.type != old_opts.type)) {
					// Remove any old icon.
					pnotify.container.find("div.ui-pnotify-icon").remove();
					if (opts.icon !== false) {
						// Build the new icon.
						$("<div />", {"class": "ui-pnotify-icon"})
						.append($("<span />", {"class": opts.icon === true ? (opts.type == "error" ? styles.error_icon : (opts.type == "info" ? styles.info_icon : (opts.type == "success" ? styles.success_icon : styles.notice_icon))) : opts.icon}))
						.prependTo(pnotify.container);
					}
				}
				// Update the width.
				if (opts.width !== old_opts.width)
					pnotify.animate({width: opts.width});
				// Update the minimum height.
				if (opts.min_height !== old_opts.min_height)
					pnotify.container.animate({minHeight: opts.min_height});
				// Update the opacity.
				if (opts.opacity !== old_opts.opacity)
					pnotify.fadeTo(opts.animate_speed, opts.opacity);
				// Update the sticker and closer buttons.
				if (!opts.closer || opts.nonblock)
					pnotify.closer.css("display", "none");
				else
					pnotify.closer.css("display", "block");
				if (!opts.sticker || opts.nonblock)
					pnotify.sticker.css("display", "none");
				else
					pnotify.sticker.css("display", "block");
				// Update the sticker icon.
				pnotify.sticker.trigger("pnotify_icon");
				// Update the hover status of the buttons.
				if (opts.sticker_hover)
					pnotify.sticker.css("visibility", "hidden");
				else if (!opts.nonblock)
					pnotify.sticker.css("visibility", "visible");
				if (opts.closer_hover)
					pnotify.closer.css("visibility", "hidden");
				else if (!opts.nonblock)
					pnotify.closer.css("visibility", "visible");
				// Update the timed hiding.
				if (!opts.hide)
					pnotify.pnotify_cancel_remove();
				else if (!old_opts.hide)
					pnotify.pnotify_queue_remove();
				pnotify.pnotify_queue_position();
				return pnotify;
			};

			// Position the notice. dont_skip_hidden causes the notice to
			// position even if it's not visible.
			pnotify.pnotify_position = function(dont_skip_hidden){
				// Get the notice's stack.
				var s = pnotify.opts.stack;
				if (!s) return;
				if (!s.nextpos1)
					s.nextpos1 = s.firstpos1;
				if (!s.nextpos2)
					s.nextpos2 = s.firstpos2;
				if (!s.addpos2)
					s.addpos2 = 0;
				var hidden = pnotify.css("display") == "none";
				// Skip this notice if it's not shown.
				if (!hidden || dont_skip_hidden) {
					var curpos1, curpos2;
					// Store what will need to be animated.
					var animate = {};
					// Calculate the current pos1 value.
					var csspos1;
					switch (s.dir1) {
						case "down":
							csspos1 = "top";
							break;
						case "up":
							csspos1 = "bottom";
							break;
						case "left":
							csspos1 = "right";
							break;
						case "right":
							csspos1 = "left";
							break;
					}
					curpos1 = parseInt(pnotify.css(csspos1));
					if (isNaN(curpos1))
						curpos1 = 0;
					// Remember the first pos1, so the first visible notice goes there.
					if (typeof s.firstpos1 == "undefined" && !hidden) {
						s.firstpos1 = curpos1;
						s.nextpos1 = s.firstpos1;
					}
					// Calculate the current pos2 value.
					var csspos2;
					switch (s.dir2) {
						case "down":
							csspos2 = "top";
							break;
						case "up":
							csspos2 = "bottom";
							break;
						case "left":
							csspos2 = "right";
							break;
						case "right":
							csspos2 = "left";
							break;
					}
					curpos2 = parseInt(pnotify.css(csspos2));
					if (isNaN(curpos2))
						curpos2 = 0;
					// Remember the first pos2, so the first visible notice goes there.
					if (typeof s.firstpos2 == "undefined" && !hidden) {
						s.firstpos2 = curpos2;
						s.nextpos2 = s.firstpos2;
					}
					// Check that it's not beyond the viewport edge.
					if ((s.dir1 == "down" && s.nextpos1 + pnotify.height() > jwindow.height()) ||
						(s.dir1 == "up" && s.nextpos1 + pnotify.height() > jwindow.height()) ||
						(s.dir1 == "left" && s.nextpos1 + pnotify.width() > jwindow.width()) ||
						(s.dir1 == "right" && s.nextpos1 + pnotify.width() > jwindow.width()) ) {
						// If it is, it needs to go back to the first pos1, and over on pos2.
						s.nextpos1 = s.firstpos1;
						s.nextpos2 += s.addpos2 + (typeof s.spacing2 == "undefined" ? 25 : s.spacing2);
						s.addpos2 = 0;
					}
					// Animate if we're moving on dir2.
					if (s.animation && s.nextpos2 < curpos2) {
						switch (s.dir2) {
							case "down":
								animate.top = s.nextpos2+"px";
								break;
							case "up":
								animate.bottom = s.nextpos2+"px";
								break;
							case "left":
								animate.right = s.nextpos2+"px";
								break;
							case "right":
								animate.left = s.nextpos2+"px";
								break;
						}
					} else
						pnotify.css(csspos2, s.nextpos2+"px");
					// Keep track of the widest/tallest notice in the column/row, so we can push the next column/row.
					switch (s.dir2) {
						case "down":
						case "up":
							if (pnotify.outerHeight(true) > s.addpos2)
								s.addpos2 = pnotify.height();
							break;
						case "left":
						case "right":
							if (pnotify.outerWidth(true) > s.addpos2)
								s.addpos2 = pnotify.width();
							break;
					}
					// Move the notice on dir1.
					if (s.nextpos1) {
						// Animate if we're moving toward the first pos.
						if (s.animation && (curpos1 > s.nextpos1 || animate.top || animate.bottom || animate.right || animate.left)) {
							switch (s.dir1) {
								case "down":
									animate.top = s.nextpos1+"px";
									break;
								case "up":
									animate.bottom = s.nextpos1+"px";
									break;
								case "left":
									animate.right = s.nextpos1+"px";
									break;
								case "right":
									animate.left = s.nextpos1+"px";
									break;
							}
						} else
							pnotify.css(csspos1, s.nextpos1+"px");
					}
					// Run the animation.
					if (animate.top || animate.bottom || animate.right || animate.left)
						pnotify.animate(animate, {duration: 500, queue: false});
					// Calculate the next dir1 position.
					switch (s.dir1) {
						case "down":
						case "up":
							s.nextpos1 += pnotify.height() + (typeof s.spacing1 == "undefined" ? 25 : s.spacing1);
							break;
						case "left":
						case "right":
							s.nextpos1 += pnotify.width() + (typeof s.spacing1 == "undefined" ? 25 : s.spacing1);
							break;
					}
				}
			};

			// Queue the positiona all function so it doesn't run repeatedly and
			// use up resources.
			pnotify.pnotify_queue_position = function(milliseconds){
				if (timer)
					clearTimeout(timer);
				if (!milliseconds)
					milliseconds = 10;
				timer = setTimeout($.pnotify_position_all, milliseconds);
			};

			// Display the notice.
			pnotify.pnotify_display = function() {
				// If the notice is not in the DOM, append it.
				if (!pnotify.parent().length)
					pnotify.appendTo(body);
				// Run callback.
				if (opts.before_open) {
					if (opts.before_open(pnotify) === false)
						return;
				}
				// Try to put it in the right position.
				if (opts.stack.push != "top")
					pnotify.pnotify_position(true);
				// First show it, then set its opacity, then hide it.
				if (opts.animation == "fade" || opts.animation.effect_in == "fade") {
					// If it's fading in, it should start at 0.
					pnotify.show().fadeTo(0, 0).hide();
				} else {
					// Or else it should be set to the opacity.
					if (opts.opacity != 1)
						pnotify.show().fadeTo(0, opts.opacity).hide();
				}
				pnotify.animate_in(function(){
					if (opts.after_open)
						opts.after_open(pnotify);

					pnotify.pnotify_queue_position();

					// Now set it to hide.
					if (opts.hide)
						pnotify.pnotify_queue_remove();
				});
			};

			// Remove the notice.
			pnotify.pnotify_remove = function() {
				if (pnotify.timer) {
					window.clearTimeout(pnotify.timer);
					pnotify.timer = null;
				}
				// Run callback.
				if (opts.before_close) {
					if (opts.before_close(pnotify) === false)
						return;
				}
				pnotify.animate_out(function(){
					if (opts.after_close) {
						if (opts.after_close(pnotify) === false)
							return;
					}
					pnotify.pnotify_queue_position();
					// If we're supposed to remove the notice from the DOM, do it.
					if (opts.remove)
						pnotify.detach();
				});
			};

			// Animate the notice in.
			pnotify.animate_in = function(callback){
				// Declare that the notice is animating in. (Or has completed animating in.)
				animating = "in";
				var animation;
				if (typeof opts.animation.effect_in != "undefined")
					animation = opts.animation.effect_in;
				else
					animation = opts.animation;
				if (animation == "none") {
					pnotify.show();
					callback();
				} else if (animation == "show")
					pnotify.show(opts.animate_speed, callback);
				else if (animation == "fade")
					pnotify.show().fadeTo(opts.animate_speed, opts.opacity, callback);
				else if (animation == "slide")
					pnotify.slideDown(opts.animate_speed, callback);
				else if (typeof animation == "function")
					animation("in", callback, pnotify);
				else
					pnotify.show(animation, (typeof opts.animation.options_in == "object" ? opts.animation.options_in : {}), opts.animate_speed, callback);
			};

			// Animate the notice out.
			pnotify.animate_out = function(callback){
				// Declare that the notice is animating out. (Or has completed animating out.)
				animating = "out";
				var animation;
				if (typeof opts.animation.effect_out != "undefined")
					animation = opts.animation.effect_out;
				else
					animation = opts.animation;
				if (animation == "none") {
					pnotify.hide();
					callback();
				} else if (animation == "show")
					pnotify.hide(opts.animate_speed, callback);
				else if (animation == "fade")
					pnotify.fadeOut(opts.animate_speed, callback);
				else if (animation == "slide")
					pnotify.slideUp(opts.animate_speed, callback);
				else if (typeof animation == "function")
					animation("out", callback, pnotify);
				else
					pnotify.hide(animation, (typeof opts.animation.options_out == "object" ? opts.animation.options_out : {}), opts.animate_speed, callback);
			};

			// Cancel any pending removal timer.
			pnotify.pnotify_cancel_remove = function() {
				if (pnotify.timer)
					window.clearTimeout(pnotify.timer);
			};

			// Queue a removal timer.
			pnotify.pnotify_queue_remove = function() {
				// Cancel any current removal timer.
				pnotify.pnotify_cancel_remove();
				pnotify.timer = window.setTimeout(function(){
					pnotify.pnotify_remove();
				}, (isNaN(opts.delay) ? 0 : opts.delay));
			};

			// Provide a button to close the notice.
			pnotify.closer = $("<div />", {
				"class": "ui-pnotify-closer",
				"css": {"cursor": "pointer", "visibility": opts.closer_hover ? "hidden" : "visible"},
				"click": function(){
					pnotify.pnotify_remove();
					pnotify.sticker.css("visibility", "hidden");
					pnotify.closer.css("visibility", "hidden");
				}
			})
			.append($("<span />", {"class": styles.closer}))
			.appendTo(pnotify.container);
			if (!opts.closer || opts.nonblock)
				pnotify.closer.css("display", "none");

			// Provide a button to stick the notice.
			pnotify.sticker = $("<div />", {
				"class": "ui-pnotify-sticker",
				"css": {"cursor": "pointer", "visibility": opts.sticker_hover ? "hidden" : "visible"},
				"click": function(){
					opts.hide = !opts.hide;
					if (opts.hide)
						pnotify.pnotify_queue_remove();
					else
						pnotify.pnotify_cancel_remove();
					$(this).trigger("pnotify_icon");
				}
			})
			.bind("pnotify_icon", function(){
				$(this).children().removeClass(styles.pin_up+" "+styles.pin_down).addClass(opts.hide ? styles.pin_up : styles.pin_down);
			})
			.append($("<span />", {"class": styles.pin_up}))
			.appendTo(pnotify.container);
			if (!opts.sticker || opts.nonblock)
				pnotify.sticker.css("display", "none");

			// Add the appropriate icon.
			if (opts.icon !== false) {
				$("<div />", {"class": "ui-pnotify-icon"})
				.append($("<span />", {"class": opts.icon === true ? (opts.type == "error" ? styles.error_icon : (opts.type == "info" ? styles.info_icon : (opts.type == "success" ? styles.success_icon : styles.notice_icon))) : opts.icon}))
				.prependTo(pnotify.container);
			}

			// Add a title.
			pnotify.title_container = $("<h4 />", {
				"class": "ui-pnotify-title"
			})
			.appendTo(pnotify.container);
			if (opts.title === false)
				pnotify.title_container.hide();
			else if (opts.title_escape)
				pnotify.title_container.text(opts.title);
			else
				pnotify.title_container.html(opts.title);

			// Add text.
			pnotify.text_container = $("<div />", {
				"class": "ui-pnotify-text"
			})
			.appendTo(pnotify.container);
			if (opts.text === false)
				pnotify.text_container.hide();
			else if (opts.text_escape)
				pnotify.text_container.text(opts.text);
			else
				pnotify.text_container.html(opts.insert_brs ? String(opts.text).replace(/\n/g, "<br />") : opts.text);

			// Set width and min height.
			if (typeof opts.width == "string")
				pnotify.css("width", opts.width);
			if (typeof opts.min_height == "string")
				pnotify.container.css("min-height", opts.min_height);

			// The history variable controls whether the notice gets redisplayed
			// by the history pull down.
			pnotify.pnotify_history = opts.history;
			// The hide variable controls whether the history pull down should
			// queue a removal timer.
			pnotify.pnotify_hide = opts.hide;

			// Add the notice to the notice array.
			var notices_data = jwindow.data("pnotify");
			if (notices_data == null || typeof notices_data != "object")
				notices_data = [];
			if (opts.stack.push == "top")
				notices_data = $.merge([pnotify], notices_data);
			else
				notices_data = $.merge(notices_data, [pnotify]);
			jwindow.data("pnotify", notices_data);
			// Now position all the notices if they are to push to the top.
			if (opts.stack.push == "top")
				pnotify.pnotify_queue_position(1);

			// Run callback.
			if (opts.after_init)
				opts.after_init(pnotify);

			if (opts.history) {
				// If there isn't a history pull down, create one.
				var history_menu = jwindow.data("pnotify_history");
				if (typeof history_menu == "undefined") {
					history_menu = $("<div />", {
						"class": "ui-pnotify-history-container "+styles.hi_menu,
						"mouseleave": function(){
							history_menu.animate({top: "-"+history_handle_top+"px"}, {duration: 100, queue: false});
						}
					})
					.append($("<div />", {"class": "ui-pnotify-history-header", "text": "Redisplay"}))
					.append($("<button />", {
							"class": "ui-pnotify-history-all "+styles.hi_btn,
							"text": "All",
							"mouseenter": function(){
								$(this).addClass(styles.hi_btnhov);
							},
							"mouseleave": function(){
								$(this).removeClass(styles.hi_btnhov);
							},
							"click": function(){
								// Display all notices. (Disregarding non-history notices.)
								$.each(notices_data, function(){
									if (this.pnotify_history) {
										if (this.is(":visible")) {
											if (this.pnotify_hide)
												this.pnotify_queue_remove();
										} else if (this.pnotify_display)
											this.pnotify_display();
									}
								});
								return false;
							}
					}))
					.append($("<button />", {
							"class": "ui-pnotify-history-last "+styles.hi_btn,
							"text": "Last",
							"mouseenter": function(){
								$(this).addClass(styles.hi_btnhov);
							},
							"mouseleave": function(){
								$(this).removeClass(styles.hi_btnhov);
							},
							"click": function(){
								// Look up the last history notice, and display it.
								var i = -1;
								var notice;
								do {
									if (i == -1)
										notice = notices_data.slice(i);
									else
										notice = notices_data.slice(i, i+1);
									if (!notice[0])
										break;
									i--;
								} while (!notice[0].pnotify_history || notice[0].is(":visible"));
								if (!notice[0])
									return false;
								if (notice[0].pnotify_display)
									notice[0].pnotify_display();
								return false;
							}
					}))
					.appendTo(body);

					// Make a handle so the user can pull down the history tab.
					var handle = $("<span />", {
						"class": "ui-pnotify-history-pulldown "+styles.hi_hnd,
						"mouseenter": function(){
							history_menu.animate({top: "0"}, {duration: 100, queue: false});
						}
					})
					.appendTo(history_menu);

					// Get the top of the handle.
					history_handle_top = handle.offset().top + 2;
					// Hide the history pull down up to the top of the handle.
					history_menu.css({top: "-"+history_handle_top+"px"});
					// Save the history pull down.
					jwindow.data("pnotify_history", history_menu);
				}
			}

			// Mark the stack so it won't animate the new notice.
			opts.stack.animation = false;

			// Display the notice.
			pnotify.pnotify_display();

			return pnotify;
		}
	});

	// Some useful regexes.
	var re_on = /^on/,
		re_mouse_events = /^(dbl)?click$|^mouse(move|down|up|over|out|enter|leave)$|^contextmenu$/,
		re_ui_events = /^(focus|blur|select|change|reset)$|^key(press|down|up)$/,
		re_html_events = /^(scroll|resize|(un)?load|abort|error)$/;
	// Fire a DOM event.
	var dom_event = function(e, orig_e){
		var event_object;
		e = e.toLowerCase();
		if (document.createEvent && this.dispatchEvent) {
			// FireFox, Opera, Safari, Chrome
			e = e.replace(re_on, '');
			if (e.match(re_mouse_events)) {
				// This allows the click event to fire on the notice. There is
				// probably a much better way to do it.
				$(this).offset();
				event_object = document.createEvent("MouseEvents");
				event_object.initMouseEvent(
					e, orig_e.bubbles, orig_e.cancelable, orig_e.view, orig_e.detail,
					orig_e.screenX, orig_e.screenY, orig_e.clientX, orig_e.clientY,
					orig_e.ctrlKey, orig_e.altKey, orig_e.shiftKey, orig_e.metaKey, orig_e.button, orig_e.relatedTarget
				);
			} else if (e.match(re_ui_events)) {
				event_object = document.createEvent("UIEvents");
				event_object.initUIEvent(e, orig_e.bubbles, orig_e.cancelable, orig_e.view, orig_e.detail);
			} else if (e.match(re_html_events)) {
				event_object = document.createEvent("HTMLEvents");
				event_object.initEvent(e, orig_e.bubbles, orig_e.cancelable);
			}
			if (!event_object) return;
			this.dispatchEvent(event_object);
		} else {
			// Internet Explorer
			if (!e.match(re_on)) e = "on"+e;
			event_object = document.createEventObject(orig_e);
			this.fireEvent(e, event_object);
		}
	};

	$.pnotify.defaults = {
		// The notice's title.
		title: false,
		// Whether to escape the content of the title. (Not allow HTML.)
		title_escape: false,
		// The notice's text.
		text: false,
		// Whether to escape the content of the text. (Not allow HTML.)
		text_escape: false,
		// What styling classes to use. (Can be either jqueryui or bootstrap.)
		styling: "bootstrap",
		// Additional classes to be added to the notice. (For custom styling.)
		addclass: "",
		// Class to be added to the notice for corner styling.
		cornerclass: "",
		// Create a non-blocking notice. It lets the user click elements underneath it.
		nonblock: false,
		// The opacity of the notice (if it's non-blocking) when the mouse is over it.
		nonblock_opacity: .2,
		// Display a pull down menu to redisplay previous notices, and place the notice in the history.
		history: true,
		// Width of the notice.
		width: "300px",
		// Minimum height of the notice. It will expand to fit content.
		min_height: "16px",
		// Type of the notice. "notice", "info", "success", or "error".
		type: "notice",
		// Set icon to true to use the default icon for the selected style/type, false for no icon, or a string for your own icon class.
		icon: true,
		// The animation to use when displaying and hiding the notice. "none", "show", "fade", and "slide" are built in to jQuery. Others require jQuery UI. Use an object with effect_in and effect_out to use different effects.
		animation: "fade",
		// Speed at which the notice animates in and out. "slow", "def" or "normal", "fast" or number of milliseconds.
		animate_speed: "slow",
		// Opacity of the notice.
		opacity: 1,
		// Display a drop shadow.
		shadow: true,
		// Provide a button for the user to manually close the notice.
		closer: true,
		// Only show the closer button on hover.
		closer_hover: true,
		// Provide a button for the user to manually stick the notice.
		sticker: true,
		// Only show the sticker button on hover.
		sticker_hover: true,
		// After a delay, remove the notice.
		hide: true,
		// Delay in milliseconds before the notice is removed.
		delay: 8000,
		// Reset the hide timer if the mouse moves over the notice.
		mouse_reset: true,
		// Remove the notice's elements from the DOM after it is removed.
		remove: true,
		// Change new lines to br tags.
		insert_brs: true,
		// The stack on which the notices will be placed. Also controls the direction the notices stack.
		stack: {"dir1": "down", "dir2": "left", "push": "bottom", "spacing1": 25, "spacing2": 25}
	};
})(jQuery);
define("ext/jquery-pnotify/jquery.pnotify", function(){});

define('lib/util/notification',[
      "lib/util/dom"
    , "ext/jquery-pnotify/jquery.pnotify"
],

function(dom) {
    var timeout = 5000,
        shorttimeout = 2500,
        longtimeout  = 10000;

    function defaultHandler(v) { return v; };

    var map = [
          { src : "text", dst : "text", handler : defaultHandler }
        , { src : "type", dst : "type", handler : defaultHandler }
        , { src : "icon", dst : "notice_icon", handler : function(v) { return "ui-icon "+v; } }
        , { src : "timeout", dst : "delay", handler : defaultHandler }
        , { src : "hide", dst : "hide", handler : defaultHandler }
        , { src : "before_open", dst : "before_open", handler : defaultHandler }
        , { src : "before_close", dst : "before_close", handler : defaultHandler }
        , { src : "after_open",  dst : "after_open", handler : defaultHandler }
        , { src : "after_close", dst : "after_close", handler : defaultHandler }
        , { src : "history", dst : "history", handler : defaultHandler }
        , { src : "sticker", dst : "sticker", handler : defaultHandler }
        , { src : "width", dst : "width", handler : defaultHandler }
        , { src : "min_height", dst : "min_height", handler : defaultHandler }
        , { src : "opacity", dst : "opacity", handler : defaultHandler }
        , { src : "stack", dst : "stack", handler : defaultHandler }
        , { src : "shadow", dst : "shadow", handler : defaultHandler }
    ];

    function applyOptions(src, dst, map) {
        for(var i = 0; i < map.length; i++) {
            if("undefined" !== typeof src[map[i].src]) {
                dst[map[i].dst] = map[i].handler(src[map[i].src]);
            }
        }
    }

    return {
        success : function(title, o) {
            o = o || {};

            var options = {
                  title : title
                , shadow : true
                , delay : timeout
                , sticker : false
                , insert_brs : false
                , styling : "jqueryui"
                , title_escape : false
                , text_escape : false
            };

            applyOptions(o, options, map);

            if(!options.text) options.text = "";
            options.text += '\n<div class="clear"></div>';

            return $.pnotify(options);
        },

        context : function(title, o) {
            o = o || {};
            o.voffset = o.voffset || 25;
            o.width = o.width || '420px';

            var n = this.tip(title, o);

            n.mouseenter(function() {
                var selectOpened = false;
                $('select').click(function(e) {
                    selectOpened = !selectOpened;
                    e.stopPropagation();
                });
                $('body').click(function() {
                    if(selectOpened) {
                        selectOpened = false;
                    }
                });

                n.mouseleave(function() {
                    if(!selectOpened) {
                        n.remove();
                    }
                });
            });

            return n;
        },

        copier : function(title, o) {
            o = o || {};

            var keycombo = navigator.userAgent.indexOf("Mac OS X") != -1 ? "CMD+C" : "CTRL+C";
            o.text = '<div class="message">'+ o.text+'</div><div class="textarea"><textarea>'+ o.copy+'</textarea></div><div class="footer">'+keycombo+' to copy the link</div>';

            var n = this.context(title, o),
                area = n.find("textarea");

            area.click(function() {
                dom.selectText(area.get(0));
            });

            setTimeout(function() {
                dom.selectText(area.get(0));
            }, 500);

            return n;
        },

        menu : function(o) {
          var noty,
              items = o.items || [];
          function closeMenu() {
            noty.hide();
          }

          $("body").on("mouseup", closeMenu);
          o.voffset = 0;
          o.before_close = function() {
            $("body").off("mouseup", closeMenu);
          };
          o.text = '<ul class="menu"></ul>';
          noty = this.tip("something", o);
          noty.find(".ui-pnotify-icon,.ui-pnotify-closer,.ui-pnotify-sticker,.ui-pnotify-title").hide();

          var ul = noty.find("ul.menu");

          var length = 0;

          function createItem(item) {
            var li = $('<li>'+item.content+'</li>'),
                index = length;
            ul.append(li);
            li.click(function() {
              $(noty).trigger("select", [item.data, index]);
            });
            length++;
          }

          function removeItem(index) {
            length--;
            throw "NOT IMPLEMENTED REMOVEITEM IN NOTIFICATION";
          }

          $(items).each(function(index, item) {
            createItem(item);
          });

          noty.menu = {
            add : function(item) {
              createItem(item);
            },
            remove : removeItem
          };

          return noty;
        },

        tip : function(title, o) {
            o = o || {};
            o.history = false;
            o.sticker = false;
            o.hide = false;
            o.stack = false;
            o.shadow = true;
            o.type = o.type || "info";
            o.opacity = 0.95;
            o.voffset = o.voffset || 40;
            o.hoffset = o.hoffset || 10;

            var el = o.target || document.body,
                n = this.success(title, o);

            function position() {
                var pos = $(el).offset(),
                    vw  = $(el).outerWidth(),
                    ww  = n.outerWidth();

                var left = (vw - ww) / 2 + pos.left;
                if(left < o.hoffset)
                    left = o.hoffset;
                else if(left + ww + o.hoffset > $(window).width())
                    left = $(window).width() - o.hoffset - ww;
                n.css({
                    left : left+"px",
                    top  : (pos.top + o.voffset)+"px"
                });
            }

            $(window).on("resize", position);

            function remove_resize() {
                $(window).off("resize", position);
            }

            var old = o.before_close;
            o.before_close = function(e) {
                if(old)
                    old.apply(this, e);
                remove_resize(this, e);
            };

            setTimeout(position, 0);
            return n;
        },

        main : function(title, o) {
            o = o || {};
            o.history = false;
            o.sticker = false;
            o.width = '500px';
            if(!o.min_height) o.min_height = '300px';
            o.hide = false;
            o.stack = false;
            o.shadow = true;
            o.type = "info";
            o.opacity = 0.95;

            var old = o.before_close;
            o.before_close = function(e) {
                if(old)
                    old.apply(this, e);
                remove_resize(this, e);
            };

            var n = this.success(title, o);

            function center() {
                var vw = $(window).width(),
                    vh = $(window).height(),
                    ww = n.outerWidth(),
                    wh = n.outerHeight();
                n.css({
                    left : ((vw-ww)/2)+"px",
                    top  : ((vh-wh)/2)+"px"
                });
            }

            $(window).on("resize", center);

            function remove_resize() {
                $(window).off("resize", center);
            }

            setTimeout(center, 0);
            return n;
        },
        quick : function(title, o) {
            o = o || {};
            o.timeout = shorttimeout;
            return this.success(title, o);
        },
        progress : function(title, o) {
            var cur_value = 1,
                pnotify,
                $progress,
                $message,
                text = o.text || "";
            // progress
            // complete

            var k;

            o.hide = false;
            o.text = '<div class="message">'+text+'</div><div class="progress-bar"></div>';
            o.before_open = function(pn) {
                pnotify = pn;
                $progress = pn.find("div.progress-bar");
                $message = pn.find("div.message");
            };

            o.progressStart = function(message) {
                clearInterval(k);
                pnotify.show();
                $message.removeClass("ui-state-error")
                $message.html(message);
                $progress.show();
                $progress.progressbar({
                    value : 0
                });
            };

            o.progressStep = function(value) {
                var v = value * 100;
                if(v > 100) v = 100;
                $progress.progressbar({
                    value : v
                });
            };

            o.progressComplete = function(message) {
                $message.html(message);
                $progress.hide();
                k = setTimeout(function() {
                    pnotify.hide();
                }, longtimeout);
            };

            o.progressError = function(err) {
                $progress.hide();
                $message.addClass("ui-state-error").html(err);
                k = setTimeout(function() {
                    pnotify.hide();
                }, longtimeout);
            };

            return o.el = this.success(title, o);
        }
    }
});
define('lib/util/uid',[

],

function() {
  var S4 = function ()
  {
    return Math.floor(
      Math.random() * 0x10000 /* 65536 */
    ).toString(16);
  };

  return function() {
    return (
      S4() + S4() + "-" +
      S4() + "-" +
      S4() + "-" +
      S4() + "-" +
      S4() + S4() + S4()
    );
  }
});
/*! jQuery UI - v1.9.0pre - 2012-09-12
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2012 jQuery Foundation and other contributors; Licensed MIT */

(function( $, undefined ) {

var uuid = 0,
	runiqueId = /^ui-id-\d+$/;

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "@VERSION",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.css(this,'position')) && (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.css(this,'overflow')+$.css(this,'overflow-y')+$.css(this,'overflow-x'));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	uniqueId: function() {
		return this.each(function() {
			if ( !this.id ) {
				this.id = "ui-id-" + (++uuid);
			}
		});
	},

	removeUniqueId: function() {
		return this.each(function() {
			if ( runiqueId.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.css( this, "visibility" ) === "hidden" ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the element to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});





// deprecated

$.fn.extend({
	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var i,
				proto = $.ui[ module ].prototype;
			for ( i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var i,
				set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) {
				return;
			}

			for ( i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},

	contains: $.contains,

	// only used by resizable
	hasScroll: function( el, a ) {

		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );

(function( $, undefined ) {

var uuid = 0,
	slice = Array.prototype.slice,
	_cleanData = $.cleanData;
$.cleanData = function( elems ) {
	for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
		try {
			$( elem ).triggerHandler( "remove" );
		// http://bugs.jquery.com/ticket/8235
		} catch( e ) {}
	}
	_cleanData( elems );
};

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( $.isFunction( value ) ) {
			prototype[ prop ] = (function() {
				var _super = function() {
						return base.prototype[ prop ].apply( this, arguments );
					},
					_superApply = function( args ) {
						return base.prototype[ prop ].apply( this, args );
					};
				return function() {
					var __super = this._super,
						__superApply = this._superApply,
						returnValue;

					this._super = _super;
					this._superApply = _superApply;

					returnValue = value.apply( this, arguments );

					this._super = __super;
					this._superApply = __superApply;

					return returnValue;
				};
			})();
		}
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: name
	}, prototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		// TODO remove widgetBaseClass, see #8155
		widgetBaseClass: fullName,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );
};

$.widget.extend = function( target ) {
	var input = slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if (input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				target[ key ] = $.isPlainObject( value ) ? $.widget.extend( {}, target[ key ], value ) : value;
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					new object( options, this );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			// 1.9 BC for #7810
			// TODO remove dual storage
			$.data( element, this.widgetName, this );
			$.data( element, this.widgetFullName, this );
			this._on({ remove: "destroy" });
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			// 1.9 BC for #7810
			// TODO remove dual storage
			.removeData( this.widgetName )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( value === undefined ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( value === undefined ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.hoverable.removeClass( "ui-state-hover" );
			this.focusable.removeClass( "ui-state-focus" );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_on: function( element, handlers ) {
		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
		} else {
			// accept selectors, DOM elements
			element = $( element );
			this.bindings = this.bindings.add( element );
		}

		var instance = this;
		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^(\w+)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				instance.widget().delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] ) ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	$.Widget.prototype._getCreateOptions = function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	};
}

})( jQuery );

(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	version: "@VERSION",
	options: {
		cancel: 'input,textarea,button,select,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
					$.removeData(event.target, that.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return; }

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "@VERSION",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() { 
			this.parentNode.removeChild(this); 
		});
		
		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.droppable", {
	version: "@VERSION",
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				// find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(':data(droppable)').filter(function () {
					return $.data(this, 'droppable').options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);

(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	version: "@VERSION",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var that = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				that.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		var cursor = $('.ui-resizable-' + this.axis).css('cursor');
		$('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			that = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]);

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, that = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) },
				left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

		b = {
			minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			// We want to create an enclosing box whose aspect ration is the requested one
			// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
			if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
			if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
			if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).data("resizable"), o = that.options, os = that.originalSize, op = that.originalPosition;

		var delta = {
			height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
			top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, 
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options;

		var pr = that._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : that.sizeDiff.height,
						soffsetw = ista ? 0 : that.sizeDiff.width;

		var style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
					left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
						top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css('width'), 10),
						height: parseInt(that.element.css('height'), 10),
						top: parseInt(that.element.css('top'), 10),
						left: parseInt(that.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, el = that.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		that.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			that.containerOffset = { left: 0, top: 0 };
			that.containerPosition = { left: 0, top: 0 };

			that.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = that.containerOffset, ch = that.containerSize.height,	cw = that.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			that.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options,
				ps = that.containerSize, co = that.containerOffset, cs = that.size, cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = that.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (that._helper ? co.left : 0)) {
			that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
			that.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (that._helper ? co.top : 0)) {
			that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left+that.position.left;
		that.offset.top = that.parentData.top+that.position.top;

		var woset = Math.abs( (that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width ),
					hoset = Math.abs( (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height );

		var isParent = that.containerElement.get(0) == that.element.parent().get(0),
			isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= that.parentData.left;

		if (woset + that.size.width >= that.parentData.width) {
			that.size.width = that.parentData.width - woset;
			if (pRatio) that.size.height = that.size.width / that.aspectRatio;
		}

		if (hoset + that.size.height >= that.parentData.height) {
			that.size.height = that.parentData.height - hoset;
			if (pRatio) that.size.width = that.size.height * that.aspectRatio;
		}
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options, cp = that.position,
				co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement;

		var helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;

		if (that._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (that._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var that = $(this).data("resizable"), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		that.ghost.appendTo(that.helper);

	},

	resize: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost) that.ghost.css({ position: 'relative', height: that.size.height, width: that.size.width });
	},

	stop: function(event, ui){
		var that = $(this).data("resizable"), o = that.options;
		if (that.ghost && that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var that = $(this).data("resizable"), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.left = op.left - ox;
		}
		else {
			that.size.width = os.width + ox;
			that.size.height = os.height + oy;
			that.position.top = op.top - oy;
			that.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);

(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	version: "@VERSION",
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var that = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == that.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

})(jQuery);

(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	version: "@VERSION",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		//We're ready to go
		this.ready = true

	},

	_destroy: function() {
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData(this.widgetName + "-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;

			this.widget().toggleClass( "ui-sortable-disabled", !!value );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + '-item') == that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + '-item') == that) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, this._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			// Only put the placeholder inside the current Container, skip all
			// items form other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this moving items in "sub-sortables" can cause the placeholder to jitter
			// beetween the outer and inner container.
			if (item.instance !== this.currentContainer) continue;

			if (itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var that = this;
			var cur = this.placeholder.offset();

			this.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var o = that.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(that.currentItem[0].nodeName))
						.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop')||0, 10) - parseInt(that.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft')||0, 10) - parseInt(that.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {

		// get innermost container that intersects with item
		var innermostContainer = null, innermostIndex = null;


		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) return;

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top'];
			for (var j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				var cur = this.containers[innermostIndex].floating ? this.items[j].item.offset().left : this.items[j].item.offset().top;
				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = (cur - base > 0) ? 'down' : 'up';
				}
			}

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});

})(jQuery);

;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [],
			source;

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && $.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v, i ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q,
		r, g, b;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = "";

			if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
					curElem = hook === "backgroundColor" ? elem.parentNode : elem;
					while (
						(backgroundColor === "" || backgroundColor === "transparent") &&
						curElem && curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, "backgroundColor" );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
						backgroundColor :
						"_default" );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( value ) {
				// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		camelCase,
		len;

	// webkit enumerates style porperties
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, '' );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "@VERSION",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all optinos as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect)
	if ( options === undefined ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat && $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

$.fn.extend({
	effect: function( effect, options, speed, callback ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod && backCompat && $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));

(function( $, undefined ) {

var uid = 0,
	hideProps = {},
	showProps = {},
	showPropsAdjust = {};

hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
	hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
showProps.height = showProps.paddingTop = showProps.paddingBottom =
	showProps.borderTopWidth = showProps.borderBottomWidth = "show";
$.extend( showPropsAdjust, showProps, { accordionHeight: "show" } );

$.fx.step.accordionHeight = function( fx ) {
	var elem = $( fx.elem ),
		data = elem.data( "ui-accordion-height" );
	elem.height( data.total - elem.outerHeight() - data.toHide.outerHeight() + elem.height() );
};

$.widget( "ui.accordion", {
	version: "@VERSION",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	_create: function() {
		var accordionId = this.accordionId = "ui-accordion-" +
				(this.element.attr( "id" ) || ++uid),
			options = this.options;

		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" );

		this.headers = this.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" );
		this._hoverable( this.headers );
		this._focusable( this.headers );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.hide();

		// don't allow collapsible: false and active: false
		if ( !options.collapsible && options.active === false ) {
			options.active = 0;
		}
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active" )
			.toggleClass( "ui-corner-all ui-corner-top" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this._createIcons();
		this.originalHeight = this.element[0].style.height;
		this.refresh();

		// ARIA
		this.element.attr( "role", "tablist" );

		this.headers
			.attr( "role", "tab" )
			.each(function( i ) {
				var header = $( this ),
					headerId = header.attr( "id" ),
					panel = header.next(),
					panelId = panel.attr( "id" );
				if ( !headerId ) {
					headerId = accordionId + "-header-" + i;
					header.attr( "id", headerId );
				}
				if ( !panelId ) {
					panelId = accordionId + "-panel-" + i;
					panel.attr( "id", panelId );
				}
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-expanded": "false",
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}

		this._on( this.headers, { keydown: "_keydown" });
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._setupEvents( options.event );
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			content: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.each(function() {
				if ( /^ui-accordion/.test( this.id ) ) {
					this.removeAttribute( "id" );
				}
			});
		if ( this.options.heightStyle !== "content" ) {
			this.element.css( "height", this.originalHeight );
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown : function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var maxHeight, overflow,
			heightStyle = this.options.heightStyle,
			parent = this.element.parent();

		this.element.css( "height", this.originalHeight );

		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				})
				.height( maxHeight );
		}

		if ( heightStyle !== "content" ) {
			this.element.height( this.element.height() );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( !event ) {
			return;
		}
		$.each( event.split(" "), function( index, eventName ) {
			events[ eventName ] = "_eventHandler";
		});
		this._on( this.headers, events );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr({
				"aria-expanded": "true",
				"aria-hidden": "false"
			})
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				toShow.removeData( "ui-accordion-height" );
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( hideProps, duration, easing );
		toShow
			.hide()
			.data( "ui-accordion-height", {
				total: total,
				toHide: toHide
			})
			.animate( this.options.heightStyle === "content" ? showProps : showPropsAdjust,
				duration, easing, complete );
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[0].className = toHide.parent()[0].className;
		}

		this._trigger( "activate", null, data );
	}
});



// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// navigation options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			navigation: false,
			navigationFilter: function() {
				return this.href.toLowerCase() === location.href.toLowerCase();
			}
		});

		var _create = prototype._create;
		prototype._create = function() {
			if ( this.options.navigation ) {
				var that = this,
					headers = this.element.find( this.options.header ),
					content = headers.next(),
					current = headers.add( content )
						.find( "a" )
						.filter( this.options.navigationFilter )
						[ 0 ];
				if ( current ) {
					headers.add( content ).each( function( index ) {
						if ( $.contains( this, current ) ) {
							that.options.active = Math.floor( index / 2 );
							return false;
						}
					});
				}
			}
			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// height options
	(function( $, prototype ) {
		$.extend( prototype.options, {
			heightStyle: null, // remove default so we fall back to old values
			autoHeight: true, // use heightStyle: "auto"
			clearStyle: false, // use heightStyle: "content"
			fillSpace: false // use heightStyle: "fill"
		});

		var _create = prototype._create,
			_setOption = prototype._setOption;

		$.extend( prototype, {
			_create: function() {
				this.options.heightStyle = this.options.heightStyle ||
					this._mergeHeightStyle();

				_create.call( this );
			},

			_setOption: function( key, value ) {
				if ( key === "autoHeight" || key === "clearStyle" || key === "fillSpace" ) {
					this.options.heightStyle = this._mergeHeightStyle();
				}
				_setOption.apply( this, arguments );
			},

			_mergeHeightStyle: function() {
				var options = this.options;

				if ( options.fillSpace ) {
					return "fill";
				}

				if ( options.clearStyle ) {
					return "content";
				}

				if ( options.autoHeight ) {
					return "auto";
				}
			}
		});
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// icon options
	(function( $, prototype ) {
		$.extend( prototype.options.icons, {
			activeHeader: null, // remove default so we fall back to old values
			headerSelected: "ui-icon-triangle-1-s"
		});

		var _createIcons = prototype._createIcons;
		prototype._createIcons = function() {
			if ( this.options.icons ) {
				this.options.icons.activeHeader = this.options.icons.activeHeader ||
					this.options.icons.headerSelected;
			}
			_createIcons.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// expanded active option, activate method
	(function( $, prototype ) {
		prototype.activate = prototype._activate;

		var _findActive = prototype._findActive;
		prototype._findActive = function( index ) {
			if ( index === -1 ) {
				index = false;
			}
			if ( index && typeof index !== "number" ) {
				index = this.headers.index( this.headers.filter( index ) );
				if ( index === -1 ) {
					index = false;
				}
			}
			return _findActive.call( this, index );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// resize method
	jQuery.ui.accordion.prototype.resize = jQuery.ui.accordion.prototype.refresh;

	// change events
	(function( $, prototype ) {
		$.extend( prototype.options, {
			change: null,
			changestart: null
		});

		var _trigger = prototype._trigger;
		prototype._trigger = function( type, event, data ) {
			var ret = _trigger.apply( this, arguments );
			if ( !ret ) {
				return false;
			}

			if ( type === "beforeActivate" ) {
				ret = _trigger.call( this, "changestart", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			} else if ( type === "activate" ) {
				ret = _trigger.call( this, "change", event, {
					oldHeader: data.oldHeader,
					oldContent: data.oldPanel,
					newHeader: data.newHeader,
					newContent: data.newPanel
				});
			}
			return ret;
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );

	// animated option
	// NOTE: this only provides support for "slide", "bounceslide", and easings
	// not the full $.ui.accordion.animations API
	(function( $, prototype ) {
		$.extend( prototype.options, {
			animate: null,
			animated: "slide"
		});

		var _create = prototype._create;
		prototype._create = function() {
			var options = this.options;
			if ( options.animate === null ) {
				if ( !options.animated ) {
					options.animate = false;
				} else if ( options.animated === "slide" ) {
					options.animate = 300;
				} else if ( options.animated === "bounceslide" ) {
					options.animate = {
						duration: 200,
						down: {
							easing: "easeOutBounce",
							duration: 1000
						}
					};
				} else {
					options.animate = options.animated;
				}
			}

			_create.call( this );
		};
	}( jQuery, jQuery.ui.accordion.prototype ) );
}

})( jQuery );

(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	version: "@VERSION",
	defaultElement: "<input>",
	options: {
		appendTo: "body",
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput;

		this.isMultiLine = this._isMultiLine();
		this.valueMethod = this.element[ this.element.is( "input,textarea" ) ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on({
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( this.document.find( this.options.appendTo || "body" )[ 0 ] )
			.menu({
				// custom key handling for now
				input: $(),
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.zIndex( this.element.zIndex() + 1 )
			.hide()
			.data( "menu" );
		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				// #7024 - Prevent accidental activation of menu items in Firefox
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				} else {
					// Normally the input is populated with the item's value as the
					// menu is navigated, causing screen readers to notice a change and
					// announce the item. Since the focus event was canceled, this doesn't
					// happen, so we update the live region so that screen readers can
					// still notice the change and announce it.
					this.liveRegion.text( item.value );
				}
			},
			menuselect: function( event, ui ) {
				// back compat for _renderItem using item.autocomplete, via #7810
				// TODO remove the fallback, see #8156
				var item = ui.item.data( "ui-autocomplete-item" ) || ui.item.data( "item.autocomplete" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[0] !== this.document[0].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "polite"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.insertAfter( this.element );

		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this.document.find( value || "body" )[0] );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isMultiLine: function() {
		// Textareas are always multi-line
		if ( this.element.is( "textarea" ) ) {
			return true;
		}
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		if ( this.element.is( "input" ) ) {
			return false;
		}
		// All other element types are determined by whether or not they're contentEditable
		return this.element.prop( "isContentEditable" );
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data, status ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {
			// only search if the value has changed
			if ( this.term !== this._value() ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( "ui-autocomplete-loading" );
			}
		};
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<a>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {
			this._value( this.term );
			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function( value ) {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});


// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.text( message );
	}
});


}( jQuery ));

(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "@VERSION",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			hoverClass = "ui-state-hover" + ( !toggleButton ? " ui-state-active" : "" ),
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus" + this.eventNamespace, function() {
				// no need to check disabled, focus won't be triggered anyway
				that.buttonElement.addClass( focusClass );
			})
			.bind( "blur" + this.eventNamespace, function() {
				that.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				if ( clickDragged ) {
					return;
				}
				that.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup" + this.eventNamespace, function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", that.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
			} else {
				this.element.prop( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( ":disabled" );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "@VERSION",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";

		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

}( jQuery ) );

(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "@VERSION" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',
	
	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},
	
	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker(); 
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + 
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	   If false returned from beforeShow event handler do not show. 
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			//false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft());
		var viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
		while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
		}
		var position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) )
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			var extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, 'stepMonths');
		var id = '#' + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find('[data-handler]').map(function () {
			var handler = {
				prev: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, -stepMonths, 'M');
				},
				next: function () {
					window['DP_jQuery_' + dpuuid].datepicker._adjustDate(id, +stepMonths, 'M');
				},
				hide: function () {
					window['DP_jQuery_' + dpuuid].datepicker._hideDatepicker();
				},
				today: function () {
					window['DP_jQuery_' + dpuuid].datepicker._gotoToday(id);
				},
				selectDay: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
					return false;
				},
				selectMonth: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'M');
					return false;
				},
				selectYear: function () {
					window['DP_jQuery_' + dpuuid].datepicker._selectMonthYear(id, this, 'Y');
					return false;
				}
			};
			$(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
		});
	},
	
	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">' +
			this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' data-handler="selectDay" data-event="click" data-month="' + printDate.getMonth() + '" data-year="' + printDate.getFullYear() + '"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' + 
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';
				
				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */ 
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.delegate(selector, 'mouseout', function() {
			$(this).removeClass('ui-state-hover');
			if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).removeClass('ui-datepicker-prev-hover');
			if (this.className.indexOf('ui-datepicker-next') != -1) $(this).removeClass('ui-datepicker-next-hover');
		})
		.delegate(selector, 'mouseover', function(){
			if (!$.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
				$(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
				$(this).addClass('ui-state-hover');
				if (this.className.indexOf('ui-datepicker-prev') != -1) $(this).addClass('ui-datepicker-prev-hover');
				if (this.className.indexOf('ui-datepicker-next') != -1) $(this).addClass('ui-datepicker-next-hover');
			}
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
	                Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){
	
	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}
	
	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find(document.body).append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "@VERSION";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);

(function( $, undefined ) {

var uiDialogClasses = "ui-dialog ui-widget ui-widget-content ui-corner-all ",
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	};

$.widget("ui.dialog", {
	version: "@VERSION",
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: "close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// ensure that the titlebar is never outside the document
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: "",
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr( "title" );
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}
		this.oldPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.options.title = this.options.title || this.originalTitle;
		var that = this,
			options = this.options,

			title = options.title || "&#160;",

			uiDialog = ( this.uiDialog = $( "<div>" ) )
				.addClass( uiDialogClasses + options.dialogClass )
				.css({
					display: "none",
					outline: 0, // TODO: move to stylesheet
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				.attr( "tabIndex", -1)
				.keydown(function( event ) {
					if ( options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
							event.keyCode === $.ui.keyCode.ESCAPE ) {
						that.close( event );
						event.preventDefault();
					}
				})
				.mousedown(function( event ) {
					that.moveToTop( false, event );
				})
				.appendTo( "body" ),

			uiDialogContent = this.element
				.show()
				.removeAttr( "title" )
				.addClass( "ui-dialog-content ui-widget-content" )
				.appendTo( uiDialog ),

			uiDialogTitlebar = ( this.uiDialogTitlebar = $( "<div>" ) )
				.addClass( "ui-dialog-titlebar  ui-widget-header  " +
					"ui-corner-all  ui-helper-clearfix" )
				.prependTo( uiDialog ),

			uiDialogTitlebarClose = $( "<a href='#'></a>" )
				.addClass( "ui-dialog-titlebar-close  ui-corner-all" )
				.attr( "role", "button" )
				.click(function( event ) {
					event.preventDefault();
					that.close( event );
				})
				.appendTo( uiDialogTitlebar ),

			uiDialogTitlebarCloseText = ( this.uiDialogTitlebarCloseText = $( "<span>" ) )
				.addClass( "ui-icon ui-icon-closethick" )
				.text( options.closeText )
				.appendTo( uiDialogTitlebarClose ),

			uiDialogTitle = $( "<span>" )
				.uniqueId()
				.addClass( "ui-dialog-title" )
				.html( title )
				.prependTo( uiDialogTitlebar ),

			uiDialogButtonPane = ( this.uiDialogButtonPane = $( "<div>" ) )
				.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" ),

			uiButtonSet = ( this.uiButtonSet = $( "<div>" ) )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		uiDialog.attr({
			role: "dialog",
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});

		uiDialogTitlebar.find( "*" ).add( uiDialogTitlebar ).disableSelection();
		this._hoverable( uiDialogTitlebarClose );
		this._focusable( uiDialogTitlebarClose );

		if ( options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._createButtons( options.buttons );
		this._isOpen = false;

		if ( $.fn.bgiframe ) {
			uiDialog.bgiframe();
		}

		// prevent tabbing out of modal dialogs
		this._on( uiDialog, { keydown: function( event ) {
			if ( !options.modal || event.keyCode !== $.ui.keyCode.TAB ) {
				return;
			}

			var tabbables = $( ":tabbable", uiDialog ),
				first = tabbables.filter( ":first" ),
				last  = tabbables.filter( ":last" );

			if ( event.target === last[0] && !event.shiftKey ) {
				first.focus( 1 );
				return false;
			} else if ( event.target === first[0] && event.shiftKey ) {
				last.focus( 1 );
				return false;
			}
		}});
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_destroy: function() {
		var next,
			oldPosition = this.oldPosition;

		if ( this.overlay ) {
			this.overlay.destroy();
		}
		this.uiDialog.hide();
		this.element
			.removeClass( "ui-dialog-content ui-widget-content" )
			.hide()
			.appendTo( "body" );
		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = oldPosition.parent.children().eq( oldPosition.index );
		if ( next.length ) {
			next.before( this.element );
		} else {
			oldPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function( event ) {
		var that = this,
			maxZ, thisZ;

		if ( !this._isOpen ) {
			return;
		}

		if ( false === this._trigger( "beforeClose", event ) ) {
			return;
		}

		this._isOpen = false;

		if ( this.overlay ) {
			this.overlay.destroy();
		}

		if ( this.options.hide ) {
			this.uiDialog.hide( this.options.hide, function() {
				that._trigger( "close", event );
			});
		} else {
			this.uiDialog.hide();
			this._trigger( "close", event );
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if ( this.options.modal ) {
			maxZ = 0;
			$( ".ui-dialog" ).each(function() {
				if ( this !== that.uiDialog[0] ) {
					thisZ = $( this ).css( "z-index" );
					if ( !isNaN( thisZ ) ) {
						maxZ = Math.max( maxZ, thisZ );
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return this;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function( force, event ) {
		var options = this.options,
			saveScroll;

		if ( ( options.modal && !force ) ||
				( !options.stack && !options.modal ) ) {
			return this._trigger( "focus", event );
		}

		if ( options.zIndex > $.ui.dialog.maxZ ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if ( this.overlay ) {
			$.ui.dialog.maxZ += 1;
			$.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ;
			this.overlay.$el.css( "z-index", $.ui.dialog.overlay.maxZ );
		}

		// Save and then restore scroll
		// Opera 9.5+ resets when parent z-index is changed.
		// http://bugs.jqueryui.com/ticket/3193
		saveScroll = {
			scrollTop: this.element.scrollTop(),
			scrollLeft: this.element.scrollLeft()
		};
		$.ui.dialog.maxZ += 1;
		this.uiDialog.css( "z-index", $.ui.dialog.maxZ );
		this.element.attr( saveScroll );
		this._trigger( "focus", event );

		return this;
	},

	open: function() {
		if ( this._isOpen ) {
			return;
		}

		var hasFocus,
			options = this.options,
			uiDialog = this.uiDialog;

		this._size();
		this._position( options.position );
		uiDialog.show( options.show );
		this.overlay = options.modal ? new $.ui.dialog.overlay( this ) : null;
		this.moveToTop( true );

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		hasFocus = this.element.find( ":tabbable" );
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
			if ( !hasFocus.length ) {
				hasFocus = uiDialog;
			}
		}
		hasFocus.eq( 0 ).focus();

		this._isOpen = true;
		this._trigger( "open" );

		return this;
	},

	_createButtons: function( buttons ) {
		var uiDialogButtonPane, uiButtonSet,
			that = this,
			hasButtons = false;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( typeof buttons === "object" && buttons !== null ) {
			$.each( buttons, function() {
				return !(hasButtons = true);
			});
		}
		if ( hasButtons ) {
			$.each( buttons, function( name, props ) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $( "<button type='button'>" )
					.attr( props, true )
					.unbind( "click" )
					.click(function() {
						props.click.apply( that.element[0], arguments );
					})
					.appendTo( that.uiButtonSet );
				if ( $.fn.button ) {
					button.button();
				}
			});
			this.uiDialog.addClass( "ui-dialog-buttons" );
			this.uiDialogButtonPane.appendTo( this.uiDialog );
		} else {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
		}
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this )
					.addClass( "ui-dialog-dragging" );
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				options.position = [
					ui.position.left - that.document.scrollLeft(),
					ui.position.top - that.document.scrollTop()
				];
				$( this )
					.removeClass( "ui-dialog-dragging" );
				that._trigger( "dragStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function( handles ) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var that = this,
			options = this.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === 'string' ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				$( this ).removeClass( "ui-dialog-resizing" );
				options.height = $( this ).height();
				options.width = $( this ).width();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
				$.ui.dialog.overlay.resize();
			}
		})
		.css( "position", position )
		.find( ".ui-resizable-se" )
			.addClass( "ui-icon ui-icon-grip-diagonal-se" );
	},

	_minHeight: function() {
		var options = this.options;

		if ( options.height === "auto" ) {
			return options.minHeight;
		} else {
			return Math.min( options.minHeight, options.height );
		}
	},

	_position: function( position ) {
		var myAt = [],
			offset = [ 0, 0 ],
			isVisible;

		if ( position ) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if ( typeof position === "string" || (typeof position === "object" && "0" in position ) ) {
				myAt = position.split ? position.split( " " ) : [ position[ 0 ], position[ 1 ] ];
				if ( myAt.length === 1 ) {
					myAt[ 1 ] = myAt[ 0 ];
				}

				$.each( [ "left", "top" ], function( i, offsetPosition ) {
					if ( +myAt[ i ] === myAt[ i ] ) {
						offset[ i ] = myAt[ i ];
						myAt[ i ] = offsetPosition;
					}
				});

				position = {
					my: myAt.join( " " ),
					at: myAt.join( " " ),
					offset: offset.join( " " )
				};
			}

			position = $.extend( {}, $.ui.dialog.prototype.options.position, position );
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		switch ( key ) {
			case "buttons":
				this._createButtons( value );
				break;
			case "closeText":
				// ensure that we always pass a string
				this.uiDialogTitlebarCloseText.text( "" + value );
				break;
			case "dialogClass":
				uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( uiDialogClasses + value );
				break;
			case "disabled":
				if ( value ) {
					uiDialog.addClass( "ui-dialog-disabled" );
				} else {
					uiDialog.removeClass( "ui-dialog-disabled" );
				}
				break;
			case "draggable":
				isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}

				if ( !isDraggable && value ) {
					this._makeDraggable();
				}
				break;
			case "position":
				this._position( value );
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				isResizable = uiDialog.is( ":data(resizable)" );
				if ( isResizable && !value ) {
					uiDialog.resizable( "destroy" );
				}

				// currently resizable, changing handles
				if ( isResizable && typeof value === "string" ) {
					uiDialog.resizable( "option", "handles", value );
				}

				// currently non-resizable, becoming resizable
				if ( !isResizable && value !== false ) {
					this._makeResizable( value );
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$( ".ui-dialog-title", this.uiDialogTitlebar )
					.html( "" + ( value || "&#160;" ) );
				break;
		}

		this._super( key, value );
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var nonContentHeight, minContentHeight, autoHeight,
			options = this.options,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );

		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	}
});

$.extend($.ui.dialog, {
	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr( "id" );
		if ( !id ) {
			this.uuid += 1;
			id = this.uuid;
		}
		return "ui-dialog-title-" + id;
	},

	overlay: function( dialog ) {
		this.$el = $.ui.dialog.overlay.create( dialog );
	}
});

$.extend( $.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map(
		"focus,mousedown,mouseup,keydown,keypress,click".split( "," ),
		function( event ) {
			return event + ".dialog-overlay";
		}
	).join( " " ),
	create: function( dialog ) {
		if ( this.instances.length === 0 ) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ( $.ui.dialog.overlay.instances.length ) {
					$( document ).bind( $.ui.dialog.overlay.events, function( event ) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ( $( event.target ).zIndex() < $.ui.dialog.overlay.maxZ ) {
							return false;
						}
					});
				}
			}, 1 );

			// handle window resize
			$( window ).bind( "resize.dialog-overlay", $.ui.dialog.overlay.resize );
		}

		var $el = ( this.oldInstances.pop() || $( "<div>" ).addClass( "ui-widget-overlay" ) );

		// allow closing by pressing the escape key
		$( document ).bind( "keydown.dialog-overlay", function( event ) {
			var instances = $.ui.dialog.overlay.instances;
			// only react to the event if we're the top overlay
			if ( instances.length !== 0 && instances[ instances.length - 1 ] === $el &&
				dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
				event.keyCode === $.ui.keyCode.ESCAPE ) {

				dialog.close( event );
				event.preventDefault();
			}
		});

		$el.appendTo( document.body ).css({
			width: this.width(),
			height: this.height()
		});

		if ( $.fn.bgiframe ) {
			$el.bgiframe();
		}

		this.instances.push( $el );
		return $el;
	},

	destroy: function( $el ) {
		var indexOf = $.inArray( $el, this.instances ),
			maxZ = 0;

		if ( indexOf !== -1 ) {
			this.oldInstances.push( this.instances.splice( indexOf, 1 )[ 0 ] );
		}

		if ( this.instances.length === 0 ) {
			$( [ document, window ] ).unbind( ".dialog-overlay" );
		}

		$el.height( 0 ).width( 0 ).remove();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		$.each( this.instances, function() {
			maxZ = Math.max( maxZ, this.css( "z-index" ) );
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE
		if ( $.browser.msie ) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if ( scrollHeight < offsetHeight ) {
				return $( window ).height() + "px";
			} else {
				return scrollHeight + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).height() + "px";
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if ( scrollWidth < offsetWidth ) {
				return $( window ).width() + "px";
			} else {
				return scrollWidth + "px";
			}
		// handle "good" browsers
		} else {
			return $( document ).width() + "px";
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $( [] );
		$.each( $.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add( this );
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend( $.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy( this.$el );
	}
});

}( jQuery ) );

(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );

(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );
	
	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? { height: 0, width: 0 } : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		original, baseline, factor,
		position = el.css( "position" );

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	el.from = o.from || original;
	el.to = o.to || original;

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, restore ? props : props1 );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, restore ? props : props1 );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( '<div class="ui-effects-transfer"></div>' )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

(function( $, undefined ) {

var mouseHandled = false;

$.widget( "ui.menu", {
	version: "@VERSION",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			})
			// need to catch all clicks on disabled menu
			// not possible through _on
			.bind( "click" + this.eventNamespace, $.proxy(function( event ) {
				if ( this.options.disabled ) {
					event.preventDefault();
				}
			}, this ));

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-state-disabled > a": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item:has(a)": function( event ) {
				var target = $( event.target ).closest( ".ui-menu-item" );
				if ( !mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					mouseHandled = true;

					this.select( event );
					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) ) {
						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings().children( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.children( ".ui-menu-item" ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( !$( event.target ).closest( ".ui-menu" ).length ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).andSelf()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.children( "a" )
				.removeUniqueId()
				.removeClass( "ui-corner-all ui-state-hover" )
				.removeAttr( "tabIndex" )
				.removeAttr( "role" )
				.removeAttr( "aria-haspopup" )
				.children().each( function() {
					var elem = $( this );
					if ( elem.data( "ui-menu-submenu-carat" ) ) {
						elem.remove();
					}
				});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
				return regex.test( $( this ).children( "a" ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.children( ".ui-menu-item" ).filter(function() {
					return regex.test( $( this ).children( "a" ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "a[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		// Initialize nested menus
		var menus,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus + ":not(.ui-menu)" )
				.addClass( "ui-menu ui-widget ui-widget-content ui-corner-all" )
				.hide()
				.attr({
					role: this.options.role,
					"aria-hidden": "true",
					"aria-expanded": "false"
				});

		// Don't refresh list items that are already adapted
		menus = submenus.add( this.element );

		menus.children( ":not(.ui-menu-item):has(a)" )
			.addClass( "ui-menu-item" )
			.attr( "role", "presentation" )
			.children( "a" )
				.uniqueId()
				.addClass( "ui-corner-all" )
				.attr({
					tabIndex: -1,
					role: this._itemRole()
				});

		// Initialize unlinked menu-items containing spaces and/or dashes only as dividers
		menus.children( ":not(.ui-menu-item)" ).each(function() {
			var item = $( this );
			// hyphen, em dash, en dash
			if ( !/[^\-—–\s]/.test( item.text() ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Add aria-disabled attribute to any disabled menu item
		menus.children( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		submenus.each(function() {
			var menu = $( this ),
				item = menu.prev( "a" ),
				submenuCarat = $( "<span>" )
					.addClass( "ui-menu-icon ui-icon " + icon )
					.data( "ui-menu-submenu-carat", true );

			item
				.attr( "aria-haspopup", "true" )
				.prepend( submenuCarat );
			menu.attr( "aria-labelledby", item.attr( "id" ) );
		});

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.children( "a" ).addClass( "ui-state-focus" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.children( "a:first" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.height();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.children( "a" ).removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( "a.ui-state-active" )
				.removeClass( "ui-state-active" );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.children( ".ui-menu-item" )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.children( ".ui-menu-item" )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.children( ".ui-menu-item" ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});

}( jQuery ));

(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}
function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: 0, left: 0 };
	} else if ( $.isWindow( targetElem ) ) {
		targetWidth = target.width();
		targetHeight = target.height();
		targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		targetOffset = target.offset();
	}
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

// DEPRECATED
if ( $.uiBackCompat !== false ) {
	// offset option
	(function( $ ) {
		var _position = $.fn.position;
		$.fn.position = function( options ) {
			if ( !options || !options.offset ) {
				return _position.call( this, options );
			}
			var offset = options.offset.split( " " ),
				at = options.at.split( " " );
			if ( offset.length === 1 ) {
				offset[ 1 ] = offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 0 ] ) ) {
				offset[ 0 ] = "+" + offset[ 0 ];
			}
			if ( /^\d/.test( offset[ 1 ] ) ) {
				offset[ 1 ] = "+" + offset[ 1 ];
			}
			if ( at.length === 1 ) {
				if ( /left|center|right/.test( at[ 0 ] ) ) {
					at[ 1 ] = "center";
				} else {
					at[ 1 ] = at[ 0 ];
					at[ 0 ] = "center";
				}
			}
			return _position.call( this, $.extend( options, {
				at: at[ 0 ] + offset[ 0 ] + " " + at[ 1 ] + offset[ 1 ],
				offset: undefined
			} ) );
		};
	}( jQuery ) );
}

}( jQuery ) );

(function( $, undefined ) {

$.widget( "ui.progressbar", {
	version: "@VERSION",
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( "complete" );
			}
		}

		this._super( key, value );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value(),
			percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}

		this.valueDiv
			.toggle( value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

})( jQuery );

(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {
	version: "@VERSION",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var i,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" +
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.mouseenter(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			})
			.mouseleave(function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});

		this._on( this.handles, {
			keydown: function( event ) {
				var allowed, curVal, newVal, step,
					index = $( event.target ).data( "ui-slider-handle-index" );

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !this._keySliding ) {
							this._keySliding = true;
							$( event.target ).addClass( "ui-state-active" );
							allowed = this._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}

				step = this.options.step;
				if ( this.options.values && this.options.values.length ) {
					curVal = newVal = this.values( index );
				} else {
					curVal = newVal = this.value();
				}

				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = this._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = this._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = this._trimAlignValue( curVal + ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = this._trimAlignValue( curVal - ( (this._valueMax() - this._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === this._valueMax() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === this._valueMin() ) {
							return;
						}
						newVal = this._trimAlignValue( curVal - step );
						break;
				}

				this._slide( event, index, newVal );
			},
			keyup: function( event ) {
				var index = $( event.target ).data( "ui-slider-handle-index" );

				if ( this._keySliding ) {
					this._keySliding = false;
					this._stop( event, index );
					this._change( event, index );
					$( event.target ).removeClass( "ui-state-active" );
				}
			}
		});

		this._refreshValue();

		this._animateOff = false;
	},

	_destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.prop( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.prop( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

}(jQuery));

(function( $ ) {

function modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "@VERSION",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// format the value, but don't constrain
		this._value( this.element.val(), true );

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.uiSpinner.addClass( "ui-state-active" );
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._refresh();
			this.uiSpinner.removeClass( "ui-state-active" );
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );
		this._hoverable( uiSpinner );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-state-default ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i*i*i/50000 - i*i/500 + 17*i/200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			if ( value ) {
				this.element.prop( "disabled", true );
				this.buttons.button( "disable" );
			} else {
				this.element.prop( "disabled", false );
				this.buttons.button( "enable" );
			}
		}
	},

	_setOptions: modifier(function( options ) {
		this._super( options );
		this._value( this.element.val() );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		this._spin( (steps || 1) * this.options.step );
	},

	stepDown: modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		this._spin( (steps || 1) * -this.options.step );
	},

	pageUp: modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});

}( jQuery ) );

(function( $, undefined ) {

var tabId = 0,
	rhash = /#.*$/;

function getNextTabId() {
	return ++tabId;
}

function isLocal( anchor ) {
	// clone the node to work around IE 6 not normalizing the href property
	// if it's manually set, i.e., a.href = "#foo" kills the normalization
	anchor = anchor.cloneNode( false );
	return anchor.hash.length > 1 &&
		anchor.href.replace( rhash, "" ) === location.href.replace( rhash, "" );
}

$.widget( "ui.tabs", {
	version: "@VERSION",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_create: function() {
		var panel,
			that = this,
			options = this.options,
			active = options.active;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( location.hash ) {
				this.anchors.each(function( i, anchor ) {
					if ( anchor.hash === location.hash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.filter( ".ui-tabs-active" ).index();
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = options.collapsible ? false : 0;
			}
		}
		options.active = active;

		// don't allow collapsible: false and active: false
		if ( !options.collapsible && options.active === false && this.anchors.length ) {
			options.active = 0;
		}

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( this.options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_tabId: function( tab ) {
		return tab.attr( "aria-controls" ) || "ui-tabs-" + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var next,
			options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-expanded": "false",
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-expanded": "true",
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( isLocal( anchor ) ) {
				selector = anchor.hash;
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				panelId = that._tabId( tab );
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": selector.substring( 1 ),
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {
			click: function( event ) {
				event.preventDefault();
			}
		};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight, overflow,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			// IE 6 treats height like minHeight, so we need to turn off overflow
			// in order to get a reliable height
			// we use the minHeight support test because we assume that only
			// browsers that don't support minHeight will treat height as minHeight
			if ( !$.support.minHeight ) {
				overflow = parent.css( "overflow" );
				parent.css( "overflow", "hidden");
			}
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});
			if ( overflow ) {
				parent.css( "overflow", overflow );
			}

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr({
			"aria-expanded": "false",
			"aria-hidden": "true"
		});
		eventData.oldTab.attr( "aria-selected", "false" );
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr({
			"aria-expanded": "true",
			"aria-hidden": "false"
		});
		eventData.newTab.attr({
			"aria-selected": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeData( "href.tabs" )
			.removeData( "load.tabs" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li.attr( "aria-controls", prev );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	// TODO: Remove this function in 1.10 when ajaxOptions is removed
	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR : jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// helper method for a lot of the back compat extensions
	$.ui.tabs.prototype._ui = function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	};

	// url method
	$.widget( "ui.tabs", $.ui.tabs, {
		url: function( index, url ) {
			this.anchors.eq( index ).attr( "href", url );
		}
	});

	// TODO: Remove _ajaxSettings() method when removing this extension
	// ajaxOptions and cache options
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			ajaxOptions: null,
			cache: false
		},

		_create: function() {
			this._super();

			var that = this;

			this._on({ tabsbeforeload: function( event, ui ) {
				// tab is already cached
				if ( $.data( ui.tab[ 0 ], "cache.tabs" ) ) {
					event.preventDefault();
					return;
				}

				ui.jqXHR.success(function() {
					if ( that.options.cache ) {
						$.data( ui.tab[ 0 ], "cache.tabs", true );
					}
				});
			}});
		},

		_ajaxSettings: function( anchor, event, ui ) {
			var ajaxOptions = this.options.ajaxOptions;
			return $.extend( {}, ajaxOptions, {
				error: function( xhr, s, e ) {
					try {
						// Passing index avoid a race condition when this method is
						// called after the user has selected another tab.
						// Pass the anchor that initiated this request allows
						// loadError to manipulate the tab content panel via $(a.hash)
						ajaxOptions.error(
							xhr, s, ui.tab.closest( "li" ).index(), ui.tab[ 0 ] );
					}
					catch ( e ) {}
				}
			}, this._superApply( arguments ) );
		},

		_setOption: function( key, value ) {
			// reset cache if switching from cached to not cached
			if ( key === "cache" && value === false ) {
				this.anchors.removeData( "cache.tabs" );
			}
			this._super( key, value );
		},

		_destroy: function() {
			this.anchors.removeData( "cache.tabs" );
			this._super();
		},

		url: function( index, url ){
			this.anchors.eq( index ).removeData( "cache.tabs" );
			this._superApply( arguments );
		}
	});

	// abort method
	$.widget( "ui.tabs", $.ui.tabs, {
		abort: function() {
			if ( this.xhr ) {
				this.xhr.abort();
			}
		}
	});

	// spinner
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			spinner: "<em>Loading&#8230;</em>"
		},
		_create: function() {
			this._super();
			this._on({
				tabsbeforeload: function( event, ui ) {
					// Don't react to nested tabs or tabs that don't use a spinner
					if ( event.target !== this.element[ 0 ] ||
							!this.options.spinner ) {
						return;
					}

					var span = ui.tab.find( "span" ),
						html = span.html();
					span.html( this.options.spinner );
					ui.jqXHR.complete(function() {
						span.html( html );
					});
				}
			});
		}
	});

	// enable/disable events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			enable: null,
			disable: null
		},

		enable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === true ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) !== -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		},

		disable: function( index ) {
			var options = this.options,
				trigger;

			if ( index && options.disabled === false ||
					( $.isArray( options.disabled ) && $.inArray( index, options.disabled ) === -1 ) ) {
				trigger = true;
			}

			this._superApply( arguments );

			if ( trigger ) {
				this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			}
		}
	});

	// add/remove methods and events
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			add: null,
			remove: null,
			tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
		},

		add: function( url, label, index ) {
			if ( index === undefined ) {
				index = this.anchors.length;
			}

			var doInsertAfter, panel,
				options = this.options,
				li = $( options.tabTemplate
					.replace( /#\{href\}/g, url )
					.replace( /#\{label\}/g, label ) ),
				id = !url.indexOf( "#" ) ?
					url.replace( "#", "" ) :
					this._tabId( li );

			li.addClass( "ui-state-default ui-corner-top" ).data( "ui-tabs-destroy", true );
			li.attr( "aria-controls", id );

			doInsertAfter = index >= this.tabs.length;

			// try to find an existing element before creating a new one
			panel = this.element.find( "#" + id );
			if ( !panel.length ) {
				panel = this._createPanel( id );
				if ( doInsertAfter ) {
					if ( index > 0 ) {
						panel.insertAfter( this.panels.eq( -1 ) );
					} else {
						panel.appendTo( this.element );
					}
				} else {
					panel.insertBefore( this.panels[ index ] );
				}
			}
			panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" ).hide();

			if ( doInsertAfter ) {
				li.appendTo( this.tablist );
			} else {
				li.insertBefore( this.tabs[ index ] );
			}

			options.disabled = $.map( options.disabled, function( n ) {
				return n >= index ? ++n : n;
			});

			this.refresh();
			if ( this.tabs.length === 1 && options.active === false ) {
				this.option( "active", 0 );
			}

			this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
			return this;
		},

		remove: function( index ) {
			index = this._getIndex( index );
			var options = this.options,
				tab = this.tabs.eq( index ).remove(),
				panel = this._getPanelForTab( tab ).remove();

			// If selected tab was removed focus tab to the right or
			// in case the last tab was removed the tab to the left.
			// We check for more than 2 tabs, because if there are only 2,
			// then when we remove this tab, there will only be one tab left
			// so we don't need to detect which tab to activate.
			if ( tab.hasClass( "ui-tabs-active" ) && this.anchors.length > 2 ) {
				this._activate( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
			}

			options.disabled = $.map(
				$.grep( options.disabled, function( n ) {
					return n !== index;
				}),
				function( n ) {
					return n >= index ? --n : n;
				});

			this.refresh();

			this._trigger( "remove", null, this._ui( tab.find( "a" )[ 0 ], panel[ 0 ] ) );
			return this;
		}
	});

	// length method
	$.widget( "ui.tabs", $.ui.tabs, {
		length: function() {
			return this.anchors.length;
		}
	});

	// panel ids (idPrefix option + title attribute)
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			idPrefix: "ui-tabs-"
		},

		_tabId: function( tab ) {
			var a = tab.is( "li" ) ? tab.find( "a[href]" ) : tab;
			a = a[0];
			return $( a ).closest( "li" ).attr( "aria-controls" ) ||
				a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF\-]/g, "" ) ||
				this.options.idPrefix + getNextTabId();
		}
	});

	// _createPanel method
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			panelTemplate: "<div></div>"
		},

		_createPanel: function( id ) {
			return $( this.options.panelTemplate )
				.attr( "id", id )
				.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
				.data( "ui-tabs-destroy", true );
		}
	});

	// selected option
	$.widget( "ui.tabs", $.ui.tabs, {
		_create: function() {
			var options = this.options;
			if ( options.active === null && options.selected !== undefined ) {
				options.active = options.selected === -1 ? false : options.selected;
			}
			this._super();
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_setOption: function( key, value ) {
			if ( key !== "selected" ) {
				return this._super( key, value );
			}

			var options = this.options;
			this._super( "active", value === -1 ? false : value );
			options.selected = options.active;
			if ( options.selected === false ) {
				options.selected = -1;
			}
		},

		_eventHandler: function( event ) {
			this._superApply( arguments );
			this.options.selected = this.options.active;
			if ( this.options.selected === false ) {
				this.options.selected = -1;
			}
		}
	});

	// show and select event
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			show: null,
			select: null
		},
		_create: function() {
			this._super();
			if ( this.options.active !== false ) {
				this._trigger( "show", null, this._ui(
					this.active.find( ".ui-tabs-anchor" )[ 0 ],
					this._getPanelForTab( this.active )[ 0 ] ) );
			}
		},
		_trigger: function( type, event, data ) {
			var ret = this._superApply( arguments );
			if ( !ret ) {
				return false;
			}
			if ( type === "beforeActivate" && data.newTab.length ) {
				ret = this._super( "select", event, {
					tab: data.newTab.find( ".ui-tabs-anchor" )[ 0],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( "li" ).index()
				});
			} else if ( type === "activate" && data.newTab.length ) {
				ret = this._super( "show", event, {
					tab: data.newTab.find( ".ui-tabs-anchor" )[ 0 ],
					panel: data.newPanel[ 0 ],
					index: data.newTab.closest( "li" ).index()
				});
			}
			return ret;
		}
	});

	// select method
	$.widget( "ui.tabs", $.ui.tabs, {
		select: function( index ) {
			index = this._getIndex( index );
			if ( index === -1 ) {
				if ( this.options.collapsible && this.options.selected !== -1 ) {
					index = this.options.selected;
				} else {
					return;
				}
			}
			this.anchors.eq( index ).trigger( this.options.event + this.eventNamespace );
		}
	});

	// cookie option
	(function() {

	var listId = 0;

	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			cookie: null // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		},
		_create: function() {
			var options = this.options,
				active;
			if ( options.active == null && options.cookie ) {
				active = parseInt( this._cookie(), 10 );
				if ( active === -1 ) {
					active = false;
				}
				options.active = active;
			}
			this._super();
		},
		_cookie: function( active ) {
			var cookie = [ this.cookie ||
				( this.cookie = this.options.cookie.name || "ui-tabs-" + (++listId) ) ];
			if ( arguments.length ) {
				cookie.push( active === false ? -1 : active );
				cookie.push( this.options.cookie );
			}
			return $.cookie.apply( null, cookie );
		},
		_refresh: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_eventHandler: function( event ) {
			this._superApply( arguments );
			if ( this.options.cookie ) {
				this._cookie( this.options.active, this.options.cookie );
			}
		},
		_destroy: function() {
			this._super();
			if ( this.options.cookie ) {
				this._cookie( null, this.options.cookie );
			}
		}
	});

	})();

	// load event
	$.widget( "ui.tabs", $.ui.tabs, {
		_trigger: function( type, event, data ) {
			var _data = $.extend( {}, data );
			if ( type === "load" ) {
				_data.panel = _data.panel[ 0 ];
				_data.tab = _data.tab.find( ".ui-tabs-anchor" )[ 0 ];
			}
			return this._super( type, event, _data );
		}
	});

	// fx option
	// The new animation options (show, hide) conflict with the old show callback.
	// The old fx option wins over show/hide anyway (always favor back-compat).
	// If a user wants to use the new animation API, they must give up the old API.
	$.widget( "ui.tabs", $.ui.tabs, {
		options: {
			fx: null // e.g. { height: "toggle", opacity: "toggle", duration: 200 }
		},

		_getFx: function() {
			var hide, show,
				fx = this.options.fx;

			if ( fx ) {
				if ( $.isArray( fx ) ) {
					hide = fx[ 0 ];
					show = fx[ 1 ];
				} else {
					hide = show = fx;
				}
			}

			return fx ? { show: show, hide: hide } : null;
		},

		_toggle: function( event, eventData ) {
			var that = this,
				toShow = eventData.newPanel,
				toHide = eventData.oldPanel,
				fx = this._getFx();

			if ( !fx ) {
				return this._super( event, eventData );
			}

			that.running = true;

			function complete() {
				that.running = false;
				that._trigger( "activate", event, eventData );
			}

			function show() {
				eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

				if ( toShow.length && fx.show ) {
					toShow
						.animate( fx.show, fx.show.duration, function() {
							complete();
						});
				} else {
					toShow.show();
					complete();
				}
			}

			// start out by hiding, then showing, then completing
			if ( toHide.length && fx.hide ) {
				toHide.animate( fx.hide, fx.hide.duration, function() {
					eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
					show();
				});
			} else {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				toHide.hide();
				show();
			}
		}
	});
}

})( jQuery );

(function( $ ) {

var increments = 0;

function addDescribedBy( elem, id ) {
	var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
	describedby.push( id );
	elem
		.data( "ui-tooltip-id", id )
		.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
}

function removeDescribedBy( elem ) {
	var id = elem.data( "ui-tooltip-id" ),
		describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
		index = $.inArray( id, describedby );
	if ( index !== -1 ) {
		describedby.splice( index, 1 );
	}

	elem.removeData( "ui-tooltip-id" );
	describedby = $.trim( describedby.join( " " ) );
	if ( describedby ) {
		elem.attr( "aria-describedby", describedby );
	} else {
		elem.removeAttr( "aria-describedby" );
	}
}

$.widget( "ui.tooltip", {
	version: "@VERSION",
	options: {
		content: function() {
			return $( this ).attr( "title" );
		},
		hide: true,
		items: "[title]",
		position: {
			my: "left+15 center",
			at: "right center",
			collision: "flipfit flipfit"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.attr( "title", "" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).andSelf().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var target = $( event ? event.target : this.element )
				.closest( this.options.items );

		// No element to show a tooltip for
		if ( !target.length ) {
			return;
		}

		// If the tooltip is open and we're tracking then reposition the tooltip.
		// This makes sure that a tracking tooltip doesn't obscure a focused element
		// if the user was hovering when the element gained focused.
		if ( this.options.track && target.data( "ui-tooltip-id" ) ) {
			this._find( target ).position( $.extend({
				of: target
			}, this.options.position ) );
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "tooltip-open", true );

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( "tooltip-open" ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, positionOption;
		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltip = this._tooltip( target );
		addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		function position( event ) {
			positionOption.of = event;
			tooltip.position( positionOption );
		}
		if ( this.options.track && /^mouse/.test( event.originalEvent.type ) ) {
			positionOption = $.extend( {}, this.options.position );
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );

		this._trigger( "open", event, { tooltip: tooltip } );

		this._on( target, {
			mouseleave: "close",
			focusout: "close",
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			}
		});
	},

	close: function( event, force ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// don't close if the element has focus
		// this prevents the tooltip from closing if you hover while focused
		//
		// we have to check the event type because tabbing out of the document
		// may leave the element as the activeElement
		if ( !force && event && event.type !== "focusout" &&
				this.document[0].activeElement === target[0] ) {
			return;
		}

		// only set title if we had one before (see comment in _open())
		if ( target.data( "ui-tooltip-title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			$( this ).remove();
			delete that.tooltips[ this.id ];
		});

		target.removeData( "tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );
		this._off( this.document, "mousemove" );

		this.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var id = "ui-tooltip-" + increments++,
			tooltip = $( "<div>" )
				.attr({
					id: id,
					role: "tooltip"
				})
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) );
		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );
		tooltip.appendTo( this.document[0].body );
		if ( $.fn.bgiframe ) {
			tooltip.bgiframe();
		}
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? $( "#" + id ) : $();
	},

	_destroy: function() {
		$.each( this.tooltips, function( id ) {
			$( "#" + id ).remove();
		});
	}
});

}( jQuery ) );

define("ext/jquery-ui/jquery.ui", function(){});

define('lib/util/view/widgets/menu',[
  "jquery",
  "ext/jquery-ui/jquery.ui"
],
function($) {
  $.widget("custom.menu", {
    options: {
/*
      red: 255,
      green: 0,
      blue: 0,
*/
      // callbacks
//      change: null,
//      random: null
    },

    // the constructor
    _create: function() {
      this.element
        // add a class for theming
        .addClass("rg-widget")
        // prevent double click to select text
        .disableSelection()
      ;
      this.menu = $('<ul class="menu-items ui-widget-content"></ul>');
/*
      this.changer = $( "<button>", {
        text: "change",
        "class": "custom-colorize-changer"
      })
        .appendTo( this.element )
        .button();
*/
      // bind click events on the changer button to the random method
      // in 1.9 would use this._bind( this.changer, { click: "random" });
/*
      var that = this;
      this.changer.bind("click.colorize", function() {
        // _bind would handle this check
        if (that.options.disabled) {
          return;
        }
        that.random.apply(that, arguments);
      });
*/
      this.element.append(this.menu);
      this._refresh();
    },

    // called when created, and later when changing options
    _refresh: function() {
      /*
      this.element.css( "background-color", "rgb(" +
        this.options.red +"," +
        this.options.green + "," +
        this.options.blue + ")"
      );

      // trigger a callback/event
      this._trigger( "change" );
      */
    },

    addItem : function(content) {
      var li = $('<li></li>');
      li.append(content || '');
      this.menu.append(li);
      return li;
    },

    addCommand : function(content, handler) {
      var li = this.addItem(''),
          button = $('<a></a>').button();
      if(handler) button.click(handler);
      button.find(".ui-button-text").append(content);
      li.append(button);
      return button;
    },

    addDivider : function() {
      var li = this.addItem('');
      li.addClass("ui-divider");
      return li;
    },

    // a public method to change the color to a random value
    // can be called directly via .colorize( "random" )
    /*
    random: function( event ) {
      var colors = {
        red: Math.floor( Math.random() * 256 ),
        green: Math.floor( Math.random() * 256 ),
        blue: Math.floor( Math.random() * 256 )
      };

      // trigger an event, check if it's canceled
      if ( this._trigger( "random", event, colors ) !== false ) {
        this.option( colors );
      }
    },
*/
    // events bound via _bind are removed automatically
    // revert other modifications here
    _destroy: function() {
      // remove generated elements
      /*
      this.changer.remove();

      this.element
        .removeClass( "custom-colorize" )
        .enableSelection()
        .css( "background-color", "transparent" );
        */
    },

    // _setOptions is called with a hash of all options that are changing
    // always refresh when changing options
    _setOptions: function() {
      // in 1.9 would use _superApply
      $.Widget.prototype._setOptions.apply( this, arguments );
      this._refresh();
    },

    // _setOption is called for each individual option that is changing
    _setOption: function( key, value ) {
      // prevent invalid color values
      /*
      if ( /red|green|blue/.test(key) && (value < 0 || value > 255) ) {
        return;
      }
      */
      // in 1.9 would use _super
      $.Widget.prototype._setOption.call( this, key, value );
    }
  });
});
define('lib/util/ui',[
    'jquery'
  , 'lib/util/dom'
  , 'lib/util/notification'
  , 'lib/util/uid'
  , 'lib/util/view/widgets/menu'
  , 'ext/jquery-ui/jquery.ui'
],

function($, dom, notification, uid) {
  var wrapper;

  $.fn.outerHTML = function(){
    // IE, Chrome & Safari will comply with the non-standard outerHTML, all others (FF) will have a fall-back for cloning
    return (!this.length) ? this : (this[0].outerHTML || (
      function(el){
        var div = document.createElement('div');
        div.appendChild(el.cloneNode(true));
        var contents = div.innerHTML;
        div = null;
        return contents;
      })(this[0]));
  }

  return wrapper = {
    clickOrDoubleClick : function(el, clickHandler, dblClickHandler) {
      var sequence = 0;
      el.click(function(e) {
        sequence++;
        if(sequence === 1) {
          setTimeout(function() {
            if(sequence !== 1) {
              sequence = 0;
              return;
            }
            sequence = 0;
            clickHandler.call(this, e);
          }, 200);
        } else {
          sequence = 0;
          dblClickHandler.call(this, e);
        }
      });
    },
    button : function(el, o) {
      el = $(el);
      o = $.extend({
        disabled : false,
        label : "",
        text : false,
        handler : function() {},
        icons : null
      }, o);

      var options = {
        disabled : o.disabled,
        text: o.text,
        label: o.label,
        icons: o.icon ? { primary : o.icon } : o.icons
      };

      if(!options.icons) delete options.icons;

      var button = el.append('<button></button>')
        .find('button:last')
        .button(options)
        .click(function(e) {
          o.handler.apply(button.get(0));
          e.preventDefault(); return false;
        });
      if(o.className)
        button.addClass(o.className);
      if(o.description)
        wrapper.tooltip(button, o.description);
      return button;
    },
    menu : function(el, o) {
      el = $(el);
      o = $.extend({
        disabled : false
      }, o);
      var menu = el.menu({
        disabled: o.disabled
      });
      menu.find("ul").addClass("ui-menu");
      return menu;
    },
    contextmenu : function(el, o) {
      el = $(el);
      el.addClass("context-menu");
      $("body").append(el);
      var menu = this.menu(el, o),
          show = menu.show;
      menu.show = function() {
        $("body").one("click", function() {
          menu.hide();
        });
        show.apply(menu, arguments);
      };

      return menu;
    },

    tabs : function(el, o) {
      el = $(el);
      return el.tabs(o);
    },
    radios : function(el, actions) { /* group, label, handler */
      var current;
      el = $(el);
      if(actions) {
        el.find("*").remove();
        $(actions).each(function(i, action) {
          var name = action.group,
              id = "buttonset-" + uid() + "-" + i,
              label = action.label;
          action.btn = el.append('<input type="radio" id="'+id+'" name="'+name+'" '+(action.checked ? 'checked="checked" ' : '')+'/><label for="'+id+'">'+label+'</label>').find("#"+id);
          action.btn.click(function() {
            $(actions).each(function(i, a) {
                a.checked = a.token === action.token;
            });
            action.handler(action);
          });
          if(action.checked)
            current = action.btn;
          if(action.description)
            wrapper.tooltip(btn, action.description);
        });
      }
      var buttons = el.buttonset();
      if(current) {
        setTimeout(function() {
          current.click();
        }, 100);
      }
      return buttons;
    },
    checks : function(el, actions) { /* group, label, handler */
      el = $(el);
      if(actions) {
        el.find("*").remove();
        $(actions).each(function(i, action) {
          var name = action.name || "",
              checked = action.checked || false,
              id = "buttonset-" + uid() + "-" + i,
              label = action.label;
          var btn = el.append('<input type="checkbox" id="'+id+'" name="'+name+'" '+(checked ? 'checked="checked" ' : "")+'/><label for="'+id+'">'+label+'</label>').find("#"+id);
          btn.click(function(e) {
            action.checked = !!btn.attr("checked");
            if(action.handler)
              action.handler.call(btn, e, action);
          });
          if(action.description)
            wrapper.tooltip(btn, action.description);
        });
      }
      return el.buttonset();
    },
    buttonset : function(el) {
      el = $(el);
      return el.buttonset();
    },
    progressbar : function(el) {
      el = $(el);
      return el.progressbar();
    },
    tooltip : function(el, html) {
      var f = "function" === typeof html ? html : function() { return html; };
      $(el).attr("title", f.apply($(el), []));
      return el;
    },
    edit : function(el, options) {
      el = $(el);
      options = $.extend({
        handler : function(t) { return null; },
        cancel : function() { }
      }, options);
      var text = options.text || el.text().trim(),
        html = el.html(),
        edit = el.html('<input type="text" name="editable" id="editable" value="'+text+'" />').find("#editable"),
        tip;

      function exit() {
        if(tip) tip.remove();
        el.html(html);
        options.cancel();
      }

      $(document.body).one("mousedown", function() { exit(); });
      edit.change(function() {
          var newtext = edit.val();
          if(newtext === text) {
            return exit();
          }
          options.handler(newtext, function(error) {
            if(tip) tip.remove();
            if(error) {
              tip = notification.tip("invalid value", {
                target : el,
                text : error,
                type : "error"
              });
              return;
            } else {
              el.html(newtext);
            }
          });
        })
        .keyup(function(e) {
          switch(e.which) {
            case 9:
            case 13:
              edit.trigger("change");
              break;
            case 27:
              exit();
              break;
          }
        });
      edit.focus();
      var selectable = el.get(0);
      if(!dom.canSelect(selectable))  // firefox doesn't like selecting text this way
        selectable = edit.get(0);
      dom.selectText(selectable, 0, text.length);
    },
    selectmenu : function(el, o) {
      o = $.extend({
        format : function(d) { return JSON.stringify(d); },
        position : {
          menu : "right top",
          at : "right top"
        }
      }, o);

      var widget,
          trigger = $('<div class="selectmenu ui-buttonset"><button class="label ui-button ui-widget ui-state-default ui-button-text-only ui-corner-all"><span class="ui-button-text text"></span><span class="ui-icon ui-icon-triangle-1-s dropdown"></span></button></div>'),
          triggerLabel = trigger.find(".label span.text"),
          index   = ("undefined" !== typeof o.selectedIndex && o.selectedIndex) || -1;

      if(o.labelWidth) {
        triggerLabel.css("width", o.labelWidth + "px");
      }

      function selectMessage()
      {
        return o.selectMessage || "select an option";
      }

      function selectIndex(i, force) {
        if(!force && index === i) return;
        index = i;
        var content = i < 0 ? selectMessage() : o.selectedFormat ? o.selectedFormat(o.data[index]) : o.format(o.data[index]);
        triggerLabel.html(content);
      }

      function selectValue(value) {
        var i = -1;
        for(var j = 0; j < moptions.items.length; j++) {
          if(moptions.id(value, moptions.items[j])) {
            i = j;
            break;
          }
        }
        selectIndex(i, false);
      }

      el.append(trigger);

      selectIndex(index, true);

      trigger.find("button")
        .mouseover(function() { $(this).addClass("ui-state-hover"); })
        .mouseout(function() { $(this).removeClass("ui-state-hover"); })
      ;

      var moptions = {
        target : triggerLabel,
        items  : o.data.map(function(item) {
          return {
            content : o.format(item),
            data    : item
          }
        }),
        id :o.id || function(a, b) { return a === b; }
      };
      if(o.width)
        moptions.width = o.width + "px";
      var menu = notification.menu(moptions);
      menu.hide();
      $(menu).on("select", function(e, item, i) {
        selectIndex(i);
        $(widget).trigger("select", [item, i]);
      });

      trigger.click(function() {
        menu.show();
        menu.position({
          my : o.position.menu,
          at : o.position.at,
          of : trigger.find("button:first")
        });
      });

      return widget = {
          selectIndex : function(index) {
            selectIndex(index);
          }
        , getSelected : function() { return index; }
        , reset : function() {
          selectIndex(-1);
        }
        , add : function(item) {
          o.data.push(item);
          menu.menu.add(item);
          moptions.items.push(item);
        }
        , remove : function(index) {
          menu.menu.remove(index);
          moptions.items.splice(index, 1);
        }, selectValue : function(value) {
          selectValue(value);
        }
      };
    },
    snapHeight : function(el, step) {
      el = $(el);
      el.css("min-height", 0);
      el.css("min-height", (step + Math.round((el.outerHeight(false)-1)/step) * step) + "px");
    }
  };
});
/**
 * @license RequireJS text 2.0.3 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
 define: false, window: false, process: false, Packages: false,
 java: false, location: false */

define('text',['module'], function (module) {
  'use strict';

  var text, fs,
    progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
    xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
    bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
    hasLocation = typeof location !== 'undefined' && location.href,
    defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
    defaultHostName = hasLocation && location.hostname,
    defaultPort = hasLocation && (location.port || undefined),
    buildMap = [],
    masterConfig = (module.config && module.config()) || {};

  text = {
    version: '2.0.3',

    strip: function (content) {
      //Strips <?xml ...?> declarations so that external SVG and XML
      //documents can be added to a document without worry. Also, if the string
      //is an HTML document, only the part inside the body tag is returned.
      if (content) {
        content = content.replace(xmlRegExp, "");
        var matches = content.match(bodyRegExp);
        if (matches) {
          content = matches[1];
        }
      } else {
        content = "";
      }
      return content;
    },

    jsEscape: function (content) {
      return content.replace(/(['\\])/g, '\\$1')
        .replace(/[\f]/g, "\\f")
        .replace(/[\b]/g, "\\b")
        .replace(/[\n]/g, "\\n")
        .replace(/[\t]/g, "\\t")
        .replace(/[\r]/g, "\\r")
        .replace(/[\u2028]/g, "\\u2028")
        .replace(/[\u2029]/g, "\\u2029");
    },

    createXhr: masterConfig.createXhr || function () {
      //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
      var xhr, i, progId;
      if (typeof XMLHttpRequest !== "undefined") {
        return new XMLHttpRequest();
      } else if (typeof ActiveXObject !== "undefined") {
        for (i = 0; i < 3; i += 1) {
          progId = progIds[i];
          try {
            xhr = new ActiveXObject(progId);
          } catch (e) {}

          if (xhr) {
            progIds = [progId];  // so faster next time
            break;
          }
        }
      }

      return xhr;
    },

    /**
     * Parses a resource name into its component parts. Resource names
     * look like: module/name.ext!strip, where the !strip part is
     * optional.
     * @param {String} name the resource name
     * @returns {Object} with properties "moduleName", "ext" and "strip"
     * where strip is a boolean.
     */
    parseName: function (name) {
      var strip = false, index = name.indexOf("."),
        modName = name.substring(0, index),
        ext = name.substring(index + 1, name.length);

      index = ext.indexOf("!");
      if (index !== -1) {
        //Pull off the strip arg.
        strip = ext.substring(index + 1, ext.length);
        strip = strip === "strip";
        ext = ext.substring(0, index);
      }

      return {
        moduleName: modName,
        ext: ext,
        strip: strip
      };
    },

    xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

    /**
     * Is an URL on another domain. Only works for browser use, returns
     * false in non-browser environments. Only used to know if an
     * optimized .js version of a text resource should be loaded
     * instead.
     * @param {String} url
     * @returns Boolean
     */
    useXhr: function (url, protocol, hostname, port) {
      var uProtocol, uHostName, uPort,
        match = text.xdRegExp.exec(url);
      if (!match) {
        return true;
      }
      uProtocol = match[2];
      uHostName = match[3];

      uHostName = uHostName.split(':');
      uPort = uHostName[1];
      uHostName = uHostName[0];

      return (!uProtocol || uProtocol === protocol) &&
        (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
        ((!uPort && !uHostName) || uPort === port);
    },

    finishLoad: function (name, strip, content, onLoad) {
      content = strip ? text.strip(content) : content;
      if (masterConfig.isBuild) {
        buildMap[name] = content;
      }
      onLoad(content);
    },

    load: function (name, req, onLoad, config) {
      //Name has format: some.module.filext!strip
      //The strip part is optional.
      //if strip is present, then that means only get the string contents
      //inside a body tag in an HTML string. For XML/SVG content it means
      //removing the <?xml ...?> declarations so the content can be inserted
      //into the current doc without problems.

      // Do not bother with the work if a build and text will
      // not be inlined.
      if (config.isBuild && !config.inlineText) {
        onLoad();
        return;
      }

      masterConfig.isBuild = config.isBuild;

      var parsed = text.parseName(name),
        nonStripName = parsed.moduleName + '.' + parsed.ext,
        url = req.toUrl(nonStripName),
        useXhr = (masterConfig.useXhr) ||
          text.useXhr;

      //Load the text. Use XHR if possible and in a browser.
      if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
        text.get(url, function (content) {
          text.finishLoad(name, parsed.strip, content, onLoad);
        }, function (err) {
          if (onLoad.error) {
            onLoad.error(err);
          }
        });
      } else {
        //Need to fetch the resource across domains. Assume
        //the resource has been optimized into a JS module. Fetch
        //by the module name + extension, but do not include the
        //!strip part to avoid file system issues.
        req([nonStripName], function (content) {
          text.finishLoad(parsed.moduleName + '.' + parsed.ext,
            parsed.strip, content, onLoad);
        });
      }
    },

    write: function (pluginName, moduleName, write, config) {
      if (buildMap.hasOwnProperty(moduleName)) {
        var content = text.jsEscape(buildMap[moduleName]);
        write.asModule(pluginName + "!" + moduleName,
          "define(function () { return '" +
            content +
            "';});\n");
      }
    },

    writeFile: function (pluginName, moduleName, req, write, config) {
      var parsed = text.parseName(moduleName),
        nonStripName = parsed.moduleName + '.' + parsed.ext,
      //Use a '.js' file name so that it indicates it is a
      //script that can be loaded across domains.
        fileName = req.toUrl(parsed.moduleName + '.' +
          parsed.ext) + '.js';

      //Leverage own load() method to load plugin value, but only
      //write out values that do not have the strip argument,
      //to avoid any potential issues with ! in file names.
      text.load(nonStripName, req, function (value) {
        //Use own write() method to construct full module value.
        //But need to create shell that translates writeFile's
        //write() to the right interface.
        var textWrite = function (contents) {
          return write(fileName, contents);
        };
        textWrite.asModule = function (moduleName, contents) {
          return write.asModule(moduleName, fileName, contents);
        };

        text.write(pluginName, nonStripName, textWrite, config);
      }, config);
    }
  };

  if (masterConfig.env === 'node' || (!masterConfig.env &&
    typeof process !== "undefined" &&
    process.versions &&
    !!process.versions.node)) {
    //Using special require.nodeRequire, something added by r.js.
    fs = require.nodeRequire('fs');

    text.get = function (url, callback) {
      var file = fs.readFileSync(url, 'utf8');
      //Remove BOM (Byte Mark Order) from utf8 files if it is there.
      if (file.indexOf('\uFEFF') === 0) {
        file = file.substring(1);
      }
      callback(file);
    };
  } else if (masterConfig.env === 'xhr' || (!masterConfig.env &&
    text.createXhr())) {
    text.get = function (url, callback, errback) {
      var xhr = text.createXhr();
      xhr.open('GET', url, true);

      //Allow overrides specified in config
      if (masterConfig.onXhr) {
        masterConfig.onXhr(xhr, url);
      }

      xhr.onreadystatechange = function (evt) {
        var status, err;
        //Do not explicitly handle errors, those should be
        //visible via console output in the browser.
        if (xhr.readyState === 4) {
          status = xhr.status;
          if (status > 399 && status < 600) {
            //An http 4xx or 5xx error. Signal an error.
            err = new Error(url + ' HTTP status: ' + status);
            err.xhr = xhr;
            errback(err);
          } else {
            callback(xhr.responseText);
          }
        }
      };
      xhr.send(null);
    };
  } else if (masterConfig.env === 'rhino' || (!masterConfig.env &&
    typeof Packages !== 'undefined' && typeof java !== 'undefined')) {
    //Why Java, why is this so awkward?
    text.get = function (url, callback) {
      var stringBuffer, line,
        encoding = "utf-8",
        file = new java.io.File(url),
        lineSeparator = java.lang.System.getProperty("line.separator"),
        input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
        content = '';
      try {
        stringBuffer = new java.lang.StringBuffer();
        line = input.readLine();

        // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
        // http://www.unicode.org/faq/utf_bom.html

        // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
        // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
        if (line && line.length() && line.charAt(0) === 0xfeff) {
          // Eat the BOM, since we've already found the encoding on this file,
          // and we plan to concatenating this buffer with others; the BOM should
          // only appear at the top of a file.
          line = line.substring(1);
        }

        stringBuffer.append(line);

        while ((line = input.readLine()) !== null) {
          stringBuffer.append(lineSeparator);
          stringBuffer.append(line);
        }
        //Make sure we return a JavaScript string and not a Java string.
        content = String(stringBuffer.toString()); //String
      } finally {
        input.close();
      }
      callback(content);
    };
  }

  return text;
});
define('text!templates/layout.datasource.html',[],function () { return '<div>\n    <div class="main-container" style="width: 100%; height: 100%">\n        <div class="datasources ui-layout-west pane">\n            <div class="toolbar toolbar-tall ui-layout-north pane ui-widget-header">\n                <div class="toolbar-description">data sources</div>\n                <div class="toolbar-main"></div>\n                <div class="toolbar-context"></div>\n            </div>\n            <div class="tree ui-layout-center pane"></div>\n        </div>\n        <div class="main-splitter ui-layout-center pane">\n            <div class="datasource ui-layout-north pane">\n\n            </div>\n            <div class="dataviewer ui-layout-center pane">\n\n            </div>\n        </div>\n    </div>\n</div>';});

/**
 * @preserve jquery.layout 1.3.0 - Release Candidate 30.61
 * $Date: 2012-08-04 08:00:00 (Sat, 04 Aug 2012) $
 * $Rev: 303006 $
 *
 * Copyright (c) 2012
 *   Fabrizio Balliano (http://www.fabrizioballiano.net)
 *   Kevin Dalman (http://allpro.net)
 *
 * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
 * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
 *
 * Changelog: http://layout.jquery-dev.net/changelog.cfm#1.3.0.rc30.61
 * NOTE: This is a short-term release to patch a couple of bugs.
 * These bugs are listed as officially fixed in RC30.7, which will be released shortly.
 *
 * Docs: http://layout.jquery-dev.net/documentation.html
 * Tips: http://layout.jquery-dev.net/tips.html
 * Help: http://groups.google.com/group/jquery-ui-layout
 */

/* JavaDoc Info: http://code.google.com/closure/compiler/docs/js-for-compiler.html
 * {!Object}	non-nullable type (never NULL)
 * {?string}	nullable type (sometimes NULL) - default for {Object}
 * {number=}	optional parameter
 * {*}			ALL types
 */

// NOTE: For best readability, view with a fixed-width font and tabs equal to 4-chars

;(function ($) {

// alias Math methods - used a lot!
    var	min		= Math.min
        ,	max		= Math.max
        ,	round	= Math.floor

        ,	isStr	=  function (v) { return $.type(v) === "string"; }

        ,	runPluginCallbacks = function (Instance, a_fn) {
            if ($.isArray(a_fn))
                for (var i=0, c=a_fn.length; i<c; i++) {
                    var fn = a_fn[i];
                    try {
                        if (isStr(fn)) // 'name' of a function
                            fn = eval(fn);
                        if ($.isFunction(fn))
                            fn( Instance );
                    } catch (ex) {}
                }
        }

        ;


    /*
     *	GENERIC $.layout METHODS - used by all layouts
     */
    $.layout = {

        version:	"1.3.rc30.6"
        ,	revision:	0.033006 // 1.3.0 final = 1.0300 - major(n+).minor(nn)+patch(nn+)

        // can update code here if $.browser is phased out
        ,	browser: {
            mozilla:	!!$.browser.mozilla
            ,	webkit:		!!$.browser.webkit || !!$.browser.safari // webkit = jQ 1.4
            ,	msie:		!!$.browser.msie
            ,	isIE6:		$.browser.msie && $.browser.version == 6
            ,	boxModel:	$.support.boxModel !== false || !$.browser.msie // ONLY IE reverts to old box-model - update for older jQ onReady
            ,	version:	$.browser.version // not used in Layout core, but may be used by plugins
        }

        // *PREDEFINED* EFFECTS & DEFAULTS 
        // MUST list effect here - OR MUST set an fxSettings option (can be an empty hash: {})
        ,	effects: {

            //	Pane Open/Close Animations
            slide: {
                all:	{ duration:  "fast"	} // eg: duration: 1000, easing: "easeOutBounce"
                ,	north:	{ direction: "up"	}
                ,	south:	{ direction: "down"	}
                ,	east:	{ direction: "right"}
                ,	west:	{ direction: "left"	}
            }
            ,	drop: {
                all:	{ duration:  "slow"	}
                ,	north:	{ direction: "up"	}
                ,	south:	{ direction: "down"	}
                ,	east:	{ direction: "right"}
                ,	west:	{ direction: "left"	}
            }
            ,	scale: {
                all:	{ duration:	"fast"	}
            }
            //	these are not recommended, but can be used
            ,	blind:		{}
            ,	clip:		{}
            ,	explode:	{}
            ,	fade:		{}
            ,	fold:		{}
            ,	puff:		{}

            //	Pane Resize Animations
            ,	size: {
                all:	{ easing:	"swing"	}
            }
        }

        // INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
        ,	config: {
            optionRootKeys:	"effects,panes,north,south,west,east,center".split(",")
            ,	allPanes:		"north,south,west,east,center".split(",")
            ,	borderPanes:	"north,south,west,east".split(",")
            ,	oppositeEdge: {
                north:	"south"
                ,	south:	"north"
                ,	east: 	"west"
                ,	west: 	"east"
            }
            //	offscreen data
            ,	offscreenCSS:	{ left: "-99999px", right: "auto" } // used by hide/close if useOffscreenClose=true
            ,	offscreenReset:	"offscreenReset" // key used for data
            //	CSS used in multiple places
            ,	hidden:		{ visibility: "hidden" }
            ,	visible:	{ visibility: "visible" }
            //	layout element settings
            ,	resizers: {
                cssReq: {
                    position: 	"absolute"
                    ,	padding: 	0
                    ,	margin: 	0
                    ,	fontSize:	"1px"
                    ,	textAlign:	"left"	// to counter-act "center" alignment!
                    ,	overflow: 	"hidden" // prevent toggler-button from overflowing
                    //	SEE $.layout.defaults.zIndexes.resizer_normal
                }
                ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                    background: "#DDD"
                    ,	border:		"none"
                }
            }
            ,	togglers: {
                cssReq: {
                    position: 	"absolute"
                    ,	display: 	"block"
                    ,	padding: 	0
                    ,	margin: 	0
                    ,	overflow:	"hidden"
                    ,	textAlign:	"center"
                    ,	fontSize:	"1px"
                    ,	cursor: 	"pointer"
                    ,	zIndex: 	1
                }
                ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                    background: "#AAA"
                }
            }
            ,	content: {
                cssReq: {
                    position:	"relative" /* contain floated or positioned elements */
                }
                ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                    overflow:	"auto"
                    ,	padding:	"10px"
                }
                ,	cssDemoPane: { // DEMO CSS - REMOVE scrolling from 'pane' when it has a content-div
                    overflow:	"hidden"
                    ,	padding:	0
                }
            }
            ,	panes: { // defaults for ALL panes - overridden by 'per-pane settings' below
                cssReq: {
                    position: 	"absolute"
                    ,	margin:		0
                    //	$.layout.defaults.zIndexes.pane_normal
                }
                ,	cssDemo: { // DEMO CSS - applied if: options.PANE.applyDemoStyles=true
                    padding:	"10px"
                    ,	background:	"#FFF"
                    ,	border:		"1px solid #BBB"
                    ,	overflow:	"auto"
                }
            }
            ,	north: {
                side:			"Top"
                ,	sizeType:		"Height"
                ,	dir:			"horz"
                ,	cssReq: {
                    top: 		0
                    ,	bottom: 	"auto"
                    ,	left: 		0
                    ,	right: 		0
                    ,	width: 		"auto"
                    //	height: 	DYNAMIC
                }
            }
            ,	south: {
                side:			"Bottom"
                ,	sizeType:		"Height"
                ,	dir:			"horz"
                ,	cssReq: {
                    top: 		"auto"
                    ,	bottom: 	0
                    ,	left: 		0
                    ,	right: 		0
                    ,	width: 		"auto"
                    //	height: 	DYNAMIC
                }
            }
            ,	east: {
                side:			"Right"
                ,	sizeType:		"Width"
                ,	dir:			"vert"
                ,	cssReq: {
                    left: 		"auto"
                    ,	right: 		0
                    ,	top: 		"auto" // DYNAMIC
                    ,	bottom: 	"auto" // DYNAMIC
                    ,	height: 	"auto"
                    //	width: 		DYNAMIC
                }
            }
            ,	west: {
                side:			"Left"
                ,	sizeType:		"Width"
                ,	dir:			"vert"
                ,	cssReq: {
                    left: 		0
                    ,	right: 		"auto"
                    ,	top: 		"auto" // DYNAMIC
                    ,	bottom: 	"auto" // DYNAMIC
                    ,	height: 	"auto"
                    //	width: 		DYNAMIC
                }
            }
            ,	center: {
                dir:			"center"
                ,	cssReq: {
                    left: 		"auto" // DYNAMIC
                    ,	right: 		"auto" // DYNAMIC
                    ,	top: 		"auto" // DYNAMIC
                    ,	bottom: 	"auto" // DYNAMIC
                    ,	height: 	"auto"
                    ,	width: 		"auto"
                }
            }
        }

        // CALLBACK FUNCTION NAMESPACE - used to store reusable callback functions
        ,	callbacks: {}

        ,	getParentPaneElem: function (el) {
            // must pass either a container or pane element
            var $el = $(el)
                ,	layout = $el.data("layout") || $el.data("parentLayout");
            if (layout) {
                var $cont = layout.container;
                // see if this container is directly-nested inside an outer-pane
                if ($cont.data("layoutPane")) return $cont;
                var $pane = $cont.closest("."+ $.layout.defaults.panes.paneClass);
                // if a pane was found, return it
                if ($pane.data("layoutPane")) return $pane;
            }
            return null;
        }

        ,	getParentPaneInstance: function (el) {
            // must pass either a container or pane element
            var $pane = $.layout.getParentPaneElem(el);
            return $pane ? $pane.data("layoutPane") : null;
        }

        ,	getParentLayoutInstance: function (el) {
            // must pass either a container or pane element
            var $pane = $.layout.getParentPaneElem(el);
            return $pane ? $pane.data("parentLayout") : null;
        }

        ,	getEventObject: function (evt) {
            return typeof evt === "object" && evt.stopPropagation ? evt : null;
        }
        ,	parsePaneName: function (evt_or_pane) {
            // getEventObject() automatically calls .stopPropagation(), WHICH MUST BE DONE!
            var evt = $.layout.getEventObject( evt_or_pane );
            if (evt) {
                // ALWAYS stop propagation of events triggered in Layout!
                evt.stopPropagation();
                return $(this).data("layoutEdge");
            }
            else
                return evt_or_pane;
        }


        // LAYOUT-PLUGIN REGISTRATION
        // more plugins can added beyond this default list
        ,	plugins: {
            draggable:		!!$.fn.draggable // resizing
            ,	effects: {
                core:		!!$.effects		// animimations (specific effects tested by initOptions)
                ,	slide:		$.effects && $.effects.slide // default effect
            }
        }

//	arrays of plugin or other methods to be triggered for events in *each layout* - will be passed 'Instance'
        ,	onCreate:	[]	// runs when layout is just starting to be created - right after options are set
        ,	onLoad:		[]	// runs after layout container and global events init, but before initPanes is called
        ,	onReady:	[]	// runs after initialization *completes* - ie, after initPanes completes successfully
        ,	onDestroy:	[]	// runs after layout is destroyed
        ,	onUnload:	[]	// runs after layout is destroyed OR when page unloads
        ,	afterOpen:	[]	// runs after setAsOpen() completes
        ,	afterClose:	[]	// runs after setAsClosed() completes

        /*
         *	GENERIC UTILITY METHODS
         */

        // calculate and return the scrollbar width, as an integer
        ,	scrollbarWidth:		function () { return window.scrollbarWidth  || $.layout.getScrollbarSize('width'); }
        ,	scrollbarHeight:	function () { return window.scrollbarHeight || $.layout.getScrollbarSize('height'); }
        ,	getScrollbarSize:	function (dim) {
            var $c	= $('<div style="position: absolute; top: -10000px; left: -10000px; width: 100px; height: 100px; overflow: scroll;"></div>').appendTo("body");
            var d	= { width: $c.width() - $c[0].clientWidth, height: $c.height() - $c[0].clientHeight };
            $c.remove();
            window.scrollbarWidth	= d.width;
            window.scrollbarHeight	= d.height;
            return dim.match(/^(width|height)$/) ? d[dim] : d;
        }


        /**
         * Returns hash container 'display' and 'visibility'
         *
         * @see	$.swap() - swaps CSS, runs callback, resets CSS
         */
        ,	showInvisibly: function ($E, force) {
            if (!$E) return {};
            if (!$E.jquery) $E = $($E);
            var CSS = {
                display:	$E.css('display')
                ,	visibility:	$E.css('visibility')
            };
            if (force || CSS.display === "none") { // only if not *already hidden*
                $E.css({ display: "block", visibility: "hidden" }); // show element 'invisibly' so can be measured
                return CSS;
            }
            else return {};
        }

        /**
         * Returns data for setting size of an element (container or a pane).
         *
         * @see  _create(), onWindowResize() for container, plus others for pane
         * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, outerWidth, innerHeight, etc
         */
        ,	getElementDimensions: function ($E) {
            var
                d	= {}			// dimensions hash
                ,	x	= d.css = {}	// CSS hash
                ,	i	= {}			// TEMP insets
                ,	b, p				// TEMP border, padding
                ,	N	= $.layout.cssNum
                ,	off = $E.offset()
                ;
            d.offsetLeft = off.left;
            d.offsetTop  = off.top;

            $.each("Left,Right,Top,Bottom".split(","), function (idx, e) { // e = edge
                b = x["border" + e] = $.layout.borderWidth($E, e);
                p = x["padding"+ e] = $.layout.cssNum($E, "padding"+e);
                i[e] = b + p; // total offset of content from outer side
                d["inset"+ e] = p;	// eg: insetLeft = paddingLeft
            });

            d.offsetWidth	= $E.innerWidth();	// offsetWidth is used in calc when doing manual resize
            d.offsetHeight	= $E.innerHeight();	// ditto
            d.outerWidth	= $E.outerWidth();
            d.outerHeight	= $E.outerHeight();
            d.innerWidth	= max(0, d.outerWidth  - i.Left - i.Right);
            d.innerHeight	= max(0, d.outerHeight - i.Top  - i.Bottom);

            x.width		= $E.width();
            x.height	= $E.height();
            x.top		= N($E,"top",true);
            x.bottom	= N($E,"bottom",true);
            x.left		= N($E,"left",true);
            x.right		= N($E,"right",true);

            //d.visible	= $E.is(":visible");// && x.width > 0 && x.height > 0;

            return d;
        }

        ,	getElementCSS: function ($E, list) {
            var
                CSS	= {}
                ,	style	= $E[0].style
                ,	props	= list.split(",")
                ,	sides	= "Top,Bottom,Left,Right".split(",")
                ,	attrs	= "Color,Style,Width".split(",")
                ,	p, s, a, i, j, k
                ;
            for (i=0; i < props.length; i++) {
                p = props[i];
                if (p.match(/(border|padding|margin)$/))
                    for (j=0; j < 4; j++) {
                        s = sides[j];
                        if (p === "border")
                            for (k=0; k < 3; k++) {
                                a = attrs[k];
                                CSS[p+s+a] = style[p+s+a];
                            }
                        else
                            CSS[p+s] = style[p+s];
                    }
                else
                    CSS[p] = style[p];
            };
            return CSS
        }

        /**
         * Return the innerWidth for the current browser/doctype
         *
         * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
         * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
         * @param  {number=}			outerWidth (optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}			Returns the innerWidth of the elem by subtracting padding and borders
         */
        ,	cssWidth: function ($E, outerWidth) {
            // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
            if (outerWidth <= 0) return 0;

            if (!$.layout.browser.boxModel) return outerWidth;

            // strip border and padding from outerWidth to get CSS Width
            var b = $.layout.borderWidth
                ,	n = $.layout.cssNum
                ,	W = outerWidth
                    - b($E, "Left")
                    - b($E, "Right")
                    - n($E, "paddingLeft")
                    - n($E, "paddingRight");

            return max(0,W);
        }

        /**
         * Return the innerHeight for the current browser/doctype
         *
         * @see  initPanes(), sizeMidPanes(), initHandles(), sizeHandles()
         * @param  {Array.<Object>}	$E  Must pass a jQuery object - first element is processed
         * @param  {number=}			outerHeight  (optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}			Returns the innerHeight of the elem by subtracting padding and borders
         */
        ,	cssHeight: function ($E, outerHeight) {
            // a 'calculated' outerHeight can be passed so borders and/or padding are removed if needed
            if (outerHeight <= 0) return 0;

            if (!$.layout.browser.boxModel) return outerHeight;

            // strip border and padding from outerHeight to get CSS Height
            var b = $.layout.borderWidth
                ,	n = $.layout.cssNum
                ,	H = outerHeight
                    - b($E, "Top")
                    - b($E, "Bottom")
                    - n($E, "paddingTop")
                    - n($E, "paddingBottom");

            return max(0,H);
        }

        /**
         * Returns the 'current CSS numeric value' for a CSS property - 0 if property does not exist
         *
         * @see  Called by many methods
         * @param {Array.<Object>}	$E					Must pass a jQuery object - first element is processed
         * @param {string}			prop				The name of the CSS property, eg: top, width, etc.
         * @param {boolean=}			[allowAuto=false]	true = return 'auto' if that is value; false = return 0
         * @return {(string|number)}						Usually used to get an integer value for position (top, left) or size (height, width)
         */
        ,	cssNum: function ($E, prop, allowAuto) {
            if (!$E.jquery) $E = $($E);
            var CSS = $.layout.showInvisibly($E)
                ,	p	= $.css($E[0], prop, true)
                ,	v	= allowAuto && p=="auto" ? p : (parseInt(p, 10) || 0);
            $E.css( CSS ); // RESET
            return v;
        }

        ,	borderWidth: function (el, side) {
            if (el.jquery) el = el[0];
            var b = "border"+ side.substr(0,1).toUpperCase() + side.substr(1); // left => Left
            return $.css(el, b+"Style", true) === "none" ? 0 : (parseInt($.css(el, b+"Width", true), 10) || 0);
        }

        /**
         * Mouse-tracking utility - FUTURE REFERENCE
         *
         * init: if (!window.mouse) {
         *			window.mouse = { x: 0, y: 0 };
         *			$(document).mousemove( $.layout.trackMouse );
         *		}
         *
         * @param {Object}		evt
         *
         ,	trackMouse: function (evt) {
         window.mouse = { x: evt.clientX, y: evt.clientY };
         }
         */

        /**
         * SUBROUTINE for preventPrematureSlideClose option
         *
         * @param {Object}		evt
         * @param {Object=}		el
         */
        ,	isMouseOverElem: function (evt, el) {
            var
                $E	= $(el || this)
                ,	d	= $E.offset()
                ,	T	= d.top
                ,	L	= d.left
                ,	R	= L + $E.outerWidth()
                ,	B	= T + $E.outerHeight()
                ,	x	= evt.pageX	// evt.clientX ?
                ,	y	= evt.pageY	// evt.clientY ?
                ;
            // if X & Y are < 0, probably means is over an open SELECT
            return ($.layout.browser.msie && x < 0 && y < 0) || ((x >= L && x <= R) && (y >= T && y <= B));
        }

        /**
         * Message/Logging Utility
         *
         * @example $.layout.msg("My message");				// log text
         * @example $.layout.msg("My message", true);		// alert text
         * @example $.layout.msg({ foo: "bar" }, "Title");	// log hash-data, with custom title
         * @example $.layout.msg({ foo: "bar" }, true, "Title", { sort: false }); -OR-
         * @example $.layout.msg({ foo: "bar" }, "Title", { sort: false, display: true }); // alert hash-data
         *
         * @param {(Object|string)}			info			String message OR Hash/Array
         * @param {(Boolean|string|Object)=}	[popup=false]	True means alert-box - can be skipped
         * @param {(Object|string)=}			[debugTitle=""]	Title for Hash data - can be skipped
         * @param {Object=}					[debugOpts]		Extra options for debug output
         */
        ,	msg: function (info, popup, debugTitle, debugOpts) {
            if ($.isPlainObject(info) && window.debugData) {
                if (typeof popup === "string") {
                    debugOpts	= debugTitle;
                    debugTitle	= popup;
                }
                else if (typeof debugTitle === "object") {
                    debugOpts	= debugTitle;
                    debugTitle	= null;
                }
                var t = debugTitle || "log( <object> )"
                    ,	o = $.extend({ sort: false, returnHTML: false, display: false }, debugOpts);
                if (popup === true || o.display)
                    debugData( info, t, o );
                else if (window.console)
                    console.log(debugData( info, t, o ));
            }
            else if (popup)
                alert(info);
            else if (window.console)
                console.log(info);
            else {
                var id	= "#layoutLogger"
                    ,	$l = $(id);
                if (!$l.length)
                    $l = createLog();
                $l.children("ul").append('<li style="padding: 4px 10px; margin: 0; border-top: 1px solid #CCC;">'+ info.replace(/\</g,"&lt;").replace(/\>/g,"&gt;") +'</li>');
            }

            function createLog () {
                var pos = $.support.fixedPosition ? 'fixed' : 'absolute'
                    ,	$e = $('<div id="layoutLogger" style="position: '+ pos +'; top: 5px; z-index: 999999; max-width: 25%; overflow: hidden; border: 1px solid #000; border-radius: 5px; background: #FBFBFB; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">'
                        +	'<div style="font-size: 13px; font-weight: bold; padding: 5px 10px; background: #F6F6F6; border-radius: 5px 5px 0 0; cursor: move;">'
                        +	'<span style="float: right; padding-left: 7px; cursor: pointer;" title="Remove Console" onclick="$(this).closest(\'#layoutLogger\').remove()">X</span>Layout console.log</div>'
                        +	'<ul style="font-size: 13px; font-weight: none; list-style: none; margin: 0; padding: 0 0 2px;"></ul>'
                        + '</div>'
                    ).appendTo("body");
                $e.css('left', $(window).width() - $e.outerWidth() - 5)
                if ($.ui.draggable) $e.draggable({ handle: ':first-child' });
                return $e;
            };
        }

    };

// DEFAULT OPTIONS
    $.layout.defaults = {
        /*
         *	LAYOUT & LAYOUT-CONTAINER OPTIONS
         *	- none of these options are applicable to individual panes
         */
        name:						""			// Not required, but useful for buttons and used for the state-cookie
        ,	containerSelector:			""			// ONLY used when specifying a childOptions - to find container-element that is NOT directly-nested
        ,	containerClass:				"ui-layout-container" // layout-container element
        ,	scrollToBookmarkOnLoad:		true		// after creating a layout, scroll to bookmark in URL (.../page.htm#myBookmark)
        ,	resizeWithWindow:			true		// bind thisLayout.resizeAll() to the window.resize event
        ,	resizeWithWindowDelay:		200			// delay calling resizeAll because makes window resizing very jerky
        ,	resizeWithWindowMaxDelay:	0			// 0 = none - force resize every XX ms while window is being resized
        ,	onresizeall_start:			null		// CALLBACK when resizeAll() STARTS	- NOT pane-specific
        ,	onresizeall_end:			null		// CALLBACK when resizeAll() ENDS	- NOT pane-specific
        ,	onload_start:				null		// CALLBACK when Layout inits - after options initialized, but before elements
        ,	onload_end:					null		// CALLBACK when Layout inits - after EVERYTHING has been initialized
        ,	onunload_start:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
        ,	onunload_end:				null		// CALLBACK when Layout is destroyed OR onWindowUnload
        ,	initPanes:					true		// false = DO NOT initialize the panes onLoad - will init later
        ,	showErrorMessages:			true		// enables fatal error messages to warn developers of common errors
        ,	showDebugMessages:			false		// display console-and-alert debug msgs - IF this Layout version _has_ debugging code!
//	Changing this zIndex value will cause other zIndex values to automatically change
        ,	zIndex:						null		// the PANE zIndex - resizers and masks will be +1
//	DO NOT CHANGE the zIndex values below unless you clearly understand their relationships
        ,	zIndexes: {								// set _default_ z-index values here...
            pane_normal:			0			// normal z-index for panes
            ,	content_mask:			1			// applied to overlays used to mask content INSIDE panes during resizing
            ,	resizer_normal:			2			// normal z-index for resizer-bars
            ,	pane_sliding:			100			// applied to *BOTH* the pane and its resizer when a pane is 'slid open'
            ,	pane_animate:			1000		// applied to the pane when being animated - not applied to the resizer
            ,	resizer_drag:			10000		// applied to the CLONED resizer-bar when being 'dragged'
        }
        ,	errors: {
            pane:					"pane"		// description of "layout pane element" - used only in error messages
            ,	selector:				"selector"	// description of "jQuery-selector" - used only in error messages
            ,	addButtonError:			"Error Adding Button \n\nInvalid "
            ,	containerMissing:		"UI Layout Initialization Error\n\nThe specified layout-container does not exist."
            ,	centerPaneMissing:		"UI Layout Initialization Error\n\nThe center-pane element does not exist.\n\nThe center-pane is a required element."
            ,	noContainerHeight:		"UI Layout Initialization Warning\n\nThe layout-container \"CONTAINER\" has no height.\n\nTherefore the layout is 0-height and hence 'invisible'!"
            ,	callbackError:			"UI Layout Callback Error\n\nThe EVENT callback is not a valid function."
        }
        /*
         *	PANE DEFAULT SETTINGS
         *	- settings under the 'panes' key become the default settings for *all panes*
         *	- ALL pane-options can also be set specifically for each panes, which will override these 'default values'
         */
        ,	panes: { // default options for 'all panes' - will be overridden by 'per-pane settings'
            applyDemoStyles: 		false		// NOTE: renamed from applyDefaultStyles for clarity
            ,	closable:				true		// pane can open & close
            ,	resizable:				true		// when open, pane can be resized 
            ,	slidable:				true		// when closed, pane can 'slide open' over other panes - closes on mouse-out
            ,	initClosed:				false		// true = init pane as 'closed'
            ,	initHidden: 			false 		// true = init pane as 'hidden' - no resizer-bar/spacing
            //	SELECTORS
            //,	paneSelector:			""			// MUST be pane-specific - jQuery selector for pane
            ,	contentSelector:		".ui-layout-content" // INNER div/element to auto-size so only it scrolls, not the entire pane!
            ,	contentIgnoreSelector:	".ui-layout-ignore"	// element(s) to 'ignore' when measuring 'content'
            ,	findNestedContent:		false		// true = $P.find(contentSelector), false = $P.children(contentSelector)
            //	GENERIC ROOT-CLASSES - for auto-generated classNames
            ,	paneClass:				"ui-layout-pane"	// Layout Pane
            ,	resizerClass:			"ui-layout-resizer"	// Resizer Bar
            ,	togglerClass:			"ui-layout-toggler"	// Toggler Button
            ,	buttonClass:			"ui-layout-button"	// CUSTOM Buttons	- eg: '[ui-layout-button]-toggle/-open/-close/-pin'
            //	ELEMENT SIZE & SPACING
            //,	size:					100			// MUST be pane-specific -initial size of pane
            ,	minSize:				0			// when manually resizing a pane
            ,	maxSize:				0			// ditto, 0 = no limit
            ,	spacing_open:			6			// space between pane and adjacent panes - when pane is 'open'
            ,	spacing_closed:			6			// ditto - when pane is 'closed'
            ,	togglerLength_open:		50			// Length = WIDTH of toggler button on north/south sides - HEIGHT on east/west sides
            ,	togglerLength_closed: 	50			// 100% OR -1 means 'full height/width of resizer bar' - 0 means 'hidden'
            ,	togglerAlign_open:		"center"	// top/left, bottom/right, center, OR...
            ,	togglerAlign_closed:	"center"	// 1 => nn = offset from top/left, -1 => -nn == offset from bottom/right
            ,	togglerContent_open:	""			// text or HTML to put INSIDE the toggler
            ,	togglerContent_closed:	""			// ditto
            //	RESIZING OPTIONS
            ,	resizerDblClickToggle:	true		// 
            ,	autoResize:				true		// IF size is 'auto' or a percentage, then recalc 'pixel size' whenever the layout resizes
            ,	autoReopen:				true		// IF a pane was auto-closed due to noRoom, reopen it when there is room? False = leave it closed
            ,	resizerDragOpacity:		1			// option for ui.draggable
            //,	resizerCursor:			""			// MUST be pane-specific - cursor when over resizer-bar
            ,	maskContents:			false		// true = add DIV-mask over-or-inside this pane so can 'drag' over IFRAMES
            ,	maskObjects:			false		// true = add IFRAME-mask over-or-inside this pane to cover objects/applets - content-mask will overlay this mask
            ,	maskZindex:				null		// will override zIndexes.content_mask if specified - not applicable to iframe-panes
            ,	resizingGrid:			false		// grid size that the resizers will snap-to during resizing, eg: [20,20]
            ,	livePaneResizing:		false		// true = LIVE Resizing as resizer is dragged
            ,	liveContentResizing:	false		// true = re-measure header/footer heights as resizer is dragged
            ,	liveResizingTolerance:	1			// how many px change before pane resizes, to control performance
            //	SLIDING OPTIONS
            ,	sliderCursor:			"pointer"	// cursor when resizer-bar will trigger 'sliding'
            ,	slideTrigger_open:		"click"		// click, dblclick, mouseenter
            ,	slideTrigger_close:		"mouseleave"// click, mouseleave
            ,	slideDelay_open:		300			// applies only for mouseenter event - 0 = instant open
            ,	slideDelay_close:		300			// applies only for mouseleave event (300ms is the minimum!)
            ,	hideTogglerOnSlide:		false		// when pane is slid-open, should the toggler show?
            ,	preventQuickSlideClose:	$.layout.browser.webkit // Chrome triggers slideClosed as it is opening
            ,	preventPrematureSlideClose: false	// handle incorrect mouseleave trigger, like when over a SELECT-list in IE
            //	PANE-SPECIFIC TIPS & MESSAGES
            ,	tips: {
                Open:				"Open"		// eg: "Open Pane"
                ,	Close:				"Close"
                ,	Resize:				"Resize"
                ,	Slide:				"Slide Open"
                ,	Pin:				"Pin"
                ,	Unpin:				"Un-Pin"
                ,	noRoomToOpen:		"Not enough room to show this panel."	// alert if user tries to open a pane that cannot
                ,	minSizeWarning:		"Panel has reached its minimum size"	// displays in browser statusbar
                ,	maxSizeWarning:		"Panel has reached its maximum size"	// ditto
            }
            //	HOT-KEYS & MISC
            ,	showOverflowOnHover:	false		// will bind allowOverflow() utility to pane.onMouseOver
            ,	enableCursorHotkey:		true		// enabled 'cursor' hotkeys
            //,	customHotkey:			""			// MUST be pane-specific - EITHER a charCode OR a character
            ,	customHotkeyModifier:	"SHIFT"		// either 'SHIFT', 'CTRL' or 'CTRL+SHIFT' - NOT 'ALT'
            //	PANE ANIMATION
            //	NOTE: fxSss_open, fxSss_close & fxSss_size options (eg: fxName_open) are auto-generated if not passed
            ,	fxName:					"slide" 	// ('none' or blank), slide, drop, scale -- only relevant to 'open' & 'close', NOT 'size'
            ,	fxSpeed:				null		// slow, normal, fast, 200, nnn - if passed, will OVERRIDE fxSettings.duration
            ,	fxSettings:				{}			// can be passed, eg: { easing: "easeOutBounce", duration: 1500 }
            ,	fxOpacityFix:			true		// tries to fix opacity in IE to restore anti-aliasing after animation
            ,	animatePaneSizing:		false		// true = animate resizing after dragging resizer-bar OR sizePane() is called
            /*  NOTE: Action-specific FX options are auto-generated from the options above if not specifically set:
             fxName_open:			"slide"		// 'Open' pane animation
             fnName_close:			"slide"		// 'Close' pane animation
             fxName_size:			"slide"		// 'Size' pane animation - when animatePaneSizing = true
             fxSpeed_open:			null
             fxSpeed_close:			null
             fxSpeed_size:			null
             fxSettings_open:		{}
             fxSettings_close:		{}
             fxSettings_size:		{}
             */
            //	CHILD/NESTED LAYOUTS
            ,	childOptions:			null		// Layout-options for nested/child layout - even {} is valid as options
            ,	initChildLayout:		true		// true = child layout will be created as soon as _this_ layout completes initialization
            ,	destroyChildLayout:		true		// true = destroy child-layout if this pane is destroyed
            ,	resizeChildLayout:		true		// true = trigger child-layout.resizeAll() when this pane is resized
            //	EVENT TRIGGERING
            ,	triggerEventsOnLoad:	false		// true = trigger onopen OR onclose callbacks when layout initializes
            ,	triggerEventsDuringLiveResize: true	// true = trigger onresize callback REPEATEDLY if livePaneResizing==true
            //	PANE CALLBACKS
            ,	onshow_start:			null		// CALLBACK when pane STARTS to Show	- BEFORE onopen/onhide_start
            ,	onshow_end:				null		// CALLBACK when pane ENDS being Shown	- AFTER  onopen/onhide_end
            ,	onhide_start:			null		// CALLBACK when pane STARTS to Close	- BEFORE onclose_start
            ,	onhide_end:				null		// CALLBACK when pane ENDS being Closed	- AFTER  onclose_end
            ,	onopen_start:			null		// CALLBACK when pane STARTS to Open
            ,	onopen_end:				null		// CALLBACK when pane ENDS being Opened
            ,	onclose_start:			null		// CALLBACK when pane STARTS to Close
            ,	onclose_end:			null		// CALLBACK when pane ENDS being Closed
            ,	onresize_start:			null		// CALLBACK when pane STARTS being Resized ***FOR ANY REASON***
            ,	onresize_end:			null		// CALLBACK when pane ENDS being Resized ***FOR ANY REASON***
            ,	onsizecontent_start:	null		// CALLBACK when sizing of content-element STARTS
            ,	onsizecontent_end:		null		// CALLBACK when sizing of content-element ENDS
            ,	onswap_start:			null		// CALLBACK when pane STARTS to Swap
            ,	onswap_end:				null		// CALLBACK when pane ENDS being Swapped
            ,	ondrag_start:			null		// CALLBACK when pane STARTS being ***MANUALLY*** Resized
            ,	ondrag_end:				null		// CALLBACK when pane ENDS being ***MANUALLY*** Resized
        }
        /*
         *	PANE-SPECIFIC SETTINGS
         *	- options listed below MUST be specified per-pane - they CANNOT be set under 'panes'
         *	- all options under the 'panes' key can also be set specifically for any pane
         *	- most options under the 'panes' key apply only to 'border-panes' - NOT the the center-pane
         */
        ,	north: {
            paneSelector:			".ui-layout-north"
            ,	size:					"auto"		// eg: "auto", "30%", .30, 200
            ,	resizerCursor:			"n-resize"	// custom = url(myCursor.cur)
            ,	customHotkey:			""			// EITHER a charCode (43) OR a character ("o")
        }
        ,	south: {
            paneSelector:			".ui-layout-south"
            ,	size:					"auto"
            ,	resizerCursor:			"s-resize"
            ,	customHotkey:			""
        }
        ,	east: {
            paneSelector:			".ui-layout-east"
            ,	size:					200
            ,	resizerCursor:			"e-resize"
            ,	customHotkey:			""
        }
        ,	west: {
            paneSelector:			".ui-layout-west"
            ,	size:					200
            ,	resizerCursor:			"w-resize"
            ,	customHotkey:			""
        }
        ,	center: {
            paneSelector:			".ui-layout-center"
            ,	minWidth:				0
            ,	minHeight:				0
        }
    };

    $.layout.optionsMap = {
        // layout/global options - NOT pane-options
        layout: ("stateManagement,effects,zIndexes,errors,"
            +	"name,zIndex,scrollToBookmarkOnLoad,showErrorMessages,"
            +	"resizeWithWindow,resizeWithWindowDelay,resizeWithWindowMaxDelay,"
            +	"onresizeall,onresizeall_start,onresizeall_end,onload,onunload").split(",")
//	borderPanes: [ ALL options that are NOT specified as 'layout' ]
        // default.panes options that apply to the center-pane (most options apply _only_ to border-panes)
        ,	center: ("paneClass,contentSelector,contentIgnoreSelector,findNestedContent,applyDemoStyles,triggerEventsOnLoad,"
            +	"showOverflowOnHover,maskContents,maskObjects,liveContentResizing,"
            +	"childOptions,initChildLayout,resizeChildLayout,destroyChildLayout,"
            +	"onresize,onresize_start,onresize_end,onsizecontent,onsizecontent_start,onsizecontent_end").split(",")
        // options that MUST be specifically set 'per-pane' - CANNOT set in the panes (defaults) key
        ,	noDefault: ("paneSelector,resizerCursor,customHotkey").split(",")
    };

    /**
     * Processes options passed in converts flat-format data into subkey (JSON) format
     * In flat-format, subkeys are _currently_ separated with 2 underscores, like north__optName
     * Plugins may also call this method so they can transform their own data
     *
     * @param  {!Object}	hash	Data/options passed by user - may be a single level or nested levels
     * @return {Object}				Returns hash of minWidth & minHeight
     */
    $.layout.transformData = function (hash) {
        var	json = { panes: {}, center: {} } // init return object
            ,	data, branch, optKey, keys, key, val, i, c;

        if (typeof hash !== "object") return json; // no options passed

        // convert all 'flat-keys' to 'sub-key' format
        for (optKey in hash) {
            branch	= json;
            data	= $.layout.optionsMap.layout;
            val		= hash[ optKey ];
            keys	= optKey.split("__"); // eg: west__size or north__fxSettings__duration
            c		= keys.length - 1;
            // convert underscore-delimited to subkeys
            for (i=0; i <= c; i++) {
                key = keys[i];
                if (i === c)
                    branch[key] = val;
                else if (!branch[key])
                    branch[key] = {}; // create the subkey
                // recurse to sub-key for next loop - if not done
                branch = branch[key];
            }
        }

        return json;
    };

// INTERNAL CONFIG DATA - DO NOT CHANGE THIS!
    $.layout.backwardCompatibility = {
        // data used by renameOldOptions()
        map: {
            //	OLD Option Name:			NEW Option Name
            applyDefaultStyles:			"applyDemoStyles"
            ,	resizeNestedLayout:			"resizeChildLayout"
            ,	resizeWhileDragging:		"livePaneResizing"
            ,	resizeContentWhileDragging:	"liveContentResizing"
            ,	triggerEventsWhileDragging:	"triggerEventsDuringLiveResize"
            ,	maskIframesOnResize:		"maskContents"
            ,	useStateCookie:				"stateManagement.enabled"
            ,	"cookie.autoLoad":			"stateManagement.autoLoad"
            ,	"cookie.autoSave":			"stateManagement.autoSave"
            ,	"cookie.keys":				"stateManagement.stateKeys"
            ,	"cookie.name":				"stateManagement.cookie.name"
            ,	"cookie.domain":			"stateManagement.cookie.domain"
            ,	"cookie.path":				"stateManagement.cookie.path"
            ,	"cookie.expires":			"stateManagement.cookie.expires"
            ,	"cookie.secure":			"stateManagement.cookie.secure"
            //	OLD Language options
            ,	noRoomToOpenTip:			"tips.noRoomToOpen"
            ,	togglerTip_open:			"tips.Close"	// open   = Close
            ,	togglerTip_closed:			"tips.Open"		// closed = Open
            ,	resizerTip:					"tips.Resize"
            ,	sliderTip:					"tips.Slide"
        }

        /**
         * @param {Object}	opts
         */
        ,	renameOptions: function (opts) {
            var map = $.layout.backwardCompatibility.map
                ,	oldData, newData, value
                ;
            for (var itemPath in map) {
                oldData	= getBranch( itemPath );
                value	= oldData.branch[ oldData.key ];
                if (value !== undefined) {
                    newData = getBranch( map[itemPath], true );
                    newData.branch[ newData.key ] = value;
                    delete oldData.branch[ oldData.key ];
                }
            }

            /**
             * @param {string}	path
             * @param {boolean=}	[create=false]	Create path if does not exist
             */
            function getBranch (path, create) {
                var a = path.split(".") // split keys into array
                    ,	c = a.length - 1
                    ,	D = { branch: opts, key: a[c] } // init branch at top & set key (last item)
                    ,	i = 0, k, undef;
                for (; i<c; i++) { // skip the last key (data)
                    k = a[i];
                    if (D.branch[ k ] == undefined) { // child-key does not exist
                        if (create) {
                            D.branch = D.branch[ k ] = {}; // create child-branch
                        }
                        else // can't go any farther
                            D.branch = {}; // branch is undefined
                    }
                    else
                        D.branch = D.branch[ k ]; // get child-branch
                }
                return D;
            };
        }

        /**
         * @param {Object}	opts
         */
        ,	renameAllOptions: function (opts) {
            var ren = $.layout.backwardCompatibility.renameOptions;
            // rename root (layout) options
            ren( opts );
            // rename 'defaults' to 'panes'
            if (opts.defaults) {
                if (typeof opts.panes !== "object")
                    opts.panes = {};
                $.extend(true, opts.panes, opts.defaults);
                delete opts.defaults;
            }
            // rename options in the the options.panes key
            if (opts.panes) ren( opts.panes );
            // rename options inside *each pane key*, eg: options.west
            $.each($.layout.config.allPanes, function (i, pane) {
                if (opts[pane]) ren( opts[pane] );
            });
            return opts;
        }
    };




    /*	============================================================
     *	BEGIN WIDGET: $( selector ).layout( {options} );
     *	============================================================
     */
    $.fn.layout = function (opts) {
        var

        // local aliases to global data
            browser	= $.layout.browser
            ,	_c		= $.layout.config

        // local aliases to utlity methods
            ,	cssW	= $.layout.cssWidth
            ,	cssH	= $.layout.cssHeight
            ,	elDims	= $.layout.getElementDimensions
            ,	elCSS	= $.layout.getElementCSS
            ,	evtObj	= $.layout.getEventObject
            ,	evtPane	= $.layout.parsePaneName

        /**
         * options - populated by initOptions()
         */
            ,	options = $.extend(true, {}, $.layout.defaults)
            ,	effects	= options.effects = $.extend(true, {}, $.layout.effects)

        /**
         * layout-state object
         */
            ,	state = {
                // generate unique ID to use for event.namespace so can unbind only events added by 'this layout'
                id:			"layout"+ $.now()	// code uses alias: sID
                ,	initialized: false
                ,	container:	{} // init all keys
                ,	north:		{}
                ,	south:		{}
                ,	east:		{}
                ,	west:		{}
                ,	center:		{}
            }

        /**
         * parent/child-layout pointers
         */
//,	hasParentLayout	= false	- exists ONLY inside Instance so can be set externally
            ,	children = {
                north:		null
                ,	south:		null
                ,	east:		null
                ,	west:		null
                ,	center:		null
            }

        /*
         * ###########################
         *  INTERNAL HELPER FUNCTIONS
         * ###########################
         */

        /**
         * Manages all internal timers
         */
            ,	timer = {
                data:	{}
                ,	set:	function (s, fn, ms) { timer.clear(s); timer.data[s] = setTimeout(fn, ms); }
                ,	clear:	function (s) { var t=timer.data; if (t[s]) {clearTimeout(t[s]); delete t[s];} }
            }

        /**
         * Alert or console.log a message - IF option is enabled.
         *
         * @param {(string|!Object)}	msg		Message (or debug-data) to display
         * @param {?boolean}			popup	True by default, means 'alert', false means use console.log
         * @param {?boolean}			debug	True means is a widget debugging message
         */
            ,	_log = function (msg, popup, debug) {
                var o = options;
                if ((o.showErrorMessages && !debug) || (debug && o.showDebugMessages))
                    $.layout.msg( o.name +' / '+ msg, (popup !== false) );
                return false;
            }

        /**
         * Executes a Callback function after a trigger event, like resize, open or close
         *
         * @param {string}			evtName			Name of the layout callback, eg "onresize_start"
         * @param {?string}			pane			This is passed only so we can pass the 'pane object' to the callback
         * @param {?string|?boolean}	skipBoundEvents	True = do not run events bound to the elements - only the callbacks set in options
         */
            ,	_runCallbacks = function (evtName, pane, skipBoundEvents) {
                var	paneCB	= pane && isStr(pane)
                    ,	s		= paneCB ? state[pane] : state
                    ,	o		= paneCB ? options[pane] : options
                    ,	lName	= options.name
                // names like onopen and onopen_end separate are interchangeable in options...
                    ,	lng		= evtName + (evtName.match(/_/) ? "" : "_end")
                    ,	shrt	= lng.match(/_end$/) ? lng.substr(0, lng.length - 4) : ""
                    ,	fn		= o[lng] || o[shrt]
                    ,	retVal	= "NC" // NC = No Callback
                    ,	args	= []
                    ,	$P
                    ;
                if ( !paneCB && $.type(skipBoundEvents) !== 'boolean' )
                    skipBoundEvents = pane; // allow pane param to be skipped for Layout callback

                // first trigger the callback set in the options
                if (fn) {
                    try {
                        // convert function name (string) to function object
                        if (isStr( fn )) {
                            if (fn.match(/,/)) {
                                // function name cannot contain a comma, 
                                // so must be a function name AND a parameter to pass
                                args = fn.split(",")
                                    ,	fn = eval(args[0]);
                            }
                            else // just the name of an external function?
                                fn = eval(fn);
                        }
                        // execute the callback, if exists
                        if ($.isFunction( fn )) {
                            if (args.length)
                                retVal = fn(args[1]); // pass the argument parsed from 'list'
                            else if ( paneCB )
                            // pass data: pane-name, pane-element, pane-state, pane-options, and layout-name
                                retVal = fn( pane, $Ps[pane], s, o, lName );
                            else // must be a layout/container callback - pass suitable info
                                retVal = fn( Instance, s, o, lName );
                        }
                    }
                    catch (ex) {
                        _log( options.errors.callbackError.replace(/EVENT/, $.trim(pane +" "+ lng)), false );
                    }
                }

                // trigger additional events bound directly to the pane
                if (!skipBoundEvents && retVal !== false) {
                    if ( paneCB ) { // PANE events can be bound to each pane-elements
                        $P	= $Ps[pane];
                        o	= options[pane];
                        s	= state[pane];
                        $P.triggerHandler('layoutpane'+ lng, [ pane, $P, s, o, lName ]);
                        if (shrt)
                            $P.triggerHandler('layoutpane'+ shrt, [ pane, $P, s, o, lName ]);
                    }
                    else { // LAYOUT events can be bound to the container-element
                        $N.triggerHandler('layout'+ lng, [ Instance, s, o, lName ]);
                        if (shrt)
                            $N.triggerHandler('layout'+ shrt, [ Instance, s, o, lName ]);
                    }
                }

                // ALWAYS resizeChildLayout after a resize event - even during initialization
                if (evtName === "onresize_end" || evtName === "onsizecontent_end")
                    resizeChildLayout(pane);

                return retVal;
            }


        /**
         * cure iframe display issues in IE & other browsers
         */
            ,	_fixIframe = function (pane) {
                if (browser.mozilla) return; // skip FireFox - it auto-refreshes iframes onShow
                var $P = $Ps[pane];
                // if the 'pane' is an iframe, do it
                if (state[pane].tagName === "IFRAME")
                    $P.css(_c.hidden).css(_c.visible);
                else // ditto for any iframes INSIDE the pane
                    $P.find('IFRAME').css(_c.hidden).css(_c.visible);
            }

        /**
         * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
         * @param  {number=}		outerSize	(optional) Can pass a width, allowing calculations BEFORE element is resized
         * @return {number}		Returns the innerHeight/Width of el by subtracting padding and borders
         */
            ,	cssSize = function (pane, outerSize) {
                var fn = _c[pane].dir=="horz" ? cssH : cssW;
                return fn($Ps[pane], outerSize);
            }

        /**
         * @param  {string}		pane		Can accept ONLY a 'pane' (east, west, etc)
         * @return {Object}		Returns hash of minWidth & minHeight
         */
            ,	cssMinDims = function (pane) {
                // minWidth/Height means CSS width/height = 1px
                var	$P	= $Ps[pane]
                    ,	dir	= _c[pane].dir
                    ,	d	= {
                        minWidth:	1001 - cssW($P, 1000)
                        ,	minHeight:	1001 - cssH($P, 1000)
                    }
                    ;
                if (dir === "horz") d.minSize = d.minHeight;
                if (dir === "vert") d.minSize = d.minWidth;
                return d;
            }

        // TODO: see if these methods can be made more useful...
        // TODO: *maybe* return cssW/H from these so caller can use this info

        /**
         * @param {(string|!Object)}		el
         * @param {number=}				outerWidth
         * @param {boolean=}				[autoHide=false]
         */
            ,	setOuterWidth = function (el, outerWidth, autoHide) {
                var $E = el, w;
                if (isStr(el)) $E = $Ps[el]; // west
                else if (!el.jquery) $E = $(el);
                w = cssW($E, outerWidth);
                $E.css({ width: w });
                if (w > 0) {
                    if (autoHide && $E.data('autoHidden') && $E.innerHeight() > 0) {
                        $E.show().data('autoHidden', false);
                        if (!browser.mozilla) // FireFox refreshes iframes - IE does not
                        // make hidden, then visible to 'refresh' display after animation
                            $E.css(_c.hidden).css(_c.visible);
                    }
                }
                else if (autoHide && !$E.data('autoHidden'))
                    $E.hide().data('autoHidden', true);
            }

        /**
         * @param {(string|!Object)}		el
         * @param {number=}				outerHeight
         * @param {boolean=}				[autoHide=false]
         */
            ,	setOuterHeight = function (el, outerHeight, autoHide) {
                var $E = el, h;
                if (isStr(el)) $E = $Ps[el]; // west
                else if (!el.jquery) $E = $(el);
                h = cssH($E, outerHeight);
                $E.css({ height: h, visibility: "visible" }); // may have been 'hidden' by sizeContent
                if (h > 0 && $E.innerWidth() > 0) {
                    if (autoHide && $E.data('autoHidden')) {
                        $E.show().data('autoHidden', false);
                        if (!browser.mozilla) // FireFox refreshes iframes - IE does not
                            $E.css(_c.hidden).css(_c.visible);
                    }
                }
                else if (autoHide && !$E.data('autoHidden'))
                    $E.hide().data('autoHidden', true);
            }

        /**
         * @param {(string|!Object)}		el
         * @param {number=}				outerSize
         * @param {boolean=}				[autoHide=false]
         */
            ,	setOuterSize = function (el, outerSize, autoHide) {
                if (_c[pane].dir=="horz") // pane = north or south
                    setOuterHeight(el, outerSize, autoHide);
                else // pane = east or west
                    setOuterWidth(el, outerSize, autoHide);
            }


        /**
         * Converts any 'size' params to a pixel/integer size, if not already
         * If 'auto' or a decimal/percentage is passed as 'size', a pixel-size is calculated
         *
         /**
         * @param  {string}				pane
         * @param  {(string|number)=}	size
         * @param  {string=}				[dir]
         * @return {number}
         */
            ,	_parseSize = function (pane, size, dir) {
                if (!dir) dir = _c[pane].dir;

                if (isStr(size) && size.match(/%/))
                    size = (size === '100%') ? -1 : parseInt(size, 10) / 100; // convert % to decimal

                if (size === 0)
                    return 0;
                else if (size >= 1)
                    return parseInt(size, 10);

                var o = options, avail = 0;
                if (dir=="horz") // north or south or center.minHeight
                    avail = sC.innerHeight - ($Ps.north ? o.north.spacing_open : 0) - ($Ps.south ? o.south.spacing_open : 0);
                else if (dir=="vert") // east or west or center.minWidth
                    avail = sC.innerWidth - ($Ps.west ? o.west.spacing_open : 0) - ($Ps.east ? o.east.spacing_open : 0);

                if (size === -1) // -1 == 100%
                    return avail;
                else if (size > 0) // percentage, eg: .25
                    return round(avail * size);
                else if (pane=="center")
                    return 0;
                else { // size < 0 || size=='auto' || size==Missing || size==Invalid
                    // auto-size the pane
                    var	dim	= (dir === "horz" ? "height" : "width")
                        ,	$P	= $Ps[pane]
                        ,	$C	= dim === 'height' ? $Cs[pane] : false
                        ,	vis	= $.layout.showInvisibly($P) // show pane invisibly if hidden
                        ,	szP	= $P.css(dim) // SAVE current pane size
                        ,	szC	= $C ? $C.css(dim) : 0 // SAVE current content size
                        ;
                    $P.css(dim, "auto");
                    if ($C) $C.css(dim, "auto");
                    size = (dim === "height") ? $P.outerHeight() : $P.outerWidth(); // MEASURE
                    $P.css(dim, szP).css(vis); // RESET size & visibility
                    if ($C) $C.css(dim, szC);
                    return size;
                }
            }

        /**
         * Calculates current 'size' (outer-width or outer-height) of a border-pane - optionally with 'pane-spacing' added
         *
         * @param  {(string|!Object)}	pane
         * @param  {boolean=}			[inclSpace=false]
         * @return {number}				Returns EITHER Width for east/west panes OR Height for north/south panes
         */
            ,	getPaneSize = function (pane, inclSpace) {
                var
                    $P	= $Ps[pane]
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                    ,	oSp	= (inclSpace ? o.spacing_open : 0)
                    ,	cSp	= (inclSpace ? o.spacing_closed : 0)
                    ;
                if (!$P || s.isHidden)
                    return 0;
                else if (s.isClosed || (s.isSliding && inclSpace))
                    return cSp;
                else if (_c[pane].dir === "horz")
                    return $P.outerHeight() + oSp;
                else // dir === "vert"
                    return $P.outerWidth() + oSp;
            }

        /**
         * Calculate min/max pane dimensions and limits for resizing
         *
         * @param  {string}		pane
         * @param  {boolean=}	[slide=false]
         */
            ,	setSizeLimits = function (pane, slide) {
                if (!isInitialized()) return;
                var
                    o				= options[pane]
                    ,	s				= state[pane]
                    ,	c				= _c[pane]
                    ,	dir				= c.dir
                    ,	side			= c.side.toLowerCase()
                    ,	type			= c.sizeType.toLowerCase()
                    ,	isSliding		= (slide != undefined ? slide : s.isSliding) // only open() passes 'slide' param
                    ,	$P				= $Ps[pane]
                    ,	paneSpacing		= o.spacing_open
                //	measure the pane on the *opposite side* from this pane
                    ,	altPane			= _c.oppositeEdge[pane]
                    ,	altS			= state[altPane]
                    ,	$altP			= $Ps[altPane]
                    ,	altPaneSize		= (!$altP || altS.isVisible===false || altS.isSliding ? 0 : (dir=="horz" ? $altP.outerHeight() : $altP.outerWidth()))
                    ,	altPaneSpacing	= ((!$altP || altS.isHidden ? 0 : options[altPane][ altS.isClosed !== false ? "spacing_closed" : "spacing_open" ]) || 0)
                //	limitSize prevents this pane from 'overlapping' opposite pane
                    ,	containerSize	= (dir=="horz" ? sC.innerHeight : sC.innerWidth)
                    ,	minCenterDims	= cssMinDims("center")
                    ,	minCenterSize	= dir=="horz" ? max(options.center.minHeight, minCenterDims.minHeight) : max(options.center.minWidth, minCenterDims.minWidth)
                //	if pane is 'sliding', then ignore center and alt-pane sizes - because 'overlays' them
                    ,	limitSize		= (containerSize - paneSpacing - (isSliding ? 0 : (_parseSize("center", minCenterSize, dir) + altPaneSize + altPaneSpacing)))
                    ,	minSize			= s.minSize = max( _parseSize(pane, o.minSize), cssMinDims(pane).minSize )
                    ,	maxSize			= s.maxSize = min( (o.maxSize ? _parseSize(pane, o.maxSize) : 100000), limitSize )
                    ,	r				= s.resizerPosition = {} // used to set resizing limits
                    ,	top				= sC.insetTop
                    ,	left			= sC.insetLeft
                    ,	W				= sC.innerWidth
                    ,	H				= sC.innerHeight
                    ,	rW				= o.spacing_open // subtract resizer-width to get top/left position for south/east
                    ;
                switch (pane) {
                    case "north":	r.min = top + minSize;
                        r.max = top + maxSize;
                        break;
                    case "west":	r.min = left + minSize;
                        r.max = left + maxSize;
                        break;
                    case "south":	r.min = top + H - maxSize - rW;
                        r.max = top + H - minSize - rW;
                        break;
                    case "east":	r.min = left + W - maxSize - rW;
                        r.max = left + W - minSize - rW;
                        break;
                };
            }

        /**
         * Returns data for setting the size/position of center pane. Also used to set Height for east/west panes
         *
         * @return JSON  Returns a hash of all dimensions: top, bottom, left, right, (outer) width and (outer) height
         */
            ,	calcNewCenterPaneDims = function () {
                var d = {
                    top:	getPaneSize("north", true) // true = include 'spacing' value for pane
                    ,	bottom:	getPaneSize("south", true)
                    ,	left:	getPaneSize("west", true)
                    ,	right:	getPaneSize("east", true)
                    ,	width:	0
                    ,	height:	0
                };

                // NOTE: sC = state.container
                // calc center-pane outer dimensions
                d.width		= sC.innerWidth - d.left - d.right;  // outerWidth
                d.height	= sC.innerHeight - d.bottom - d.top; // outerHeight
                // add the 'container border/padding' to get final positions relative to the container
                d.top		+= sC.insetTop;
                d.bottom	+= sC.insetBottom;
                d.left		+= sC.insetLeft;
                d.right		+= sC.insetRight;

                return d;
            }


        /**
         * @param {!Object}		el
         * @param {boolean=}		[allStates=false]
         */
            ,	getHoverClasses = function (el, allStates) {
                var
                    $El		= $(el)
                    ,	type	= $El.data("layoutRole")
                    ,	pane	= $El.data("layoutEdge")
                    ,	o		= options[pane]
                    ,	root	= o[type +"Class"]
                    ,	_pane	= "-"+ pane // eg: "-west"
                    ,	_open	= "-open"
                    ,	_closed	= "-closed"
                    ,	_slide	= "-sliding"
                    ,	_hover	= "-hover " // NOTE the trailing space
                    ,	_state	= $El.hasClass(root+_closed) ? _closed : _open
                    ,	_alt	= _state === _closed ? _open : _closed
                    ,	classes = (root+_hover) + (root+_pane+_hover) + (root+_state+_hover) + (root+_pane+_state+_hover)
                    ;
                if (allStates) // when 'removing' classes, also remove alternate-state classes
                    classes += (root+_alt+_hover) + (root+_pane+_alt+_hover);

                if (type=="resizer" && $El.hasClass(root+_slide))
                    classes += (root+_slide+_hover) + (root+_pane+_slide+_hover);

                return $.trim(classes);
            }
            ,	addHover	= function (evt, el) {
                var $E = $(el || this);
                if (evt && $E.data("layoutRole") === "toggler")
                    evt.stopPropagation(); // prevent triggering 'slide' on Resizer-bar
                $E.addClass( getHoverClasses($E) );
            }
            ,	removeHover	= function (evt, el) {
                var $E = $(el || this);
                $E.removeClass( getHoverClasses($E, true) );
            }

            ,	onResizerEnter	= function (evt) { // ALSO called by toggler.mouseenter
                if ($.fn.disableSelection)
                    $("body").disableSelection();
            }
            ,	onResizerLeave	= function (evt, el) {
                var
                    e = el || this // el is only passed when called by the timer
                    ,	pane = $(e).data("layoutEdge")
                    ,	name = pane +"ResizerLeave"
                    ;
                timer.clear(pane+"_openSlider"); // cancel slideOpen timer, if set
                timer.clear(name); // cancel enableSelection timer - may re/set below
                // this method calls itself on a timer because it needs to allow
                // enough time for dragging to kick-in and set the isResizing flag
                // dragging has a 100ms delay set, so this delay must be >100
                if (!el) // 1st call - mouseleave event
                    timer.set(name, function(){ onResizerLeave(evt, e); }, 200);
                // if user is resizing, then dragStop will enableSelection(), so can skip it here
                else if (!state[pane].isResizing && $.fn.enableSelection) // 2nd call - by timer
                    $("body").enableSelection();
            }

        /*
         * ###########################
         *   INITIALIZATION METHODS
         * ###########################
         */

        /**
         * Initialize the layout - called automatically whenever an instance of layout is created
         *
         * @see  none - triggered onInit
         * @return  mixed	true = fully initialized | false = panes not initialized (yet) | 'cancel' = abort
         */
            ,	_create = function () {
                // initialize config/options
                initOptions();
                var o = options;

                // TEMP state so isInitialized returns true during init process
                state.creatingLayout = true;

                // init plugins for this layout, if there are any (eg: stateManagement)
                runPluginCallbacks( Instance, $.layout.onCreate );

                // options & state have been initialized, so now run beforeLoad callback
                // onload will CANCEL layout creation if it returns false
                if (false === _runCallbacks("onload_start"))
                    return 'cancel';

                // initialize the container element
                _initContainer();

                // bind hotkey function - keyDown - if required
                initHotkeys();

                // bind window.onunload
                $(window).bind("unload."+ sID, unload);

                // init plugins for this layout, if there are any (eg: customButtons)
                runPluginCallbacks( Instance, $.layout.onLoad );

                // if layout elements are hidden, then layout WILL NOT complete initialization!
                // initLayoutElements will set initialized=true and run the onload callback IF successful
                if (o.initPanes) _initLayoutElements();

                delete state.creatingLayout;

                return state.initialized;
            }

        /**
         * Initialize the layout IF not already
         *
         * @see  All methods in Instance run this test
         * @return  boolean	true = layoutElements have been initialized | false = panes are not initialized (yet)
         */
            ,	isInitialized = function () {
                if (state.initialized || state.creatingLayout) return true;	// already initialized
                else return _initLayoutElements();	// try to init panes NOW
            }

        /**
         * Initialize the layout - called automatically whenever an instance of layout is created
         *
         * @see  _create() & isInitialized
         * @return  An object pointer to the instance created
         */
            ,	_initLayoutElements = function (retry) {
                // initialize config/options
                var o = options;

                // CANNOT init panes inside a hidden container!
                if (!$N.is(":visible")) {
                    // handle Chrome bug where popup window 'has no height'
                    // if layout is BODY element, try again in 50ms
                    // SEE: http://layout.jquery-dev.net/samples/test_popup_window.html
                    if ( !retry && browser.webkit && $N[0].tagName === "BODY" )
                        setTimeout(function(){ _initLayoutElements(true); }, 50);
                    return false;
                }

                // a center pane is required, so make sure it exists
                if (!getPane("center").length) {
                    return _log( o.errors.centerPaneMissing );
                }

                // TEMP state so isInitialized returns true during init process
                state.creatingLayout = true;

                // update Container dims
                $.extend(sC, elDims( $N ));

                // initialize all layout elements
                initPanes();	// size & position panes - calls initHandles() - which calls initResizable()

                if (o.scrollToBookmarkOnLoad) {
                    var l = self.location;
                    if (l.hash) l.replace( l.hash ); // scrollTo Bookmark
                }

                // check to see if this layout 'nested' inside a pane
                if (Instance.hasParentLayout)
                    o.resizeWithWindow = false;
                // bind resizeAll() for 'this layout instance' to window.resize event
                else if (o.resizeWithWindow)
                    $(window).bind("resize."+ sID, windowResize);

                delete state.creatingLayout;
                state.initialized = true;

                // init plugins for this layout, if there are any
                runPluginCallbacks( Instance, $.layout.onReady );

                // now run the onload callback, if exists
                _runCallbacks("onload_end");

                return true; // elements initialized successfully
            }

        /**
         * Initialize nested layouts - called when _initLayoutElements completes
         *
         * NOT CURRENTLY USED
         *
         * @see _initLayoutElements
         * @return  An object pointer to the instance created
         */
            ,	_initChildLayouts = function () {
                $.each(_c.allPanes, function (idx, pane) {
                    if (options[pane].initChildLayout)
                        createChildLayout( pane );
                });
            }

        /**
         * Initialize nested layouts for a specific pane - can optionally pass layout-options
         *
         * @see _initChildLayouts
         * @param {string|Object}	evt_or_pane	The pane being opened, ie: north, south, east, or west
         * @param {Object=}			[opts]		Layout-options - if passed, will OVERRRIDE options[pane].childOptions
         * @return  An object pointer to the layout instance created - or null
         */
            ,	createChildLayout = function (evt_or_pane, opts) {
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$P	= $Ps[pane]
                    ,	C	= children
                    ;
                if ($P) {
                    var	$C	= $Cs[pane]
                        ,	o	= opts || options[pane].childOptions
                        ,	d	= "layout"
                    //	determine which element is supposed to be the 'child container'
                    //	if pane has a 'containerSelector' OR a 'content-div', use those instead of the pane
                        ,	$Cont = o.containerSelector ? $P.find( o.containerSelector ) : ($C || $P)
                        ,	containerFound = $Cont.length
                    //	see if a child-layout ALREADY exists on this element
                        ,	child = containerFound ? (C[pane] = $Cont.data(d) || null) : null
                        ;
                    // if no layout exists, but childOptions are set, try to create the layout now
                    if (!child && containerFound && o)
                        child = C[pane] = $Cont.eq(0).layout(o) || null;
                    if (child)
                        child.hasParentLayout = true;	// set parent-flag in child
                }
                Instance[pane].child = C[pane]; // ALWAYS set pane-object pointer, even if null
            }

            ,	windowResize = function () {
                var delay = Number(options.resizeWithWindowDelay);
                if (delay < 10) delay = 100; // MUST have a delay!
                // resizing uses a delay-loop because the resize event fires repeatly - except in FF, but delay anyway
                timer.clear("winResize"); // if already running
                timer.set("winResize", function(){
                    timer.clear("winResize");
                    timer.clear("winResizeRepeater");
                    var dims = elDims( $N );
                    // only trigger resizeAll() if container has changed size
                    if (dims.innerWidth !== sC.innerWidth || dims.innerHeight !== sC.innerHeight)
                        resizeAll();
                }, delay);
                // ALSO set fixed-delay timer, if not already running
                if (!timer.data["winResizeRepeater"]) setWindowResizeRepeater();
            }

            ,	setWindowResizeRepeater = function () {
                var delay = Number(options.resizeWithWindowMaxDelay);
                if (delay > 0)
                    timer.set("winResizeRepeater", function(){ setWindowResizeRepeater(); resizeAll(); }, delay);
            }

            ,	unload = function () {
                var o = options;

                _runCallbacks("onunload_start");

                // trigger plugin callabacks for this layout (eg: stateManagement)
                runPluginCallbacks( Instance, $.layout.onUnload );

                _runCallbacks("onunload_end");
            }

        /**
         * Validate and initialize container CSS and events
         *
         * @see  _create()
         */
            ,	_initContainer = function () {
                var
                    N		= $N[0]
                    ,	tag		= sC.tagName = N.tagName
                    ,	id		= sC.id = N.id
                    ,	cls		= sC.className = N.className
                    ,	o		= options
                    ,	name	= o.name
                    ,	fullPage= (tag === "BODY")
                    ,	props	= "overflow,position,margin,padding,border"
                    ,	css		= "layoutCSS"
                    ,	CSS		= {}
                    ,	hid		= "hidden" // used A LOT!
                //	see if this container is a 'pane' inside an outer-layout
                    ,	parent	= $N.data("parentLayout")	// parent-layout Instance
                    ,	pane	= $N.data("layoutEdge")		// pane-name in parent-layout
                    ,	isChild	= parent && pane
                    ;
                // sC -> state.container
                sC.selector = $N.selector.split(".slice")[0];
                sC.ref		= (o.name ? o.name +' layout / ' : '') + tag + (id ? "#"+id : cls ? '.['+cls+']' : ''); // used in messages

                $N	.data({
                    layout: Instance
                    ,	layoutContainer: sID // FLAG to indicate this is a layout-container - contains unique internal ID
                })
                    .addClass(o.containerClass)
                ;
                var layoutMethods = {
                    destroy:	''
                    ,	initPanes:	''
                    ,	resizeAll:	'resizeAll'
                    ,	resize:		'resizeAll'
                };
                // loop hash and bind all methods - include layoutID namespacing
                for (name in layoutMethods) {
                    $N.bind("layout"+ name.toLowerCase() +"."+ sID, Instance[ layoutMethods[name] || name ]);
                }

                // if this container is another layout's 'pane', then set child/parent pointers
                if (isChild) {
                    // update parent flag
                    Instance.hasParentLayout = true;
                    // set pointers to THIS child-layout (Instance) in parent-layout
                    // NOTE: parent.PANE.child is an ALIAS to parent.children.PANE
                    parent[pane].child = parent.children[pane] = $N.data("layout");
                }

                // SAVE original container CSS for use in destroy()
                if (!$N.data(css)) {
                    // handle props like overflow different for BODY & HTML - has 'system default' values
                    if (fullPage) {
                        CSS = $.extend( elCSS($N, props), {
                            height:		$N.css("height")
                            ,	overflow:	$N.css("overflow")
                            ,	overflowX:	$N.css("overflowX")
                            ,	overflowY:	$N.css("overflowY")
                        });
                        // ALSO SAVE <HTML> CSS
                        var $H = $("html");
                        $H.data(css, {
                            height:		"auto" // FF would return a fixed px-size!
                            ,	overflow:	$H.css("overflow")
                            ,	overflowX:	$H.css("overflowX")
                            ,	overflowY:	$H.css("overflowY")
                        });
                    }
                    else // handle props normally for non-body elements
                        CSS = elCSS($N, props+",top,bottom,left,right,width,height,overflow,overflowX,overflowY");

                    $N.data(css, CSS);
                }

                try { // format html/body if this is a full page layout
                    if (fullPage) {
                        $("html").css({
                            height:		"100%"
                            ,	overflow:	hid
                            ,	overflowX:	hid
                            ,	overflowY:	hid
                        });
                        $("body").css({
                            position:	"relative"
                            ,	height:		"100%"
                            ,	overflow:	hid
                            ,	overflowX:	hid
                            ,	overflowY:	hid
                            ,	margin:		0
                            ,	padding:	0		// TODO: test whether body-padding could be handled?
                            ,	border:		"none"	// a body-border creates problems because it cannot be measured!
                        });

                        // set current layout-container dimensions
                        $.extend(sC, elDims( $N ));
                    }
                    else { // set required CSS for overflow and position
                        // ENSURE container will not 'scroll'
                        CSS = { overflow: hid, overflowX: hid, overflowY: hid }
                        var
                            p = $N.css("position")
                            ,	h = $N.css("height")
                            ;
                        // if this is a NESTED layout, then container/outer-pane ALREADY has position and height
                        if (!isChild) {
                            if (!p || !p.match(/fixed|absolute|relative/))
                                CSS.position = "relative"; // container MUST have a 'position'
                            /*
                             if (!h || h=="auto")
                             CSS.height = "100%"; // container MUST have a 'height'
                             */
                        }
                        $N.css( CSS );

                        // set current layout-container dimensions
                        if ( $N.is(":visible") ) {
                            $.extend(sC, elDims( $N ));
                            if (sC.innerHeight < 1)
                                _log( o.errors.noContainerHeight.replace(/CONTAINER/, sC.ref) );
                        }
                    }
                } catch (ex) {}
            }

        /**
         * Bind layout hotkeys - if options enabled
         *
         * @see  _create() and addPane()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
            ,	initHotkeys = function (panes) {
                panes = panes ? panes.split(",") : _c.borderPanes;
                // bind keyDown to capture hotkeys, if option enabled for ANY pane
                $.each(panes, function (i, pane) {
                    var o = options[pane];
                    if (o.enableCursorHotkey || o.customHotkey) {
                        $(document).bind("keydown."+ sID, keyDown); // only need to bind this ONCE
                        return false; // BREAK - binding was done
                    }
                });
            }

        /**
         * Build final OPTIONS data
         *
         * @see  _create()
         */
            ,	initOptions = function () {
                var data, d, pane, key, val, i, c, o;

                // reprocess user's layout-options to have correct options sub-key structure
                opts = $.layout.transformData( opts ); // panes = default subkey

                // auto-rename old options for backward compatibility
                opts = $.layout.backwardCompatibility.renameAllOptions( opts );

                // if user-options has 'panes' key (pane-defaults), clean it...
                if (!$.isEmptyObject(opts.panes)) {
                    // REMOVE any pane-defaults that MUST be set per-pane
                    data = $.layout.optionsMap.noDefault;
                    for (i=0, c=data.length; i<c; i++) {
                        key = data[i];
                        delete opts.panes[key]; // OK if does not exist
                    }
                    // REMOVE any layout-options specified under opts.panes
                    data = $.layout.optionsMap.layout;
                    for (i=0, c=data.length; i<c; i++) {
                        key = data[i];
                        delete opts.panes[key]; // OK if does not exist
                    }
                }

                // MOVE any NON-layout-options from opts-root to opts.panes
                data = $.layout.optionsMap.layout;
                var rootKeys = $.layout.config.optionRootKeys;
                for (key in opts) {
                    val = opts[key];
                    if ($.inArray(key, rootKeys) < 0 && $.inArray(key, data) < 0) {
                        if (!opts.panes[key])
                            opts.panes[key] = $.isPlainObject(val) ? $.extend(true, {}, val) : val;
                        delete opts[key]
                    }
                }

                // START by updating ALL options from opts
                $.extend(true, options, opts);

                // CREATE final options (and config) for EACH pane
                $.each(_c.allPanes, function (i, pane) {

                    // apply 'pane-defaults' to CONFIG.[PANE]
                    _c[pane] = $.extend(true, {}, _c.panes, _c[pane]);

                    d = options.panes;
                    o = options[pane];

                    // center-pane uses SOME keys in defaults.panes branch
                    if (pane === 'center') {
                        // ONLY copy keys from opts.panes listed in: $.layout.optionsMap.center
                        data = $.layout.optionsMap.center;		// list of 'center-pane keys'
                        for (i=0, c=data.length; i<c; i++) {	// loop the list...
                            key = data[i];
                            // only need to use pane-default if pane-specific value not set
                            if (!opts.center[key] && (opts.panes[key] || !o[key]))
                                o[key] = d[key]; // pane-default
                        }
                    }
                    else {
                        // border-panes use ALL keys in defaults.panes branch
                        o = options[pane] = $.extend(true, {}, d, o); // re-apply pane-specific opts AFTER pane-defaults
                        createFxOptions( pane );
                        // ensure all border-pane-specific base-classes exist
                        if (!o.resizerClass)	o.resizerClass	= "ui-layout-resizer";
                        if (!o.togglerClass)	o.togglerClass	= "ui-layout-toggler";
                    }
                    // ensure we have base pane-class (ALL panes)
                    if (!o.paneClass) o.paneClass = "ui-layout-pane";
                });

                // update options.zIndexes if a zIndex-option specified
                var zo	= opts.zIndex
                    ,	z	= options.zIndexes;
                if (zo > 0) {
                    z.pane_normal		= zo;
                    z.content_mask		= max(zo+1, z.content_mask);	// MIN = +1
                    z.resizer_normal	= max(zo+2, z.resizer_normal);	// MIN = +2
                }

                // DELETE 'panes' key now that we are done - values were copied to EACH pane
                delete options.panes;


                function createFxOptions ( pane ) {
                    var	o = options[pane]
                        ,	d = options.panes;
                    // ensure fxSettings key to avoid errors
                    if (!o.fxSettings) o.fxSettings = {};
                    if (!d.fxSettings) d.fxSettings = {};

                    $.each(["_open","_close","_size"], function (i,n) {
                        var
                            sName		= "fxName"+ n
                            ,	sSpeed		= "fxSpeed"+ n
                            ,	sSettings	= "fxSettings"+ n
                        // recalculate fxName according to specificity rules
                            ,	fxName = o[sName] =
                                o[sName]	// options.west.fxName_open
                                    ||	d[sName]	// options.panes.fxName_open
                                    ||	o.fxName	// options.west.fxName
                                    ||	d.fxName	// options.panes.fxName
                                    ||	"none"		// MEANS $.layout.defaults.panes.fxName == "" || false || null || 0
                            ;
                        // validate fxName to ensure is valid effect - MUST have effect-config data in options.effects
                        if (fxName === "none" || !$.effects || !$.effects[fxName] || !options.effects[fxName])
                            fxName = o[sName] = "none"; // effect not loaded OR unrecognized fxName

                        // set vars for effects subkeys to simplify logic
                        var	fx		= options.effects[fxName] || {}	// effects.slide
                            ,	fx_all	= fx.all	|| null				// effects.slide.all
                            ,	fx_pane	= fx[pane]	|| null				// effects.slide.west
                            ;
                        // create fxSpeed[_open|_close|_size]
                        o[sSpeed] =
                            o[sSpeed]				// options.west.fxSpeed_open
                                ||	d[sSpeed]				// options.west.fxSpeed_open
                                ||	o.fxSpeed				// options.west.fxSpeed
                                ||	d.fxSpeed				// options.panes.fxSpeed
                                ||	null					// DEFAULT - let fxSetting.duration control speed
                        ;
                        // create fxSettings[_open|_close|_size]
                        o[sSettings] = $.extend(
                            true
                            ,	{}
                            ,	fx_all					// effects.slide.all
                            ,	fx_pane					// effects.slide.west
                            ,	d.fxSettings			// options.panes.fxSettings
                            ,	o.fxSettings			// options.west.fxSettings
                            ,	d[sSettings]			// options.panes.fxSettings_open
                            ,	o[sSettings]			// options.west.fxSettings_open
                        );
                    });

                    // DONE creating action-specific-settings for this pane,
                    // so DELETE generic options - are no longer meaningful
                    delete o.fxName;
                    delete o.fxSpeed;
                    delete o.fxSettings;
                }
            }

        /**
         * Initialize module objects, styling, size and position for all panes
         *
         * @see  _initElements()
         * @param {string}	pane		The pane to process
         */
            ,	getPane = function (pane) {
                var sel = options[pane].paneSelector
                if (sel.substr(0,1)==="#") // ID selector
                // NOTE: elements selected 'by ID' DO NOT have to be 'children'
                    return $N.find(sel).eq(0);
                else { // class or other selector
                    var $P = $N.children(sel).eq(0);
                    // look for the pane nested inside a 'form' element
                    return $P.length ? $P : $N.children("form:first").children(sel).eq(0);
                }
            }

            ,	initPanes = function (evt) {
                // stopPropagation if called by trigger("layoutinitpanes") - use evtPane utility 
                evtPane(evt);

                // NOTE: do north & south FIRST so we can measure their height - do center LAST
                $.each(_c.allPanes, function (idx, pane) {
                    addPane( pane, true );
                });

                // init the pane-handles NOW in case we have to hide or close the pane below
                initHandles();

                // now that all panes have been initialized and initially-sized,
                // make sure there is really enough space available for each pane
                $.each(_c.borderPanes, function (i, pane) {
                    if ($Ps[pane] && state[pane].isVisible) { // pane is OPEN
                        setSizeLimits(pane);
                        makePaneFit(pane); // pane may be Closed, Hidden or Resized by makePaneFit()
                    }
                });
                // size center-pane AGAIN in case we 'closed' a border-pane in loop above
                sizeMidPanes("center");

                //	Chrome/Webkit sometimes fires callbacks BEFORE it completes resizing!
                //	Before RC30.3, there was a 10ms delay here, but that caused layout 
                //	to load asynchrously, which is BAD, so try skipping delay for now

                // process pane contents and callbacks, and init/resize child-layout if exists
                $.each(_c.allPanes, function (i, pane) {
                    var o = options[pane];
                    if ($Ps[pane]) {
                        if (state[pane].isVisible) { // pane is OPEN
                            sizeContent(pane);
                            // trigger pane.onResize if triggerEventsOnLoad = true
                            if (o.triggerEventsOnLoad)
                                _runCallbacks("onresize_end", pane);
                            else // automatic if onresize called, otherwise call it specifically
                            // resize child - IF inner-layout already exists (created before this layout)
                                resizeChildLayout(pane);
                        }
                        // init childLayout - even if pane is not visible
                        if (o.initChildLayout && o.childOptions)
                            createChildLayout(pane);
                    }
                });
            }

        /**
         * Add a pane to the layout - subroutine of initPanes()
         *
         * @see  initPanes()
         * @param {string}	pane			The pane to process
         * @param {boolean=}	[force=false]	Size content after init
         */
            ,	addPane = function (pane, force) {
                if (!force && !isInitialized()) return;
                var
                    o		= options[pane]
                    ,	s		= state[pane]
                    ,	c		= _c[pane]
                    ,	fx		= s.fx
                    ,	dir		= c.dir
                    ,	spacing	= o.spacing_open || 0
                    ,	isCenter = (pane === "center")
                    ,	CSS		= {}
                    ,	$P		= $Ps[pane]
                    ,	size, minSize, maxSize
                    ;
                // if pane-pointer already exists, remove the old one first
                if ($P)
                    removePane( pane, false, true, false );
                else
                    $Cs[pane] = false; // init

                $P = $Ps[pane] = getPane(pane);
                if (!$P.length) {
                    $Ps[pane] = false; // logic
                    return;
                }

                // SAVE original Pane CSS
                if (!$P.data("layoutCSS")) {
                    var props = "position,top,left,bottom,right,width,height,overflow,zIndex,display,backgroundColor,padding,margin,border";
                    $P.data("layoutCSS", elCSS($P, props));
                }

                // create alias for pane data in Instance - initHandles will add more
                Instance[pane] = { name: pane, pane: $Ps[pane], content: $Cs[pane], options: options[pane], state: state[pane], child: children[pane] };

                // add classes, attributes & events
                $P	.data({
                    parentLayout:	Instance		// pointer to Layout Instance
                    ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
                    ,	layoutEdge:		pane
                    ,	layoutRole:		"pane"
                })
                    .css(c.cssReq).css("zIndex", options.zIndexes.pane_normal)
                    .css(o.applyDemoStyles ? c.cssDemo : {}) // demo styles
                    .addClass( o.paneClass +" "+ o.paneClass+"-"+pane ) // default = "ui-layout-pane ui-layout-pane-west" - may be a dupe of 'paneSelector'
                    .bind("mouseenter."+ sID, addHover )
                    .bind("mouseleave."+ sID, removeHover )
                ;
                var paneMethods = {
                        hide:				''
                        ,	show:				''
                        ,	toggle:				''
                        ,	close:				''
                        ,	open:				''
                        ,	slideOpen:			''
                        ,	slideClose:			''
                        ,	slideToggle:		''
                        ,	size:				'sizePane'
                        ,	sizePane:			'sizePane'
                        ,	sizeContent:		''
                        ,	sizeHandles:		''
                        ,	enableClosable:		''
                        ,	disableClosable:	''
                        ,	enableSlideable:	''
                        ,	disableSlideable:	''
                        ,	enableResizable:	''
                        ,	disableResizable:	''
                        ,	swapPanes:			'swapPanes'
                        ,	swap:				'swapPanes'
                        ,	move:				'swapPanes'
                        ,	removePane:			'removePane'
                        ,	remove:				'removePane'
                        ,	createChildLayout:	''
                        ,	resizeChildLayout:	''
                        ,	resizeAll:			'resizeAll'
                        ,	resizeLayout:		'resizeAll'
                    }
                    ,	name;
                // loop hash and bind all methods - include layoutID namespacing
                for (name in paneMethods) {
                    $P.bind("layoutpane"+ name.toLowerCase() +"."+ sID, Instance[ paneMethods[name] || name ]);
                }

                // see if this pane has a 'scrolling-content element'
                initContent(pane, false); // false = do NOT sizeContent() - called later

                if (!isCenter) {
                    // call _parseSize AFTER applying pane classes & styles - but before making visible (if hidden)
                    // if o.size is auto or not valid, then MEASURE the pane and use that as its 'size'
                    size	= s.size = _parseSize(pane, o.size);
                    minSize	= _parseSize(pane,o.minSize) || 1;
                    maxSize	= _parseSize(pane,o.maxSize) || 100000;
                    if (size > 0) size = max(min(size, maxSize), minSize);

                    // state for border-panes
                    s.isClosed  = false; // true = pane is closed
                    s.isSliding = false; // true = pane is currently open by 'sliding' over adjacent panes
                    s.isResizing= false; // true = pane is in process of being resized
                    s.isHidden	= false; // true = pane is hidden - no spacing, resizer or toggler is visible!

                    // array for 'pin buttons' whose classNames are auto-updated on pane-open/-close
                    if (!s.pins) s.pins = [];
                }
                //	states common to ALL panes
                s.tagName	= $P[0].tagName;
                s.edge		= pane;		// useful if pane is (or about to be) 'swapped' - easy find out where it is (or is going)
                s.noRoom	= false;	// true = pane 'automatically' hidden due to insufficient room - will unhide automatically
                s.isVisible	= true;		// false = pane is invisible - closed OR hidden - simplify logic

                // set css-position to account for container borders & padding
                switch (pane) {
                    case "north": 	CSS.top 	= sC.insetTop;
                        CSS.left 	= sC.insetLeft;
                        CSS.right	= sC.insetRight;
                        break;
                    case "south": 	CSS.bottom	= sC.insetBottom;
                        CSS.left 	= sC.insetLeft;
                        CSS.right 	= sC.insetRight;
                        break;
                    case "west": 	CSS.left 	= sC.insetLeft; // top, bottom & height set by sizeMidPanes()
                        break;
                    case "east": 	CSS.right 	= sC.insetRight; // ditto
                        break;
                    case "center":	// top, left, width & height set by sizeMidPanes()
                }

                if (dir === "horz") // north or south pane
                    CSS.height = cssH($P, size);
                else if (dir === "vert") // east or west pane
                    CSS.width = cssW($P, size);
                //else if (isCenter) {}

                $P.css(CSS); // apply size -- top, bottom & height will be set by sizeMidPanes
                if (dir != "horz") sizeMidPanes(pane, true); // true = skipCallback

                // close or hide the pane if specified in settings
                if (o.initClosed && o.closable && !o.initHidden)
                    close(pane, true, true); // true, true = force, noAnimation
                else if (o.initHidden || o.initClosed)
                    hide(pane); // will be completely invisible - no resizer or spacing
                else if (!s.noRoom)
                // make the pane visible - in case was initially hidden
                    $P.css("display","block");
                // ELSE setAsOpen() - called later by initHandles()

                // RESET visibility now - pane will appear IF display:block
                $P.css("visibility","visible");

                // check option for auto-handling of pop-ups & drop-downs
                if (o.showOverflowOnHover)
                    $P.hover( allowOverflow, resetOverflow );

                // if manually adding a pane AFTER layout initialization, then...
                if (state.initialized) {
                    initHandles( pane );
                    initHotkeys( pane );
                    resizeAll(); // will sizeContent if pane is visible
                    if (s.isVisible) { // pane is OPEN
                        if (o.triggerEventsOnLoad)
                            _runCallbacks("onresize_end", pane);
                        else // automatic if onresize called, otherwise call it specifically
                        // resize child - IF inner-layout already exists (created before this layout)
                            resizeChildLayout(pane); // a previously existing childLayout
                    }
                    if (o.initChildLayout && o.childOptions)
                        createChildLayout(pane);
                }
            }

        /**
         * Initialize module objects, styling, size and position for all resize bars and toggler buttons
         *
         * @see  _create()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
            ,	initHandles = function (panes) {
                panes = panes ? panes.split(",") : _c.borderPanes;

                // create toggler DIVs for each pane, and set object pointers for them, eg: $R.north = north toggler DIV
                $.each(panes, function (i, pane) {
                    var $P		= $Ps[pane];
                    $Rs[pane]	= false; // INIT
                    $Ts[pane]	= false;
                    if (!$P) return; // pane does not exist - skip

                    var
                        o		= options[pane]
                        ,	s		= state[pane]
                        ,	c		= _c[pane]
                        ,	paneId	= o.paneSelector.substr(0,1) === "#" ? o.paneSelector.substr(1) : ""
                        ,	rClass	= o.resizerClass
                        ,	tClass	= o.togglerClass
                        ,	side	= c.side.toLowerCase()
                        ,	spacing	= (s.isVisible ? o.spacing_open : o.spacing_closed)
                        ,	_pane	= "-"+ pane // used for classNames
                        ,	_state	= (s.isVisible ? "-open" : "-closed") // used for classNames
                        ,	I		= Instance[pane]
                    // INIT RESIZER BAR
                        ,	$R		= I.resizer = $Rs[pane] = $("<div></div>")
                    // INIT TOGGLER BUTTON
                        ,	$T		= I.toggler = (o.closable ? $Ts[pane] = $("<div></div>") : false)
                        ;

                    //if (s.isVisible && o.resizable) ... handled by initResizable
                    if (!s.isVisible && o.slidable)
                        $R.attr("title", o.tips.Slide).css("cursor", o.sliderCursor);

                    $R	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "paneLeft-resizer"
                        .attr("id", paneId ? paneId +"-resizer" : "" )
                        .data({
                            parentLayout:	Instance
                            ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
                            ,	layoutEdge:		pane
                            ,	layoutRole:		"resizer"
                        })
                        .css(_c.resizers.cssReq).css("zIndex", options.zIndexes.resizer_normal)
                        .css(o.applyDemoStyles ? _c.resizers.cssDemo : {}) // add demo styles
                        .addClass(rClass +" "+ rClass+_pane)
                        .hover(addHover, removeHover) // ALWAYS add hover-classes, even if resizing is not enabled - handle with CSS instead
                        .hover(onResizerEnter, onResizerLeave) // ALWAYS NEED resizer.mouseleave to balance toggler.mouseenter
                        .appendTo($N) // append DIV to container
                    ;

                    if ($T) {
                        $T	// if paneSelector is an ID, then create a matching ID for the resizer, eg: "#paneLeft" => "#paneLeft-toggler"
                            .attr("id", paneId ? paneId +"-toggler" : "" )
                            .data({
                                parentLayout:	Instance
                                ,	layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
                                ,	layoutEdge:		pane
                                ,	layoutRole:		"toggler"
                            })
                            .css(_c.togglers.cssReq) // add base/required styles
                            .css(o.applyDemoStyles ? _c.togglers.cssDemo : {}) // add demo styles
                            .addClass(tClass +" "+ tClass+_pane)
                            .hover(addHover, removeHover) // ALWAYS add hover-classes, even if toggling is not enabled - handle with CSS instead
                            .bind("mouseenter", onResizerEnter) // NEED toggler.mouseenter because mouseenter MAY NOT fire on resizer
                            .appendTo($R) // append SPAN to resizer DIV
                        ;
                        // ADD INNER-SPANS TO TOGGLER
                        if (o.togglerContent_open) // ui-layout-open
                            $("<span>"+ o.togglerContent_open +"</span>")
                                .data({
                                    layoutEdge:		pane
                                    ,	layoutRole:		"togglerContent"
                                })
                                .data("layoutRole", "togglerContent")
                                .data("layoutEdge", pane)
                                .addClass("content content-open")
                                .css("display","none")
                                .appendTo( $T )
                                //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-open instead!
                            ;
                        if (o.togglerContent_closed) // ui-layout-closed
                            $("<span>"+ o.togglerContent_closed +"</span>")
                                .data({
                                    layoutEdge:		pane
                                    ,	layoutRole:		"togglerContent"
                                })
                                .addClass("content content-closed")
                                .css("display","none")
                                .appendTo( $T )
                                //.hover( addHover, removeHover ) // use ui-layout-toggler-west-hover .content-closed instead!
                            ;
                        // ADD TOGGLER.click/.hover
                        enableClosable(pane);
                    }

                    // add Draggable events
                    initResizable(pane);

                    // ADD CLASSNAMES & SLIDE-BINDINGS - eg: class="resizer resizer-west resizer-open"
                    if (s.isVisible)
                        setAsOpen(pane);	// onOpen will be called, but NOT onResize
                    else {
                        setAsClosed(pane);	// onClose will be called
                        bindStartSlidingEvent(pane, true); // will enable events IF option is set
                    }

                });

                // SET ALL HANDLE DIMENSIONS
                sizeHandles();
            }


        /**
         * Initialize scrolling ui-layout-content div - if exists
         *
         * @see  initPane() - or externally after an Ajax injection
         * @param {string}	[pane]			The pane to process
         * @param {boolean=}	[resize=true]	Size content after init
         */
            ,	initContent = function (pane, resize) {
                if (!isInitialized()) return;
                var
                    o	= options[pane]
                    ,	sel	= o.contentSelector
                    ,	I	= Instance[pane]
                    ,	$P	= $Ps[pane]
                    ,	$C
                    ;
                if (sel) $C = I.content = $Cs[pane] = (o.findNestedContent)
                    ? $P.find(sel).eq(0) // match 1-element only
                    : $P.children(sel).eq(0)
                ;
                if ($C && $C.length) {
                    $C.data("layoutRole", "content");
                    // SAVE original Pane CSS
                    if (!$C.data("layoutCSS"))
                        $C.data("layoutCSS", elCSS($C, "height"));
                    $C.css( _c.content.cssReq );
                    if (o.applyDemoStyles) {
                        $C.css( _c.content.cssDemo ); // add padding & overflow: auto to content-div
                        $P.css( _c.content.cssDemoPane ); // REMOVE padding/scrolling from pane
                    }
                    state[pane].content = {}; // init content state
                    if (resize !== false) sizeContent(pane);
                    // sizeContent() is called AFTER init of all elements
                }
                else
                    I.content = $Cs[pane] = false;
            }


        /**
         * Add resize-bars to all panes that specify it in options
         * -dependancy: $.fn.resizable - will skip if not found
         *
         * @see  _create()
         * @param {string=}	[panes=""]	The edge(s) to process
         */
            ,	initResizable = function (panes) {
                var	draggingAvailable = $.layout.plugins.draggable
                    ,	side // set in start()
                    ;
                panes = panes ? panes.split(",") : _c.borderPanes;

                $.each(panes, function (idx, pane) {
                    var o = options[pane];
                    if (!draggingAvailable || !$Ps[pane] || !o.resizable) {
                        o.resizable = false;
                        return true; // skip to next
                    }

                    var s		= state[pane]
                        ,	z		= options.zIndexes
                        ,	c		= _c[pane]
                        ,	side	= c.dir=="horz" ? "top" : "left"
                        ,	opEdge	= _c.oppositeEdge[pane]
                        ,	masks	=  pane +",center,"+ opEdge + (c.dir=="horz" ? ",west,east" : "")
                        ,	$P 		= $Ps[pane]
                        ,	$R		= $Rs[pane]
                        ,	base	= o.resizerClass
                        ,	lastPos	= 0 // used when live-resizing
                        ,	r, live // set in start because may change
                    //	'drag' classes are applied to the ORIGINAL resizer-bar while dragging is in process
                        ,	resizerClass		= base+"-drag"				// resizer-drag
                        ,	resizerPaneClass	= base+"-"+pane+"-drag"		// resizer-north-drag
                    //	'helper' class is applied to the CLONED resizer-bar while it is being dragged
                        ,	helperClass			= base+"-dragging"			// resizer-dragging
                        ,	helperPaneClass		= base+"-"+pane+"-dragging" // resizer-north-dragging
                        ,	helperLimitClass	= base+"-dragging-limit"	// resizer-drag
                        ,	helperPaneLimitClass = base+"-"+pane+"-dragging-limit"	// resizer-north-drag
                        ,	helperClassesSet	= false 					// logic var
                        ;

                    if (!s.isClosed)
                        $R.attr("title", o.tips.Resize)
                            .css("cursor", o.resizerCursor); // n-resize, s-resize, etc

                    $R.draggable({
                        containment:	$N[0] // limit resizing to layout container
                        ,	axis:			(c.dir=="horz" ? "y" : "x") // limit resizing to horz or vert axis
                        ,	delay:			0
                        ,	distance:		1
                        ,	grid:			o.resizingGrid
                        //	basic format for helper - style it using class: .ui-draggable-dragging
                        ,	helper:			"clone"
                        ,	opacity:		o.resizerDragOpacity
                        ,	addClasses:		false // avoid ui-state-disabled class when disabled
                        //,	iframeFix:		o.draggableIframeFix // TODO: consider using when bug is fixed
                        ,	zIndex:			z.resizer_drag

                        ,	start: function (e, ui) {
                            // REFRESH options & state pointers in case we used swapPanes
                            o = options[pane];
                            s = state[pane];
                            // re-read options
                            live = o.livePaneResizing;

                            // ondrag_start callback - will CANCEL hide if returns false
                            // TODO: dragging CANNOT be cancelled like this, so see if there is a way?
                            if (false === _runCallbacks("ondrag_start", pane)) return false;

                            s.isResizing	= true; // prevent pane from closing while resizing
                            timer.clear(pane+"_closeSlider"); // just in case already triggered

                            // SET RESIZER LIMITS - used in drag()
                            setSizeLimits(pane); // update pane/resizer state
                            r = s.resizerPosition;
                            lastPos = ui.position[ side ]

                            $R.addClass( resizerClass +" "+ resizerPaneClass ); // add drag classes
                            helperClassesSet = false; // reset logic var - see drag()

                            // DISABLE TEXT SELECTION (probably already done by resizer.mouseOver)
                            $('body').disableSelection();

                            // MASK PANES CONTAINING IFRAMES, APPLETS OR OTHER TROUBLESOME ELEMENTS
                            showMasks( masks );
                        }

                        ,	drag: function (e, ui) {
                            if (!helperClassesSet) { // can only add classes after clone has been added to the DOM
                                //$(".ui-draggable-dragging")
                                ui.helper
                                    .addClass( helperClass +" "+ helperPaneClass ) // add helper classes
                                    .css({ right: "auto", bottom: "auto" })	// fix dir="rtl" issue
                                    .children().css("visibility","hidden")	// hide toggler inside dragged resizer-bar
                                ;
                                helperClassesSet = true;
                                // draggable bug!? RE-SET zIndex to prevent E/W resize-bar showing through N/S pane!
                                if (s.isSliding) $Ps[pane].css("zIndex", z.pane_sliding);
                            }
                            // CONTAIN RESIZER-BAR TO RESIZING LIMITS
                            var limit = 0;
                            if (ui.position[side] < r.min) {
                                ui.position[side] = r.min;
                                limit = -1;
                            }
                            else if (ui.position[side] > r.max) {
                                ui.position[side] = r.max;
                                limit = 1;
                            }
                            // ADD/REMOVE dragging-limit CLASS
                            if (limit) {
                                ui.helper.addClass( helperLimitClass +" "+ helperPaneLimitClass ); // at dragging-limit
                                window.defaultStatus = (limit>0 && pane.match(/(north|west)/)) || (limit<0 && pane.match(/(south|east)/)) ? o.tips.maxSizeWarning : o.tips.minSizeWarning;
                            }
                            else {
                                ui.helper.removeClass( helperLimitClass +" "+ helperPaneLimitClass ); // not at dragging-limit
                                window.defaultStatus = "";
                            }
                            // DYNAMICALLY RESIZE PANES IF OPTION ENABLED
                            // won't trigger unless resizer has actually moved!
                            if (live && Math.abs(ui.position[side] - lastPos) >= o.liveResizingTolerance) {
                                lastPos = ui.position[side];
                                resizePanes(e, ui, pane)
                            }
                        }

                        ,	stop: function (e, ui) {
                            $('body').enableSelection(); // RE-ENABLE TEXT SELECTION
                            window.defaultStatus = ""; // clear 'resizing limit' message from statusbar
                            $R.removeClass( resizerClass +" "+ resizerPaneClass ); // remove drag classes from Resizer
                            s.isResizing = false;
                            resizePanes(e, ui, pane, true, masks); // true = resizingDone
                        }

                    });
                });

                /**
                 * resizePanes
                 *
                 * Sub-routine called from stop() - and drag() if livePaneResizing
                 *
                 * @param {!Object}		evt
                 * @param {!Object}		ui
                 * @param {string}		pane
                 * @param {boolean=}		[resizingDone=false]
                 */
                var resizePanes = function (evt, ui, pane, resizingDone, masks) {
                    var	dragPos	= ui.position
                        ,	c		= _c[pane]
                        ,	o		= options[pane]
                        ,	s		= state[pane]
                        ,	resizerPos
                        ;
                    switch (pane) {
                        case "north":	resizerPos = dragPos.top; break;
                        case "west":	resizerPos = dragPos.left; break;
                        case "south":	resizerPos = sC.offsetHeight - dragPos.top  - o.spacing_open; break;
                        case "east":	resizerPos = sC.offsetWidth  - dragPos.left - o.spacing_open; break;
                    };
                    // remove container margin from resizer position to get the pane size
                    var newSize = resizerPos - sC["inset"+ c.side];

                    // Disable OR Resize Mask(s) created in drag.start
                    if (!resizingDone) {
                        // ensure we meet liveResizingTolerance criteria
                        if (Math.abs(newSize - s.size) < o.liveResizingTolerance)
                            return; // SKIP resize this time
                        // resize the pane
                        manualSizePane(pane, newSize, false, true); // true = noAnimation
                        sizeMasks(); // resize all visible masks
                    }
                    else { // resizingDone
                        // ondrag_end callback
                        if (false !== _runCallbacks("ondrag_end", pane))
                            manualSizePane(pane, newSize, false, true); // true = noAnimation
                        hideMasks(); // hide all masks, which include panes with 'content/iframe-masks'
                        if (s.isSliding && masks) // RE-SHOW only 'object-masks' so objects won't show through sliding pane
                            showMasks( masks, true ); // true = onlyForObjects
                    }
                };
            }

        /**
         *	sizeMask
         *
         *	Needed to overlay a DIV over an IFRAME-pane because mask CANNOT be *inside* the pane
         *	Called when mask created, and during livePaneResizing
         */
            ,	sizeMask = function () {
                var $M		= $(this)
                    ,	pane	= $M.data("layoutMask") // eg: "west"
                    ,	s		= state[pane]
                    ;
                // only masks over an IFRAME-pane need manual resizing
                if (s.tagName == "IFRAME" && s.isVisible) // no need to mask closed/hidden panes
                    $M.css({
                        top:	s.offsetTop
                        ,	left:	s.offsetLeft
                        ,	width:	s.outerWidth
                        ,	height:	s.outerHeight
                    });
                /* ALT Method...
                 var $P = $Ps[pane];
                 $M.css( $P.position() ).css({ width: $P[0].offsetWidth, height: $P[0].offsetHeight });
                 */
            }
            ,	sizeMasks = function () {
                $Ms.each( sizeMask ); // resize all 'visible' masks
            }

            ,	showMasks = function (panes, onlyForObjects) {
                var a	= panes ? panes.split(",") : $.layout.config.allPanes
                    ,	z	= options.zIndexes
                    ,	o, s;
                $.each(a, function(i,p){
                    s = state[p];
                    o = options[p];
                    if (s.isVisible && ( (!onlyForObjects && o.maskContents) || o.maskObjects )) {
                        getMasks(p).each(function(){
                            sizeMask.call(this);
                            this.style.zIndex = s.isSliding ? z.pane_sliding+1 : z.pane_normal+1
                            this.style.display = "block";
                        });
                    }
                });
            }

            ,	hideMasks = function () {
                // ensure no pane is resizing - could be a timing issue
                var skip;
                $.each( $.layout.config.borderPanes, function(i,p){
                    if (state[p].isResizing) {
                        skip = true;
                        return false; // BREAK
                    }
                });
                if (!skip)
                    $Ms.hide(); // hide ALL masks
            }

            ,	getMasks = function (pane) {
                var $Masks	= $([])
                    ,	$M, i = 0, c = $Ms.length
                    ;
                for (; i<c; i++) {
                    $M = $Ms.eq(i);
                    if ($M.data("layoutMask") === pane)
                        $Masks = $Masks.add( $M );
                }
                if ($Masks.length)
                    return $Masks;
                else
                    return createMasks(pane);
            }

        /**
         *	createMasks
         *
         *	Generates both DIV (ALWAYS used) and IFRAME (optional) elements as masks
         *	An IFRAME mask is created *under* the DIV when maskObjects=true, because a DIV cannot mask an applet
         */
            ,	createMasks = function (pane) {
                var
                    $P		= $Ps[pane]
                    ,	s		= state[pane]
                    ,	o		= options[pane]
                    ,	z		= options.zIndexes
                //,	objMask	= o.maskObjects && s.tagName != "IFRAME" // check for option
                    ,	$Masks	= $([])
                    ,	isIframe, el, $M, css, i
                    ;
                if (!o.maskContents && !o.maskObjects) return $Masks;
                // if o.maskObjects=true, then loop TWICE to create BOTH kinds of mask, else only create a DIV
                for (i=0; i < (o.maskObjects ? 2 : 1); i++) {
                    isIframe = o.maskObjects && i==0;
                    el = document.createElement( isIframe ? "iframe" : "div" );
                    $M = $(el).data("layoutMask", pane); // add data to relate mask to pane
                    el.className = "ui-layout-mask ui-layout-mask-"+ pane; // for user styling
                    css = el.style;
                    // styles common to both DIVs and IFRAMES
                    css.display		= "block";
                    css.position	= "absolute";
                    if (isIframe) { // IFRAME-only props
                        el.frameborder = 0;
                        el.src		= "about:blank";
                        css.opacity	= 0;
                        css.filter	= "Alpha(Opacity='0')";
                        css.border	= 0;
                    }
                    // if pane is an IFRAME, then must mask the pane itself
                    if (s.tagName == "IFRAME") {
                        // NOTE sizing done by a subroutine so can be called during live-resizing
                        css.zIndex	= z.pane_normal+1; // 1-higher than pane
                        $N.append( el ); // append to LAYOUT CONTAINER
                    }
                    // otherwise put masks *inside the pane* to mask its contents
                    else {
                        $M.addClass("ui-layout-mask-inside-pane");
                        css.zIndex	= o.maskZindex || z.content_mask; // usually 1, but customizable
                        css.top		= 0;
                        css.left	= 0;
                        css.width	= "100%";
                        css.height	= "100%";
                        $P.append( el ); // append INSIDE pane element
                    }
                    // add to return object
                    $Masks = $Masks.add( el );
                    // add Mask to cached array so can be resized & reused
                    $Ms = $Ms.add( el );
                }
                return $Masks;
            }


        /**
         * Destroy this layout and reset all elements
         *
         * @param {boolean=}	[destroyChildren=false]		Destory Child-Layouts first?
         */
            ,	destroy = function (evt_or_destroyChildren, destroyChildren) {
                // UNBIND layout events and remove global object
                $(window).unbind("."+ sID);		// resize & unload
                $(document).unbind("."+ sID);	// keyDown (hotkeys)

                if (typeof evt_or_destroyChildren === "object")
                // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
                    evtPane(evt_or_destroyChildren);
                else // no event, so transfer 1st param to destroyChildren param
                    destroyChildren = evt_or_destroyChildren;

                // need to look for parent layout BEFORE we remove the container data, else skips a level
                //var parentPane = Instance.hasParentLayout ? $.layout.getParentPaneInstance( $N ) : null;

                // reset layout-container
                $N	.clearQueue()
                    .removeData("layout")
                    .removeData("layoutContainer")
                    .removeClass(options.containerClass)
                    .unbind("."+ sID) // remove ALL Layout events
                ;

                // remove all mask elements that have been created
                $Ms.remove();

                // loop all panes to remove layout classes, attributes and bindings
                $.each(_c.allPanes, function (i, pane) {
                    removePane( pane, false, true, destroyChildren ); // true = skipResize
                });

                // do NOT reset container CSS if is a 'pane' (or 'content') in an outer-layout - ie, THIS layout is 'nested'
                var css = "layoutCSS";
                if ($N.data(css) && !$N.data("layoutRole")) // RESET CSS
                    $N.css( $N.data(css) ).removeData(css);

                // for full-page layouts, also reset the <HTML> CSS
                if (sC.tagName === "BODY" && ($N = $("html")).data(css)) // RESET <HTML> CSS
                    $N.css( $N.data(css) ).removeData(css);

                // trigger plugins for this layout, if there are any
                runPluginCallbacks( Instance, $.layout.onDestroy );

                // trigger state-management and onunload callback
                unload();

                // clear the Instance of everything except for container & options (so could recreate)
                // RE-CREATE: myLayout = myLayout.container.layout( myLayout.options );
                for (n in Instance)
                    if (!n.match(/^(container|options)$/)) delete Instance[ n ];
                // add a 'destroyed' flag to make it easy to check
                Instance.destroyed = true;

                // if this is a child layout, CLEAR the child-pointer in the parent
                /* for now the pointer REMAINS, but with only container, options and destroyed keys
                 if (parentPane) {
                 var layout = parentPane.pane.data("parentLayout");
                 parentPane.child = layout.children[ parentPane.name ] = null;
                 }
                 */

                return Instance; // for coding convenience
            }

        /**
         * Remove a pane from the layout - subroutine of destroy()
         *
         * @see  destroy()
         * @param {string|Object}	evt_or_pane			The pane to process
         * @param {boolean=}			[remove=false]		Remove the DOM element?
         * @param {boolean=}			[skipResize=false]	Skip calling resizeAll()?
         * @param {boolean=}			[destroyChild=true]	Destroy Child-layouts? If not passed, obeys options setting
         */
            ,	removePane = function (evt_or_pane, remove, skipResize, destroyChild) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$P	= $Ps[pane]
                    ,	$C	= $Cs[pane]
                    ,	$R	= $Rs[pane]
                    ,	$T	= $Ts[pane]
                    ;
                // NOTE: elements can still exist even after remove()
                //		so check for missing data(), which is cleared by removed()
                if ($P && $.isEmptyObject( $P.data() )) $P = false;
                if ($C && $.isEmptyObject( $C.data() )) $C = false;
                if ($R && $.isEmptyObject( $R.data() )) $R = false;
                if ($T && $.isEmptyObject( $T.data() )) $T = false;

                if ($P) $P.stop(true, true);

                //	check for a child layout
                var	o	= options[pane]
                    ,	s	= state[pane]
                    ,	d	= "layout"
                    ,	css	= "layoutCSS"
                    ,	child	= children[pane] || ($P ? $P.data(d) : 0) || ($C ? $C.data(d) : 0) || null
                    ,	destroy	= destroyChild !== undefined ? destroyChild : o.destroyChildLayout
                    ;

                // FIRST destroy the child-layout(s)
                if (destroy && child && !child.destroyed) {
                    child.destroy(true);	// tell child-layout to destroy ALL its child-layouts too
                    if (child.destroyed)	// destroy was successful
                        child = null;		// clear pointer for logic below 
                }

                if ($P && remove && !child)
                    $P.remove();
                else if ($P && $P[0]) {
                    //	create list of ALL pane-classes that need to be removed
                    var	root	= o.paneClass // default="ui-layout-pane"
                        ,	pRoot	= root +"-"+ pane // eg: "ui-layout-pane-west"
                        ,	_open	= "-open"
                        ,	_sliding= "-sliding"
                        ,	_closed	= "-closed"
                        ,	classes	= [	root, root+_open, root+_closed, root+_sliding,		// generic classes
                            pRoot, pRoot+_open, pRoot+_closed, pRoot+_sliding ]	// pane-specific classes
                        ;
                    $.merge(classes, getHoverClasses($P, true)); // ADD hover-classes
                    // remove all Layout classes from pane-element
                    $P	.removeClass( classes.join(" ") ) // remove ALL pane-classes
                        .removeData("parentLayout")
                        .removeData("layoutPane")
                        .removeData("layoutRole")
                        .removeData("layoutEdge")
                        .removeData("autoHidden")	// in case set
                        .unbind("."+ sID) // remove ALL Layout events
                        // TODO: remove these extra unbind commands when jQuery is fixed
                        //.unbind("mouseenter"+ sID)
                        //.unbind("mouseleave"+ sID)
                    ;
                    // do NOT reset CSS if this pane/content is STILL the container of a nested layout!
                    // the nested layout will reset its 'container' CSS when/if it is destroyed
                    if ($C && $C.data(d)) {
                        // a content-div may not have a specific width, so give it one to contain the Layout
                        $C.width( $C.width() );
                        child.resizeAll(); // now resize the Layout
                    }
                    else if ($C)
                        $C.css( $C.data(css) ).removeData(css).removeData("layoutRole");
                    // remove pane AFTER content in case there was a nested layout
                    if (!$P.data(d))
                        $P.css( $P.data(css) ).removeData(css);
                }

                // REMOVE pane resizer and toggler elements
                if ($T) $T.remove();
                if ($R) $R.remove();

                // CLEAR all pointers and state data
                Instance[pane] = $Ps[pane] = $Cs[pane] = $Rs[pane] = $Ts[pane] = children[pane] = false;
                s = { removed: true };

                if (!skipResize)
                    resizeAll();
            }


        /*
         * ###########################
         *	   ACTION METHODS
         * ###########################
         */

            ,	_hidePane = function (pane) {
                var $P	= $Ps[pane]
                    ,	o	= options[pane]
                    ,	s	= $P[0].style
                    ;
                if (o.useOffscreenClose) {
                    if (!$P.data(_c.offscreenReset))
                        $P.data(_c.offscreenReset, { left: s.left, right: s.right });
                    $P.css( _c.offscreenCSS );
                }
                else
                    $P.hide().removeData(_c.offscreenReset);
            }

            ,	_showPane = function (pane) {
                var $P	= $Ps[pane]
                    ,	o	= options[pane]
                    ,	off	= _c.offscreenCSS
                    ,	old	= $P.data(_c.offscreenReset)
                    ,	s	= $P[0].style
                    ;
                $P	.show() // ALWAYS show, just in case
                    .removeData(_c.offscreenReset);
                if (o.useOffscreenClose && old) {
                    if (s.left == off.left)
                        s.left = old.left;
                    if (s.right == off.right)
                        s.right = old.right;
                }
            }


        /**
         * Completely 'hides' a pane, including its spacing - as if it does not exist
         * The pane is not actually 'removed' from the source, so can use 'show' to un-hide it
         *
         * @param {string|Object}	evt_or_pane			The pane being hidden, ie: north, south, east, or west
         * @param {boolean=}			[noAnimation=false]
         */
            ,	hide = function (evt_or_pane, noAnimation) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                    ,	$P	= $Ps[pane]
                    ,	$R	= $Rs[pane]
                    ;
                if (!$P || s.isHidden) return; // pane does not exist OR is already hidden

                // onhide_start callback - will CANCEL hide if returns false
                if (state.initialized && false === _runCallbacks("onhide_start", pane)) return;

                s.isSliding = false; // just in case

                // now hide the elements
                if ($R) $R.hide(); // hide resizer-bar
                if (!state.initialized || s.isClosed) {
                    s.isClosed = true; // to trigger open-animation on show()
                    s.isHidden  = true;
                    s.isVisible = false;
                    if (!state.initialized)
                        _hidePane(pane); // no animation when loading page
                    sizeMidPanes(_c[pane].dir === "horz" ? "" : "center");
                    if (state.initialized || o.triggerEventsOnLoad)
                        _runCallbacks("onhide_end", pane);
                }
                else {
                    s.isHiding = true; // used by onclose
                    close(pane, false, noAnimation); // adjust all panes to fit
                }
            }

        /**
         * Show a hidden pane - show as 'closed' by default unless openPane = true
         *
         * @param {string|Object}	evt_or_pane			The pane being opened, ie: north, south, east, or west
         * @param {boolean=}			[openPane=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[noAlert=false]
         */
            ,	show = function (evt_or_pane, openPane, noAnimation, noAlert) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                    ,	$P	= $Ps[pane]
                    ,	$R	= $Rs[pane]
                    ;
                if (!$P || !s.isHidden) return; // pane does not exist OR is not hidden

                // onshow_start callback - will CANCEL show if returns false
                if (false === _runCallbacks("onshow_start", pane)) return;

                s.isSliding = false; // just in case
                s.isShowing = true; // used by onopen/onclose
                //s.isHidden  = false; - will be set by open/close - if not cancelled

                // now show the elements
                //if ($R) $R.show(); - will be shown by open/close
                if (openPane === false)
                    close(pane, true); // true = force
                else
                    open(pane, false, noAnimation, noAlert); // adjust all panes to fit
            }


        /**
         * Toggles a pane open/closed by calling either open or close
         *
         * @param {string|Object}	evt_or_pane		The pane being toggled, ie: north, south, east, or west
         * @param {boolean=}			[slide=false]
         */
            ,	toggle = function (evt_or_pane, slide) {
                if (!isInitialized()) return;
                var	evt		= evtObj(evt_or_pane)
                    ,	pane	= evtPane.call(this, evt_or_pane)
                    ,	s		= state[pane]
                    ;
                if (evt) // called from to $R.dblclick OR triggerPaneEvent
                    evt.stopImmediatePropagation();
                if (s.isHidden)
                    show(pane); // will call 'open' after unhiding it
                else if (s.isClosed)
                    open(pane, !!slide);
                else
                    close(pane);
            }


        /**
         * Utility method used during init or other auto-processes
         *
         * @param {string}	pane   The pane being closed
         * @param {boolean=}	[setHandles=false]
         */
            ,	_closePane = function (pane, setHandles) {
                var
                    $P	= $Ps[pane]
                    ,	s	= state[pane]
                    ;
                _hidePane(pane);
                s.isClosed = true;
                s.isVisible = false;
                // UNUSED: if (setHandles) setAsClosed(pane, true); // true = force
            }

        /**
         * Close the specified pane (animation optional), and resize all other panes as needed
         *
         * @param {string|Object}	evt_or_pane			The pane being closed, ie: north, south, east, or west
         * @param {boolean=}			[force=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[skipCallback=false]
         */
            ,	close = function (evt_or_pane, force, noAnimation, skipCallback) {
                var	pane = evtPane.call(this, evt_or_pane);
                // if pane has been initialized, but NOT the complete layout, close pane instantly
                if (!state.initialized && $Ps[pane]) {
                    _closePane(pane); // INIT pane as closed
                    return;
                }
                if (!isInitialized()) return;

                var
                    $P	= $Ps[pane]
                    ,	$R	= $Rs[pane]
                    ,	$T	= $Ts[pane]
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                    ,	c	= _c[pane]
                    ,	doFX, isShowing, isHiding, wasSliding;

                // QUEUE in case another action/animation is in progress
                $N.queue(function( queueNext ){

                    if ( !$P
                        ||	(!o.closable && !s.isShowing && !s.isHiding)	// invalid request // (!o.resizable && !o.closable) ???
                        ||	(!force && s.isClosed && !s.isShowing)			// already closed
                        ) return queueNext();

                    // onclose_start callback - will CANCEL hide if returns false
                    // SKIP if just 'showing' a hidden pane as 'closed'
                    var abort = !s.isShowing && false === _runCallbacks("onclose_start", pane);

                    // transfer logic vars to temp vars
                    isShowing	= s.isShowing;
                    isHiding	= s.isHiding;
                    wasSliding	= s.isSliding;
                    // now clear the logic vars (REQUIRED before aborting)
                    delete s.isShowing;
                    delete s.isHiding;

                    if (abort) return queueNext();

                    doFX		= !noAnimation && !s.isClosed && (o.fxName_close != "none");
                    s.isMoving	= true;
                    s.isClosed	= true;
                    s.isVisible	= false;
                    // update isHidden BEFORE sizing panes
                    if (isHiding) s.isHidden = true;
                    else if (isShowing) s.isHidden = false;

                    if (s.isSliding) // pane is being closed, so UNBIND trigger events
                        bindStopSlidingEvents(pane, false); // will set isSliding=false
                    else // resize panes adjacent to this one
                        sizeMidPanes(_c[pane].dir === "horz" ? "" : "center", false); // false = NOT skipCallback

                    // if this pane has a resizer bar, move it NOW - before animation
                    setAsClosed(pane);

                    // CLOSE THE PANE
                    if (doFX) { // animate the close
                        // mask panes with objects
                        var masks = "center"+ (c.dir=="horz" ? ",west,east" : "");
                        showMasks( masks, true );	// true = ONLY mask panes with maskObjects=true
                        lockPaneForFX(pane, true);	// need to set left/top so animation will work
                        $P.hide( o.fxName_close, o.fxSettings_close, o.fxSpeed_close, function () {
                            lockPaneForFX(pane, false); // undo
                            if (s.isClosed) close_2();
                            queueNext();
                        });
                    }
                    else { // hide the pane without animation
                        _hidePane(pane);
                        close_2();
                        queueNext();
                    };
                });

                // SUBROUTINE
                function close_2 () {
                    s.isMoving	= false;
                    bindStartSlidingEvent(pane, true); // will enable if o.slidable = true

                    // if opposite-pane was autoClosed, see if it can be autoOpened now
                    var altPane = _c.oppositeEdge[pane];
                    if (state[ altPane ].noRoom) {
                        setSizeLimits( altPane );
                        makePaneFit( altPane );
                    }

                    // hide any masks shown while closing
                    hideMasks();

                    if (!skipCallback && (state.initialized || o.triggerEventsOnLoad)) {
                        // onclose callback - UNLESS just 'showing' a hidden pane as 'closed'
                        if (!isShowing)	_runCallbacks("onclose_end", pane);
                        // onhide OR onshow callback
                        if (isShowing)	_runCallbacks("onshow_end", pane);
                        if (isHiding)	_runCallbacks("onhide_end", pane);
                    }
                }
            }

        /**
         * @param {string}	pane	The pane just closed, ie: north, south, east, or west
         */
            ,	setAsClosed = function (pane) {
                var
                    $P		= $Ps[pane]
                    ,	$R		= $Rs[pane]
                    ,	$T		= $Ts[pane]
                    ,	o		= options[pane]
                    ,	s		= state[pane]
                    ,	side	= _c[pane].side.toLowerCase()
                    ,	inset	= "inset"+ _c[pane].side
                    ,	rClass	= o.resizerClass
                    ,	tClass	= o.togglerClass
                    ,	_pane	= "-"+ pane // used for classNames
                    ,	_open	= "-open"
                    ,	_sliding= "-sliding"
                    ,	_closed	= "-closed"
                    ;
                $R
                    .css(side, sC[inset]) // move the resizer
                    .removeClass( rClass+_open +" "+ rClass+_pane+_open )
                    .removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
                    .addClass( rClass+_closed +" "+ rClass+_pane+_closed )
                    .unbind("dblclick."+ sID)
                ;
                // DISABLE 'resizing' when closed - do this BEFORE bindStartSlidingEvent?
                if (o.resizable && $.layout.plugins.draggable)
                    $R
                        .draggable("disable")
                        .removeClass("ui-state-disabled") // do NOT apply disabled styling - not suitable here
                        .css("cursor", "default")
                        .attr("title","")
                    ;

                // if pane has a toggler button, adjust that too
                if ($T) {
                    $T
                        .removeClass( tClass+_open +" "+ tClass+_pane+_open )
                        .addClass( tClass+_closed +" "+ tClass+_pane+_closed )
                        .attr("title", o.tips.Open) // may be blank
                    ;
                    // toggler-content - if exists
                    $T.children(".content-open").hide();
                    $T.children(".content-closed").css("display","block");
                }

                // sync any 'pin buttons'
                syncPinBtns(pane, false);

                if (state.initialized) {
                    // resize 'length' and position togglers for adjacent panes
                    sizeHandles();
                }
            }

        /**
         * Open the specified pane (animation optional), and resize all other panes as needed
         *
         * @param {string|Object}	evt_or_pane			The pane being opened, ie: north, south, east, or west
         * @param {boolean=}			[slide=false]
         * @param {boolean=}			[noAnimation=false]
         * @param {boolean=}			[noAlert=false]
         */
            ,	open = function (evt_or_pane, slide, noAnimation, noAlert) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$P	= $Ps[pane]
                    ,	$R	= $Rs[pane]
                    ,	$T	= $Ts[pane]
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                    ,	c	= _c[pane]
                    ,	doFX, isShowing
                    ;
                // QUEUE in case another action/animation is in progress
                $N.queue(function( queueNext ){

                    if ( !$P
                        ||	(!o.resizable && !o.closable && !s.isShowing)	// invalid request
                        ||	(s.isVisible && !s.isSliding)					// already open
                        ) return queueNext();

                    // pane can ALSO be unhidden by just calling show(), so handle this scenario
                    if (s.isHidden && !s.isShowing) {
                        queueNext(); // call before show() because it needs the queue free
                        show(pane, true);
                        return;
                    }

                    if (o.autoResize && s.size != o.size) // resize pane to original size set in options
                        sizePane(pane, o.size, true, true, true); // true=skipCallback/forceResize/noAnimation
                    else
                    // make sure there is enough space available to open the pane
                        setSizeLimits(pane, slide);

                    // onopen_start callback - will CANCEL open if returns false
                    var cbReturn = _runCallbacks("onopen_start", pane);

                    if (cbReturn === "abort")
                        return queueNext();

                    // update pane-state again in case options were changed in onopen_start
                    if (cbReturn !== "NC") // NC = "No Callback"
                        setSizeLimits(pane, slide);

                    if (s.minSize > s.maxSize) { // INSUFFICIENT ROOM FOR PANE TO OPEN!
                        syncPinBtns(pane, false); // make sure pin-buttons are reset
                        if (!noAlert && o.tips.noRoomToOpen)
                            alert(o.tips.noRoomToOpen);
                        return queueNext(); // ABORT
                    }

                    if (slide) // START Sliding - will set isSliding=true
                        bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
                    else if (s.isSliding) // PIN PANE (stop sliding) - open pane 'normally' instead
                        bindStopSlidingEvents(pane, false); // UNBIND trigger events - will set isSliding=false
                    else if (o.slidable)
                        bindStartSlidingEvent(pane, false); // UNBIND trigger events

                    s.noRoom = false; // will be reset by makePaneFit if 'noRoom'
                    makePaneFit(pane);

                    // transfer logic var to temp var
                    isShowing = s.isShowing;
                    // now clear the logic var
                    delete s.isShowing;

                    doFX		= !noAnimation && s.isClosed && (o.fxName_open != "none");
                    s.isMoving	= true;
                    s.isVisible	= true;
                    s.isClosed	= false;
                    // update isHidden BEFORE sizing panes - WHY??? Old?
                    if (isShowing) s.isHidden = false;

                    if (doFX) { // ANIMATE
                        // mask panes with objects
                        var masks = "center"+ (c.dir=="horz" ? ",west,east" : "");
                        if (s.isSliding) masks += ","+ _c.oppositeEdge[pane];
                        showMasks( masks, true );	// true = ONLY mask panes with maskObjects=true
                        lockPaneForFX(pane, true);	// need to set left/top so animation will work
                        $P.show( o.fxName_open, o.fxSettings_open, o.fxSpeed_open, function() {
                            lockPaneForFX(pane, false); // undo
                            if (s.isVisible) open_2(); // continue
                            queueNext();
                        });
                    }
                    else { // no animation
                        _showPane(pane);// just show pane and...
                        open_2();		// continue
                        queueNext();
                    };
                });

                // SUBROUTINE
                function open_2 () {
                    s.isMoving	= false;

                    // cure iframe display issues
                    _fixIframe(pane);

                    // NOTE: if isSliding, then other panes are NOT 'resized'
                    if (!s.isSliding) { // resize all panes adjacent to this one
                        hideMasks(); // remove any masks shown while opening
                        sizeMidPanes(_c[pane].dir=="vert" ? "center" : "", false); // false = NOT skipCallback
                    }

                    // set classes, position handles and execute callbacks...
                    setAsOpen(pane);
                };

            }

        /**
         * @param {string}	pane		The pane just opened, ie: north, south, east, or west
         * @param {boolean=}	[skipCallback=false]
         */
            ,	setAsOpen = function (pane, skipCallback) {
                var
                    $P		= $Ps[pane]
                    ,	$R		= $Rs[pane]
                    ,	$T		= $Ts[pane]
                    ,	o		= options[pane]
                    ,	s		= state[pane]
                    ,	side	= _c[pane].side.toLowerCase()
                    ,	inset	= "inset"+ _c[pane].side
                    ,	rClass	= o.resizerClass
                    ,	tClass	= o.togglerClass
                    ,	_pane	= "-"+ pane // used for classNames
                    ,	_open	= "-open"
                    ,	_closed	= "-closed"
                    ,	_sliding= "-sliding"
                    ;
                $R
                    .css(side, sC[inset] + getPaneSize(pane)) // move the resizer
                    .removeClass( rClass+_closed +" "+ rClass+_pane+_closed )
                    .addClass( rClass+_open +" "+ rClass+_pane+_open )
                ;
                if (s.isSliding)
                    $R.addClass( rClass+_sliding +" "+ rClass+_pane+_sliding )
                else // in case 'was sliding'
                    $R.removeClass( rClass+_sliding +" "+ rClass+_pane+_sliding )

                if (o.resizerDblClickToggle)
                    $R.bind("dblclick", toggle );
                removeHover( 0, $R ); // remove hover classes
                if (o.resizable && $.layout.plugins.draggable)
                    $R	.draggable("enable")
                        .css("cursor", o.resizerCursor)
                        .attr("title", o.tips.Resize);
                else if (!s.isSliding)
                    $R.css("cursor", "default"); // n-resize, s-resize, etc

                // if pane also has a toggler button, adjust that too
                if ($T) {
                    $T	.removeClass( tClass+_closed +" "+ tClass+_pane+_closed )
                        .addClass( tClass+_open +" "+ tClass+_pane+_open )
                        .attr("title", o.tips.Close); // may be blank
                    removeHover( 0, $T ); // remove hover classes
                    // toggler-content - if exists
                    $T.children(".content-closed").hide();
                    $T.children(".content-open").css("display","block");
                }

                // sync any 'pin buttons'
                syncPinBtns(pane, !s.isSliding);

                // update pane-state dimensions - BEFORE resizing content
                $.extend(s, elDims($P));

                if (state.initialized) {
                    // resize resizer & toggler sizes for all panes
                    sizeHandles();
                    // resize content every time pane opens - to be sure
                    sizeContent(pane, true); // true = remeasure headers/footers, even if 'pane.isMoving'
                }

                if (!skipCallback && (state.initialized || o.triggerEventsOnLoad) && $P.is(":visible")) {
                    // onopen callback
                    _runCallbacks("onopen_end", pane);
                    // onshow callback - TODO: should this be here?
                    if (s.isShowing) _runCallbacks("onshow_end", pane);

                    // ALSO call onresize because layout-size *may* have changed while pane was closed
                    if (state.initialized)
                        _runCallbacks("onresize_end", pane);
                }

                // TODO: Somehow sizePane("north") is being called after this point???
            }


        /**
         * slideOpen / slideClose / slideToggle
         *
         * Pass-though methods for sliding
         */
            ,	slideOpen = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	evt		= evtObj(evt_or_pane)
                    ,	pane	= evtPane.call(this, evt_or_pane)
                    ,	s		= state[pane]
                    ,	delay	= options[pane].slideDelay_open
                    ;
                // prevent event from triggering on NEW resizer binding created below
                if (evt) evt.stopImmediatePropagation();

                if (s.isClosed && evt && evt.type === "mouseenter" && delay > 0)
                // trigger = mouseenter - use a delay
                    timer.set(pane+"_openSlider", open_NOW, delay);
                else
                    open_NOW(); // will unbind events if is already open

                /**
                 * SUBROUTINE for timed open
                 */
                function open_NOW () {
                    if (!s.isClosed) // skip if no longer closed!
                        bindStopSlidingEvents(pane, true); // BIND trigger events to close sliding-pane
                    else if (!s.isMoving)
                        open(pane, true); // true = slide - open() will handle binding
                };
            }

            ,	slideClose = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	evt		= evtObj(evt_or_pane)
                    ,	pane	= evtPane.call(this, evt_or_pane)
                    ,	o		= options[pane]
                    ,	s		= state[pane]
                    ,	delay	= s.isMoving ? 1000 : 300 // MINIMUM delay - option may override
                    ;
                if (s.isClosed || s.isResizing)
                    return; // skip if already closed OR in process of resizing
                else if (o.slideTrigger_close === "click")
                    close_NOW(); // close immediately onClick
                else if (o.preventQuickSlideClose && s.isMoving)
                    return; // handle Chrome quick-close on slide-open
                else if (o.preventPrematureSlideClose && evt && $.layout.isMouseOverElem(evt, $Ps[pane]))
                    return; // handle incorrect mouseleave trigger, like when over a SELECT-list in IE
                else if (evt) // trigger = mouseleave - use a delay
                // 1 sec delay if 'opening', else .3 sec
                    timer.set(pane+"_closeSlider", close_NOW, max(o.slideDelay_close, delay));
                else // called programically
                    close_NOW();

                /**
                 * SUBROUTINE for timed close
                 */
                function close_NOW () {
                    if (s.isClosed) // skip 'close' if already closed!
                        bindStopSlidingEvents(pane, false); // UNBIND trigger events - TODO: is this needed here?
                    else if (!s.isMoving)
                        close(pane); // close will handle unbinding
                };
            }

        /**
         * @param {string|Object}	evt_or_pane		The pane being opened, ie: north, south, east, or west
         */
            ,	slideToggle = function (evt_or_pane) {
                var pane = evtPane.call(this, evt_or_pane);
                toggle(pane, true);
            }


        /**
         * Must set left/top on East/South panes so animation will work properly
         *
         * @param {string}	pane	The pane to lock, 'east' or 'south' - any other is ignored!
         * @param {boolean}	doLock  true = set left/top, false = remove
         */
            ,	lockPaneForFX = function (pane, doLock) {
                var $P	= $Ps[pane]
                    ,	s	= state[pane]
                    ,	o	= options[pane]
                    ,	z	= options.zIndexes
                    ;
                if (doLock) {
                    $P.css({ zIndex: z.pane_animate }); // overlay all elements during animation
                    if (pane=="south")
                        $P.css({ top: sC.insetTop + sC.innerHeight - $P.outerHeight() });
                    else if (pane=="east")
                        $P.css({ left: sC.insetLeft + sC.innerWidth - $P.outerWidth() });
                }
                else { // animation DONE - RESET CSS
                    // TODO: see if this can be deleted. It causes a quick-close when sliding in Chrome
                    $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
                    if (pane=="south")
                        $P.css({ top: "auto" });
                    // if pane is positioned 'off-screen', then DO NOT screw with it!
                    else if (pane=="east" && !$P.css("left").match(/\-99999/))
                        $P.css({ left: "auto" });
                    // fix anti-aliasing in IE - only needed for animations that change opacity
                    if (browser.msie && o.fxOpacityFix && o.fxName_open != "slide" && $P.css("filter") && $P.css("opacity") == 1)
                        $P[0].style.removeAttribute('filter');
                }
            }


        /**
         * Toggle sliding functionality of a specific pane on/off by adding removing 'slide open' trigger
         *
         * @see  open(), close()
         * @param {string}	pane	The pane to enable/disable, 'north', 'south', etc.
         * @param {boolean}	enable	Enable or Disable sliding?
         */
            ,	bindStartSlidingEvent = function (pane, enable) {
                var o		= options[pane]
                    ,	$P		= $Ps[pane]
                    ,	$R		= $Rs[pane]
                    ,	evtName	= o.slideTrigger_open.toLowerCase()
                    ;
                if (!$R || (enable && !o.slidable)) return;

                // make sure we have a valid event
                if (evtName.match(/mouseover/))
                    evtName = o.slideTrigger_open = "mouseenter";
                else if (!evtName.match(/click|dblclick|mouseenter/))
                    evtName = o.slideTrigger_open = "click";

                $R
                    // add or remove event
                    [enable ? "bind" : "unbind"](evtName +'.'+ sID, slideOpen)
                    // set the appropriate cursor & title/tip
                    .css("cursor", enable ? o.sliderCursor : "default")
                    .attr("title", enable ? o.tips.Slide : "")
                ;
            }

        /**
         * Add or remove 'mouseleave' events to 'slide close' when pane is 'sliding' open or closed
         * Also increases zIndex when pane is sliding open
         * See bindStartSlidingEvent for code to control 'slide open'
         *
         * @see  slideOpen(), slideClose()
         * @param {string}	pane	The pane to process, 'north', 'south', etc.
         * @param {boolean}	enable	Enable or Disable events?
         */
            ,	bindStopSlidingEvents = function (pane, enable) {
                var	o		= options[pane]
                    ,	s		= state[pane]
                    ,	c		= _c[pane]
                    ,	z		= options.zIndexes
                    ,	evtName	= o.slideTrigger_close.toLowerCase()
                    ,	action	= (enable ? "bind" : "unbind")
                    ,	$P		= $Ps[pane]
                    ,	$R		= $Rs[pane]
                    ;
                s.isSliding = enable; // logic
                timer.clear(pane+"_closeSlider"); // just in case

                // remove 'slideOpen' event from resizer
                // ALSO will raise the zIndex of the pane & resizer
                if (enable) bindStartSlidingEvent(pane, false);

                // RE/SET zIndex - increases when pane is sliding-open, resets to normal when not
                $P.css("zIndex", enable ? z.pane_sliding : z.pane_normal);
                $R.css("zIndex", enable ? z.pane_sliding+2 : z.resizer_normal); // NOTE: mask = pane_sliding+1

                // make sure we have a valid event
                if (!evtName.match(/click|mouseleave/))
                    evtName = o.slideTrigger_close = "mouseleave"; // also catches 'mouseout'

                // add/remove slide triggers
                $R[action](evtName, slideClose); // base event on resize
                // need extra events for mouseleave
                if (evtName === "mouseleave") {
                    // also close on pane.mouseleave
                    $P[action]("mouseleave."+ sID, slideClose);
                    // cancel timer when mouse moves between 'pane' and 'resizer'
                    $R[action]("mouseenter."+ sID, cancelMouseOut);
                    $P[action]("mouseenter."+ sID, cancelMouseOut);
                }

                if (!enable)
                    timer.clear(pane+"_closeSlider");
                else if (evtName === "click" && !o.resizable) {
                    // IF pane is not resizable (which already has a cursor and tip) 
                    // then set the a cursor & title/tip on resizer when sliding
                    $R.css("cursor", enable ? o.sliderCursor : "default");
                    $R.attr("title", enable ? o.tips.Close : ""); // use Toggler-tip, eg: "Close Pane"
                }

                // SUBROUTINE for mouseleave timer clearing
                function cancelMouseOut (evt) {
                    timer.clear(pane+"_closeSlider");
                    evt.stopPropagation();
                }
            }


        /**
         * Hides/closes a pane if there is insufficient room - reverses this when there is room again
         * MUST have already called setSizeLimits() before calling this method
         *
         * @param {string}	pane					The pane being resized
         * @param {boolean=}	[isOpening=false]		Called from onOpen?
         * @param {boolean=}	[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}	[force=false]
         */
            ,	makePaneFit = function (pane, isOpening, skipCallback, force) {
                var
                    o	= options[pane]
                    ,	s	= state[pane]
                    ,	c	= _c[pane]
                    ,	$P	= $Ps[pane]
                    ,	$R	= $Rs[pane]
                    ,	isSidePane 	= c.dir==="vert"
                    ,	hasRoom		= false
                    ;
                // special handling for center & east/west panes
                if (pane === "center" || (isSidePane && s.noVerticalRoom)) {
                    // see if there is enough room to display the pane
                    // ERROR: hasRoom = s.minHeight <= s.maxHeight && (isSidePane || s.minWidth <= s.maxWidth);
                    hasRoom = (s.maxHeight >= 0);
                    if (hasRoom && s.noRoom) { // previously hidden due to noRoom, so show now
                        _showPane(pane);
                        if ($R) $R.show();
                        s.isVisible = true;
                        s.noRoom = false;
                        if (isSidePane) s.noVerticalRoom = false;
                        _fixIframe(pane);
                    }
                    else if (!hasRoom && !s.noRoom) { // not currently hidden, so hide now
                        _hidePane(pane);
                        if ($R) $R.hide();
                        s.isVisible = false;
                        s.noRoom = true;
                    }
                }

                // see if there is enough room to fit the border-pane
                if (pane === "center") {
                    // ignore center in this block
                }
                else if (s.minSize <= s.maxSize) { // pane CAN fit
                    hasRoom = true;
                    if (s.size > s.maxSize) // pane is too big - shrink it
                        sizePane(pane, s.maxSize, skipCallback, force, true); // true = noAnimation
                    else if (s.size < s.minSize) // pane is too small - enlarge it
                        sizePane(pane, s.minSize, skipCallback, force, true);
                    // need s.isVisible because new pseudoClose method keeps pane visible, but off-screen
                    else if ($R && s.isVisible && $P.is(":visible")) {
                        // make sure resizer-bar is positioned correctly
                        // handles situation where nested layout was 'hidden' when initialized
                        var	side = c.side.toLowerCase()
                            ,	pos  = s.size + sC["inset"+ c.side]
                            ;
                        if ($.layout.cssNum($R, side) != pos) $R.css( side, pos );
                    }

                    // if was previously hidden due to noRoom, then RESET because NOW there is room
                    if (s.noRoom) {
                        // s.noRoom state will be set by open or show
                        if (s.wasOpen && o.closable) {
                            if (o.autoReopen)
                                open(pane, false, true, true); // true = noAnimation, true = noAlert
                            else // leave the pane closed, so just update state
                                s.noRoom = false;
                        }
                        else
                            show(pane, s.wasOpen, true, true); // true = noAnimation, true = noAlert
                    }
                }
                else { // !hasRoom - pane CANNOT fit
                    if (!s.noRoom) { // pane not set as noRoom yet, so hide or close it now...
                        s.noRoom = true; // update state
                        s.wasOpen = !s.isClosed && !s.isSliding;
                        if (s.isClosed){} // SKIP
                        else if (o.closable) // 'close' if possible
                            close(pane, true, true); // true = force, true = noAnimation
                        else // 'hide' pane if cannot just be closed
                            hide(pane, true); // true = noAnimation
                    }
                }
            }


        /**
         * sizePane / manualSizePane
         * sizePane is called only by internal methods whenever a pane needs to be resized
         * manualSizePane is an exposed flow-through method allowing extra code when pane is 'manually resized'
         *
         * @param {string|Object}	evt_or_pane				The pane being resized
         * @param {number}			size					The *desired* new size for this pane - will be validated
         * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}			[noAnimation=false]
         */
            ,	manualSizePane = function (evt_or_pane, size, skipCallback, noAnimation) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	o	= options[pane]
                    ,	s	= state[pane]
                //	if resizing callbacks have been delayed and resizing is now DONE, force resizing to complete...
                    ,	forceResize = o.livePaneResizing && !s.isResizing
                    ;
                // ANY call to manualSizePane disables autoResize - ie, percentage sizing
                o.autoResize = false;
                // flow-through...
                sizePane(pane, size, skipCallback, forceResize, noAnimation); // will animate resize if option enabled
            }

        /**
         * @param {string|Object}	evt_or_pane				The pane being resized
         * @param {number}			size					The *desired* new size for this pane - will be validated
         * @param {boolean=}			[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}			[force=false]			Force resizing even if does not seem necessary
         * @param {boolean=}			[noAnimation=false]
         */
            ,	sizePane = function (evt_or_pane, size, skipCallback, force, noAnimation) {
                if (!isInitialized()) return;
                var	pane	= evtPane.call(this, evt_or_pane) // probably NEVER called from event?
                    ,	o		= options[pane]
                    ,	s		= state[pane]
                    ,	$P		= $Ps[pane]
                    ,	$R		= $Rs[pane]
                    ,	side	= _c[pane].side.toLowerCase()
                    ,	dimName	= _c[pane].sizeType.toLowerCase()
                    ,	inset	= "inset"+ _c[pane].side
                    ,	skipResizeWhileDragging = s.isResizing && !o.triggerEventsDuringLiveResize
                    ,	doFX	= noAnimation !== true && o.animatePaneSizing
                    ,	oldSize, newSize
                    ;
                // QUEUE in case another action/animation is in progress
                $N.queue(function( queueNext ){
                    // calculate 'current' min/max sizes
                    setSizeLimits(pane); // update pane-state
                    oldSize = s.size;
                    size = _parseSize(pane, size); // handle percentages & auto
                    size = max(size, _parseSize(pane, o.minSize));
                    size = min(size, s.maxSize);
                    if (size < s.minSize) { // not enough room for pane!
                        queueNext(); // call before makePaneFit() because it needs the queue free
                        makePaneFit(pane, false, skipCallback);	// will hide or close pane
                        return;
                    }

                    // IF newSize is same as oldSize, then nothing to do - abort
                    if (!force && size === oldSize)
                        return queueNext();

                    // onresize_start callback CANNOT cancel resizing because this would break the layout!
                    if (!skipCallback && state.initialized && s.isVisible)
                        _runCallbacks("onresize_start", pane);

                    // resize the pane, and make sure its visible
                    newSize = cssSize(pane, size);

                    if (doFX && $P.is(":visible")) { // ANIMATE
                        var fx		= $.layout.effects.size[pane] || $.layout.effects.size.all
                            ,	easing	= o.fxSettings_size.easing || fx.easing
                            ,	z		= options.zIndexes
                            ,	props	= {};
                        props[ dimName ] = newSize +'px';
                        s.isMoving = true;
                        // overlay all elements during animation
                        $P.css({ zIndex: z.pane_animate })
                            .show().animate( props, o.fxSpeed_size, easing, function(){
                                // reset zIndex after animation
                                $P.css({ zIndex: (s.isSliding ? z.pane_sliding : z.pane_normal) });
                                s.isMoving = false;
                                sizePane_2(); // continue
                                queueNext();
                            });
                    }
                    else { // no animation
                        $P.css( dimName, newSize );	// resize pane
                        // if pane is visible, then 
                        if ($P.is(":visible"))
                            sizePane_2(); // continue
                        else {
                            // pane is NOT VISIBLE, so just update state data...
                            // when pane is *next opened*, it will have the new size
                            s.size = size;				// update state.size
                            $.extend(s, elDims($P));	// update state dimensions
                        }
                        queueNext();
                    };

                });

                // SUBROUTINE
                function sizePane_2 () {
                    /*	Panes are sometimes not sized precisely in some browsers!?
                     *	This code will resize the pane up to 3 times to nudge the pane to the correct size
                     */
                    var	actual	= dimName==='width' ? $P.outerWidth() : $P.outerHeight()
                        ,	tries	= [{
                            pane:		pane
                            ,	count:		1
                            ,	target:		size
                            ,	actual:		actual
                            ,	correct:	(size === actual)
                            ,	attempt:	size
                            ,	cssSize:	newSize
                        }]
                        ,	lastTry = tries[0]
                        ,	msg		= 'Inaccurate size after resizing the '+ pane +'-pane.'
                        ;
                    while ( !lastTry.correct ) {
                        thisTry = { pane: pane, count: lastTry.count+1, target: size };

                        if (lastTry.actual > size)
                            thisTry.attempt = max(0, lastTry.attempt - (lastTry.actual - size));
                        else // lastTry.actual < size
                            thisTry.attempt = max(0, lastTry.attempt + (size - lastTry.actual));

                        thisTry.cssSize = cssSize(pane, thisTry.attempt);
                        $P.css( dimName, thisTry.cssSize );

                        thisTry.actual	= dimName=='width' ? $P.outerWidth() : $P.outerHeight();
                        thisTry.correct	= (size === thisTry.actual);

                        // log attempts and alert the user of this *non-fatal error* (if showDebugMessages)
                        if ( tries.length === 1) {
                            _log(msg, false, true);
                            _log(lastTry, false, true);
                        }
                        _log(thisTry, false, true);
                        // after 4 tries, is as close as its gonna get!
                        if (tries.length > 3) break;

                        tries.push( thisTry );
                        lastTry = tries[ tries.length - 1 ];
                    }
                    // END TESTING CODE

                    // update pane-state dimensions
                    s.size	= size;
                    $.extend(s, elDims($P));

                    if (s.isVisible && $P.is(":visible")) {
                        // reposition the resizer-bar
                        if ($R) $R.css( side, size + sC[inset] );
                        // resize the content-div
                        sizeContent(pane);
                    }

                    if (!skipCallback && !skipResizeWhileDragging && state.initialized && s.isVisible)
                        _runCallbacks("onresize_end", pane);

                    // resize all the adjacent panes, and adjust their toggler buttons
                    // when skipCallback passed, it means the controlling method will handle 'other panes'
                    if (!skipCallback) {
                        // also no callback if live-resize is in progress and NOT triggerEventsDuringLiveResize
                        if (!s.isSliding) sizeMidPanes(_c[pane].dir=="horz" ? "" : "center", skipResizeWhileDragging, force);
                        sizeHandles();
                    }

                    // if opposite-pane was autoClosed, see if it can be autoOpened now
                    var altPane = _c.oppositeEdge[pane];
                    if (size < oldSize && state[ altPane ].noRoom) {
                        setSizeLimits( altPane );
                        makePaneFit( altPane, false, skipCallback );
                    }

                    // DEBUG - ALERT user/developer so they know there was a sizing problem
                    if (tries.length > 1)
                        _log(msg +'\nSee the Error Console for details.', true, true);
                }
            }

        /**
         * @see  initPanes(), sizePane(), resizeAll(), open(), close(), hide()
         * @param {Array.<string>|string} panes					The pane(s) being resized, comma-delmited string
         * @param {boolean=}				[skipCallback=false]	Should the onresize callback be run?
         * @param {boolean=}				[force=false]
         */
            ,	sizeMidPanes = function (panes, skipCallback, force) {
                panes = (panes ? panes : "east,west,center").split(",");

                $.each(panes, function (i, pane) {
                    if (!$Ps[pane]) return; // NO PANE - skip
                    var
                        o		= options[pane]
                        ,	s		= state[pane]
                        ,	$P		= $Ps[pane]
                        ,	$R		= $Rs[pane]
                        ,	isCenter= (pane=="center")
                        ,	hasRoom	= true
                        ,	CSS		= {}
                        ,	newCenter	= calcNewCenterPaneDims()
                        ;
                    // update pane-state dimensions
                    $.extend(s, elDims($P));

                    if (pane === "center") {
                        if (!force && s.isVisible && newCenter.width === s.outerWidth && newCenter.height === s.outerHeight)
                            return true; // SKIP - pane already the correct size
                        // set state for makePaneFit() logic
                        $.extend(s, cssMinDims(pane), {
                            maxWidth:	newCenter.width
                            ,	maxHeight:	newCenter.height
                        });
                        CSS = newCenter;
                        // convert OUTER width/height to CSS width/height 
                        CSS.width	= cssW($P, CSS.width);
                        // NEW - allow pane to extend 'below' visible area rather than hide it
                        CSS.height	= cssH($P, CSS.height);
                        hasRoom		= CSS.width >= 0 && CSS.height >= 0; // height >= 0 = ALWAYS TRUE NOW
                        // during layout init, try to shrink east/west panes to make room for center
                        if (!state.initialized && o.minWidth > s.outerWidth) {
                            var
                                reqPx	= o.minWidth - s.outerWidth
                                ,	minE	= options.east.minSize || 0
                                ,	minW	= options.west.minSize || 0
                                ,	sizeE	= state.east.size
                                ,	sizeW	= state.west.size
                                ,	newE	= sizeE
                                ,	newW	= sizeW
                                ;
                            if (reqPx > 0 && state.east.isVisible && sizeE > minE) {
                                newE = max( sizeE-minE, sizeE-reqPx );
                                reqPx -= sizeE-newE;
                            }
                            if (reqPx > 0 && state.west.isVisible && sizeW > minW) {
                                newW = max( sizeW-minW, sizeW-reqPx );
                                reqPx -= sizeW-newW;
                            }
                            // IF we found enough extra space, then resize the border panes as calculated
                            if (reqPx === 0) {
                                if (sizeE && sizeE != minE)
                                    sizePane('east', newE, true, force, true); // true = skipCallback/noAnimation - initPanes will handle when done
                                if (sizeW && sizeW != minW)
                                    sizePane('west', newW, true, force, true);
                                // now start over!
                                sizeMidPanes('center', skipCallback, force);
                                return; // abort this loop
                            }
                        }
                    }
                    else { // for east and west, set only the height, which is same as center height
                        // set state.min/maxWidth/Height for makePaneFit() logic
                        if (s.isVisible && !s.noVerticalRoom)
                            $.extend(s, elDims($P), cssMinDims(pane))
                        if (!force && !s.noVerticalRoom && newCenter.height === s.outerHeight)
                            return true; // SKIP - pane already the correct size
                        // east/west have same top, bottom & height as center
                        CSS.top		= newCenter.top;
                        CSS.bottom	= newCenter.bottom;
                        // NEW - allow pane to extend 'below' visible area rather than hide it
                        CSS.height	= cssH($P, newCenter.height);
                        s.maxHeight	= CSS.height;
                        hasRoom		= (s.maxHeight >= 0); // ALWAYS TRUE NOW
                        if (!hasRoom) s.noVerticalRoom = true; // makePaneFit() logic
                    }

                    if (hasRoom) {
                        // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
                        if (!skipCallback && state.initialized)
                            _runCallbacks("onresize_start", pane);

                        $P.css(CSS); // apply the CSS to pane
                        if (pane !== "center")
                            sizeHandles(pane); // also update resizer length
                        if (s.noRoom && !s.isClosed && !s.isHidden)
                            makePaneFit(pane); // will re-open/show auto-closed/hidden pane
                        if (s.isVisible) {
                            $.extend(s, elDims($P)); // update pane dimensions
                            if (state.initialized) sizeContent(pane); // also resize the contents, if exists
                        }
                    }
                    else if (!s.noRoom && s.isVisible) // no room for pane
                        makePaneFit(pane); // will hide or close pane

                    if (!s.isVisible)
                        return true; // DONE - next pane

                    /*
                     * Extra CSS for IE6 or IE7 in Quirks-mode - add 'width' to NORTH/SOUTH panes
                     * Normally these panes have only 'left' & 'right' positions so pane auto-sizes
                     * ALSO required when pane is an IFRAME because will NOT default to 'full width'
                     *	TODO: Can I use width:100% for a north/south iframe?
                     *	TODO: Sounds like a job for $P.outerWidth( sC.innerWidth ) SETTER METHOD
                     */
                    if (pane === "center") { // finished processing midPanes
                        var fix = browser.isIE6 || !browser.boxModel;
                        if ($Ps.north && (fix || state.north.tagName=="IFRAME"))
                            $Ps.north.css("width", cssW($Ps.north, sC.innerWidth));
                        if ($Ps.south && (fix || state.south.tagName=="IFRAME"))
                            $Ps.south.css("width", cssW($Ps.south, sC.innerWidth));
                    }

                    // resizeAll passes skipCallback because it triggers callbacks after ALL panes are resized
                    if (!skipCallback && state.initialized)
                        _runCallbacks("onresize_end", pane);
                });
            }


        /**
         * @see  window.onresize(), callbacks or custom code
         */
            ,	resizeAll = function (evt) {
                // stopPropagation if called by trigger("layoutdestroy") - use evtPane utility 
                evtPane(evt);

                if (!state.initialized) {
                    _initLayoutElements();
                    return; // no need to resize since we just initialized!
                }
                var	oldW	= sC.innerWidth
                    ,	oldH	= sC.innerHeight
                    ;
                // cannot size layout when 'container' is hidden or collapsed
                if (!$N.is(":visible") ) return;
                $.extend(state.container, elDims( $N )); // UPDATE container dimensions
                if (!sC.outerHeight) return;

                // onresizeall_start will CANCEL resizing if returns false
                // state.container has already been set, so user can access this info for calcuations
                if (false === _runCallbacks("onresizeall_start")) return false;

                var	// see if container is now 'smaller' than before
                    shrunkH	= (sC.innerHeight < oldH)
                    ,	shrunkW	= (sC.innerWidth < oldW)
                    ,	$P, o, s, dir
                    ;
                // NOTE special order for sizing: S-N-E-W
                $.each(["south","north","east","west"], function (i, pane) {
                    if (!$Ps[pane]) return; // no pane - SKIP
                    s	= state[pane];
                    o	= options[pane];
                    dir	= _c[pane].dir;

                    if (o.autoResize && s.size != o.size) // resize pane to original size set in options
                        sizePane(pane, o.size, true, true, true); // true=skipCallback/forceResize/noAnimation
                    else {
                        setSizeLimits(pane);
                        makePaneFit(pane, false, true, true); // true=skipCallback/forceResize
                    }
                });

                sizeMidPanes("", true, true); // true=skipCallback, true=forceResize
                sizeHandles(); // reposition the toggler elements

                // trigger all individual pane callbacks AFTER layout has finished resizing
                o = options; // reuse alias
                $.each(_c.allPanes, function (i, pane) {
                    $P = $Ps[pane];
                    if (!$P) return; // SKIP
                    if (state[pane].isVisible) // undefined for non-existent panes
                        _runCallbacks("onresize_end", pane); // callback - if exists
                });

                _runCallbacks("onresizeall_end");
                //_triggerLayoutEvent(pane, 'resizeall');
            }

        /**
         * Whenever a pane resizes or opens that has a nested layout, trigger resizeAll
         *
         * @param {string|Object}	evt_or_pane		The pane just resized or opened
         */
            ,	resizeChildLayout = function (evt_or_pane) {
                var	pane = evtPane.call(this, evt_or_pane);
                if (!options[pane].resizeChildLayout) return;
                var	$P	= $Ps[pane]
                    ,	$C	= $Cs[pane]
                    ,	d	= "layout"
                    ,	P	= Instance[pane]
                    ,	L	= children[pane]
                    ;
                // user may have manually set EITHER instance pointer, so handle that
                if (P.child && !L) {
                    // have to reverse the pointers!
                    var el = P.child.container;
                    L = children[pane] = (el ? el.data(d) : 0) || null; // set pointer _directly_ to layout instance
                }

                // if a layout-pointer exists, see if child has been destroyed
                if (L && L.destroyed)
                    L = children[pane] = null; // clear child pointers
                // no child layout pointer is set - see if there is a child layout NOW
                if (!L)	L = children[pane] = $P.data(d) || ($C ? $C.data(d) : 0) || null; // set/update child pointers

                // ALWAYS refresh the pane.child alias
                P.child = children[pane];

                if (L) L.resizeAll();
            }


        /**
         * IF pane has a content-div, then resize all elements inside pane to fit pane-height
         *
         * @param {string|Object}	evt_or_panes		The pane(s) being resized
         * @param {boolean=}			[remeasure=false]	Should the content (header/footer) be remeasured?
         */
            ,	sizeContent = function (evt_or_panes, remeasure) {
                if (!isInitialized()) return;

                var panes = evtPane.call(this, evt_or_panes);
                panes = panes ? panes.split(",") : _c.allPanes;

                $.each(panes, function (idx, pane) {
                    var
                        $P	= $Ps[pane]
                        ,	$C	= $Cs[pane]
                        ,	o	= options[pane]
                        ,	s	= state[pane]
                        ,	m	= s.content // m = measurements
                        ;
                    if (!$P || !$C || !$P.is(":visible")) return true; // NOT VISIBLE - skip

                    // if content-element was REMOVED, update OR remove the pointer
                    if (!$C.length) {
                        initContent(pane, false);	// false = do NOT sizeContent() - already there!
                        if (!$C) return;			// no replacement element found - pointer have been removed
                    }

                    // onsizecontent_start will CANCEL resizing if returns false
                    if (false === _runCallbacks("onsizecontent_start", pane)) return;

                    // skip re-measuring offsets if live-resizing
                    if ((!s.isMoving && !s.isResizing) || o.liveContentResizing || remeasure || m.top == undefined) {
                        _measure();
                        // if any footers are below pane-bottom, they may not measure correctly,
                        // so allow pane overflow and re-measure
                        if (m.hiddenFooters > 0 && $P.css("overflow") === "hidden") {
                            $P.css("overflow", "visible");
                            _measure(); // remeasure while overflowing
                            $P.css("overflow", "hidden");
                        }
                    }
                    // NOTE: spaceAbove/Below *includes* the pane paddingTop/Bottom, but not pane.borders
                    var newH = s.innerHeight - (m.spaceAbove - s.css.paddingTop) - (m.spaceBelow - s.css.paddingBottom);

                    if (!$C.is(":visible") || m.height != newH) {
                        // size the Content element to fit new pane-size - will autoHide if not enough room
                        setOuterHeight($C, newH, true); // true=autoHide
                        m.height = newH; // save new height
                    };

                    if (state.initialized)
                        _runCallbacks("onsizecontent_end", pane);

                    function _below ($E) {
                        return max(s.css.paddingBottom, (parseInt($E.css("marginBottom"), 10) || 0));
                    };

                    function _measure () {
                        var
                            ignore	= options[pane].contentIgnoreSelector
                            ,	$Fs		= $C.nextAll().not(ignore || ':lt(0)') // not :lt(0) = ALL
                            ,	$Fs_vis	= $Fs.filter(':visible')
                            ,	$F		= $Fs_vis.filter(':last')
                            ;
                        m = {
                            top:			$C[0].offsetTop
                            ,	height:			$C.outerHeight()
                            ,	numFooters:		$Fs.length
                            ,	hiddenFooters:	$Fs.length - $Fs_vis.length
                            ,	spaceBelow:		0 // correct if no content footer ($E)
                        }
                        m.spaceAbove	= m.top; // just for state - not used in calc
                        m.bottom		= m.top + m.height;
                        if ($F.length)
                        //spaceBelow = (LastFooter.top + LastFooter.height) [footerBottom] - Content.bottom + max(LastFooter.marginBottom, pane.paddingBotom)
                            m.spaceBelow = ($F[0].offsetTop + $F.outerHeight()) - m.bottom + _below($F);
                        else // no footer - check marginBottom on Content element itself
                            m.spaceBelow = _below($C);
                    };
                });
            }


        /**
         * Called every time a pane is opened, closed, or resized to slide the togglers to 'center' and adjust their length if necessary
         *
         * @see  initHandles(), open(), close(), resizeAll()
         * @param {string|Object}	evt_or_panes		The pane(s) being resized
         */
            ,	sizeHandles = function (evt_or_panes) {
                var panes = evtPane.call(this, evt_or_panes)
                panes = panes ? panes.split(",") : _c.borderPanes;

                $.each(panes, function (i, pane) {
                    var
                        o	= options[pane]
                        ,	s	= state[pane]
                        ,	$P	= $Ps[pane]
                        ,	$R	= $Rs[pane]
                        ,	$T	= $Ts[pane]
                        ,	$TC
                        ;
                    if (!$P || !$R) return;

                    var
                        dir			= _c[pane].dir
                        ,	_state		= (s.isClosed ? "_closed" : "_open")
                        ,	spacing		= o["spacing"+ _state]
                        ,	togAlign	= o["togglerAlign"+ _state]
                        ,	togLen		= o["togglerLength"+ _state]
                        ,	paneLen
                        ,	left
                        ,	offset
                        ,	CSS = {}
                        ;

                    if (spacing === 0) {
                        $R.hide();
                        return;
                    }
                    else if (!s.noRoom && !s.isHidden) // skip if resizer was hidden for any reason
                        $R.show(); // in case was previously hidden

                    // Resizer Bar is ALWAYS same width/height of pane it is attached to
                    if (dir === "horz") { // north/south
                        //paneLen = $P.outerWidth(); // s.outerWidth || 
                        paneLen = sC.innerWidth; // handle offscreen-panes
                        s.resizerLength = paneLen;
                        left = $.layout.cssNum($P, "left")
                        $R.css({
                            width:	cssW($R, paneLen) // account for borders & padding
                            ,	height:	cssH($R, spacing) // ditto
                            ,	left:	left > -9999 ? left : sC.insetLeft // handle offscreen-panes
                        });
                    }
                    else { // east/west
                        paneLen = $P.outerHeight(); // s.outerHeight || 
                        s.resizerLength = paneLen;
                        $R.css({
                            height:	cssH($R, paneLen) // account for borders & padding
                            ,	width:	cssW($R, spacing) // ditto
                            ,	top:	sC.insetTop + getPaneSize("north", true) // TODO: what if no North pane?
                            //,	top:	$.layout.cssNum($Ps["center"], "top")
                        });
                    }

                    // remove hover classes
                    removeHover( o, $R );

                    if ($T) {
                        if (togLen === 0 || (s.isSliding && o.hideTogglerOnSlide)) {
                            $T.hide(); // always HIDE the toggler when 'sliding'
                            return;
                        }
                        else
                            $T.show(); // in case was previously hidden

                        if (!(togLen > 0) || togLen === "100%" || togLen > paneLen) {
                            togLen = paneLen;
                            offset = 0;
                        }
                        else { // calculate 'offset' based on options.PANE.togglerAlign_open/closed
                            if (isStr(togAlign)) {
                                switch (togAlign) {
                                    case "top":
                                    case "left":	offset = 0;
                                        break;
                                    case "bottom":
                                    case "right":	offset = paneLen - togLen;
                                        break;
                                    case "middle":
                                    case "center":
                                    default:		offset = round((paneLen - togLen) / 2); // 'default' catches typos
                                }
                            }
                            else { // togAlign = number
                                var x = parseInt(togAlign, 10); //
                                if (togAlign >= 0) offset = x;
                                else offset = paneLen - togLen + x; // NOTE: x is negative!
                            }
                        }

                        if (dir === "horz") { // north/south
                            var width = cssW($T, togLen);
                            $T.css({
                                width:	width  // account for borders & padding
                                ,	height:	cssH($T, spacing) // ditto
                                ,	left:	offset // TODO: VERIFY that toggler  positions correctly for ALL values
                                ,	top:	0
                            });
                            // CENTER the toggler content SPAN
                            $T.children(".content").each(function(){
                                $TC = $(this);
                                $TC.css("marginLeft", round((width-$TC.outerWidth())/2)); // could be negative
                            });
                        }
                        else { // east/west
                            var height = cssH($T, togLen);
                            $T.css({
                                height:	height // account for borders & padding
                                ,	width:	cssW($T, spacing) // ditto
                                ,	top:	offset // POSITION the toggler
                                ,	left:	0
                            });
                            // CENTER the toggler content SPAN
                            $T.children(".content").each(function(){
                                $TC = $(this);
                                $TC.css("marginTop", round((height-$TC.outerHeight())/2)); // could be negative
                            });
                        }

                        // remove ALL hover classes
                        removeHover( 0, $T );
                    }

                    // DONE measuring and sizing this resizer/toggler, so can be 'hidden' now
                    if (!state.initialized && (o.initHidden || s.noRoom)) {
                        $R.hide();
                        if ($T) $T.hide();
                    }
                });
            }


        /**
         * @param {string|Object}	evt_or_pane
         */
            ,	enableClosable = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$T	= $Ts[pane]
                    ,	o	= options[pane]
                    ;
                if (!$T) return;
                o.closable = true;
                $T	.bind("click."+ sID, function(evt){ evt.stopPropagation(); toggle(pane); })
                    .css("visibility", "visible")
                    .css("cursor", "pointer")
                    .attr("title", state[pane].isClosed ? o.tips.Open : o.tips.Close) // may be blank
                    .show();
            }
        /**
         * @param {string|Object}	evt_or_pane
         * @param {boolean=}			[hide=false]
         */
            ,	disableClosable = function (evt_or_pane, hide) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$T	= $Ts[pane]
                    ;
                if (!$T) return;
                options[pane].closable = false;
                // is closable is disable, then pane MUST be open!
                if (state[pane].isClosed) open(pane, false, true);
                $T	.unbind("."+ sID)
                    .css("visibility", hide ? "hidden" : "visible") // instead of hide(), which creates logic issues
                    .css("cursor", "default")
                    .attr("title", "");
            }


        /**
         * @param {string|Object}	evt_or_pane
         */
            ,	enableSlidable = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$R	= $Rs[pane]
                    ;
                if (!$R || !$R.data('draggable')) return;
                options[pane].slidable = true;
                if (state[pane].isClosed)
                    bindStartSlidingEvent(pane, true);
            }
        /**
         * @param {string|Object}	evt_or_pane
         */
            ,	disableSlidable = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$R	= $Rs[pane]
                    ;
                if (!$R) return;
                options[pane].slidable = false;
                if (state[pane].isSliding)
                    close(pane, false, true);
                else {
                    bindStartSlidingEvent(pane, false);
                    $R	.css("cursor", "default")
                        .attr("title", "");
                    removeHover(null, $R[0]); // in case currently hovered
                }
            }


        /**
         * @param {string|Object}	evt_or_pane
         */
            ,	enableResizable = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$R	= $Rs[pane]
                    ,	o	= options[pane]
                    ;
                if (!$R || !$R.data('draggable')) return;
                o.resizable = true;
                $R.draggable("enable");
                if (!state[pane].isClosed)
                    $R	.css("cursor", o.resizerCursor)
                        .attr("title", o.tips.Resize);
            }
        /**
         * @param {string|Object}	evt_or_pane
         */
            ,	disableResizable = function (evt_or_pane) {
                if (!isInitialized()) return;
                var	pane = evtPane.call(this, evt_or_pane)
                    ,	$R	= $Rs[pane]
                    ;
                if (!$R || !$R.data('draggable')) return;
                options[pane].resizable = false;
                $R	.draggable("disable")
                    .css("cursor", "default")
                    .attr("title", "");
                removeHover(null, $R[0]); // in case currently hovered
            }


        /**
         * Move a pane from source-side (eg, west) to target-side (eg, east)
         * If pane exists on target-side, move that to source-side, ie, 'swap' the panes
         *
         * @param {string|Object}	evt_or_pane1	The pane/edge being swapped
         * @param {string}			pane2			ditto
         */
            ,	swapPanes = function (evt_or_pane1, pane2) {
                if (!isInitialized()) return;
                var pane1 = evtPane.call(this, evt_or_pane1);
                // change state.edge NOW so callbacks can know where pane is headed...
                state[pane1].edge = pane2;
                state[pane2].edge = pane1;
                // run these even if NOT state.initialized
                if (false === _runCallbacks("onswap_start", pane1)
                    ||	false === _runCallbacks("onswap_start", pane2)
                    ) {
                    state[pane1].edge = pane1; // reset
                    state[pane2].edge = pane2;
                    return;
                }

                var
                    oPane1	= copy( pane1 )
                    ,	oPane2	= copy( pane2 )
                    ,	sizes	= {}
                    ;
                sizes[pane1] = oPane1 ? oPane1.state.size : 0;
                sizes[pane2] = oPane2 ? oPane2.state.size : 0;

                // clear pointers & state
                $Ps[pane1] = false;
                $Ps[pane2] = false;
                state[pane1] = {};
                state[pane2] = {};

                // ALWAYS remove the resizer & toggler elements
                if ($Ts[pane1]) $Ts[pane1].remove();
                if ($Ts[pane2]) $Ts[pane2].remove();
                if ($Rs[pane1]) $Rs[pane1].remove();
                if ($Rs[pane2]) $Rs[pane2].remove();
                $Rs[pane1] = $Rs[pane2] = $Ts[pane1] = $Ts[pane2] = false;

                // transfer element pointers and data to NEW Layout keys
                move( oPane1, pane2 );
                move( oPane2, pane1 );

                // cleanup objects
                oPane1 = oPane2 = sizes = null;

                // make panes 'visible' again
                if ($Ps[pane1]) $Ps[pane1].css(_c.visible);
                if ($Ps[pane2]) $Ps[pane2].css(_c.visible);

                // fix any size discrepancies caused by swap
                resizeAll();

                // run these even if NOT state.initialized
                _runCallbacks("onswap_end", pane1);
                _runCallbacks("onswap_end", pane2);

                return;

                function copy (n) { // n = pane
                    var
                        $P	= $Ps[n]
                        ,	$C	= $Cs[n]
                        ;
                    return !$P ? false : {
                        pane:		n
                        ,	P:			$P ? $P[0] : false
                        ,	C:			$C ? $C[0] : false
                        ,	state:		$.extend(true, {}, state[n])
                        ,	options:	$.extend(true, {}, options[n])
                    }
                };

                function move (oPane, pane) {
                    if (!oPane) return;
                    var
                        P		= oPane.P
                        ,	C		= oPane.C
                        ,	oldPane = oPane.pane
                        ,	c		= _c[pane]
                        ,	side	= c.side.toLowerCase()
                        ,	inset	= "inset"+ c.side
                    //	save pane-options that should be retained
                        ,	s		= $.extend(true, {}, state[pane])
                        ,	o		= options[pane]
                    //	RETAIN side-specific FX Settings - more below
                        ,	fx		= { resizerCursor: o.resizerCursor }
                        ,	re, size, pos
                        ;
                    $.each("fxName,fxSpeed,fxSettings".split(","), function (i, k) {
                        fx[k +"_open"]  = o[k +"_open"];
                        fx[k +"_close"] = o[k +"_close"];
                        fx[k +"_size"]  = o[k +"_size"];
                    });

                    // update object pointers and attributes
                    $Ps[pane] = $(P)
                        .data({
                            layoutPane:		Instance[pane]	// NEW pointer to pane-alias-object
                            ,	layoutEdge:		pane
                        })
                        .css(_c.hidden)
                        .css(c.cssReq)
                    ;
                    $Cs[pane] = C ? $(C) : false;

                    // set options and state
                    options[pane]	= $.extend(true, {}, oPane.options, fx);
                    state[pane]		= $.extend(true, {}, oPane.state);

                    // change classNames on the pane, eg: ui-layout-pane-east ==> ui-layout-pane-west
                    re = new RegExp(o.paneClass +"-"+ oldPane, "g");
                    P.className = P.className.replace(re, o.paneClass +"-"+ pane);

                    // ALWAYS regenerate the resizer & toggler elements
                    initHandles(pane); // create the required resizer & toggler

                    // if moving to different orientation, then keep 'target' pane size
                    if (c.dir != _c[oldPane].dir) {
                        size = sizes[pane] || 0;
                        setSizeLimits(pane); // update pane-state
                        size = max(size, state[pane].minSize);
                        // use manualSizePane to disable autoResize - not useful after panes are swapped
                        manualSizePane(pane, size, true, true); // true/true = skipCallback/noAnimation
                    }
                    else // move the resizer here
                        $Rs[pane].css(side, sC[inset] + (state[pane].isVisible ? getPaneSize(pane) : 0));


                    // ADD CLASSNAMES & SLIDE-BINDINGS
                    if (oPane.state.isVisible && !s.isVisible)
                        setAsOpen(pane, true); // true = skipCallback
                    else {
                        setAsClosed(pane);
                        bindStartSlidingEvent(pane, true); // will enable events IF option is set
                    }

                    // DESTROY the object
                    oPane = null;
                };
            }


        /**
         * INTERNAL method to sync pin-buttons when pane is opened or closed
         * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
         *
         * @see  open(), setAsOpen(), setAsClosed()
         * @param {string}	pane   These are the params returned to callbacks by layout()
         * @param {boolean}	doPin  True means set the pin 'down', False means 'up'
         */
            ,	syncPinBtns = function (pane, doPin) {
                if ($.layout.plugins.buttons)
                    $.each(state[pane].pins, function (i, selector) {
                        $.layout.buttons.setPinState(Instance, $(selector), pane, doPin);
                    });
            }

            ;	// END var DECLARATIONS

        /**
         * Capture keys when enableCursorHotkey - toggle pane if hotkey pressed
         *
         * @see  document.keydown()
         */
        function keyDown (evt) {
            if (!evt) return true;
            var code = evt.keyCode;
            if (code < 33) return true; // ignore special keys: ENTER, TAB, etc

            var
                PANE = {
                    38: "north" // Up Cursor	- $.ui.keyCode.UP
                    ,	40: "south" // Down Cursor	- $.ui.keyCode.DOWN
                    ,	37: "west"  // Left Cursor	- $.ui.keyCode.LEFT
                    ,	39: "east"  // Right Cursor	- $.ui.keyCode.RIGHT
                }
                ,	ALT		= evt.altKey // no worky!
                ,	SHIFT	= evt.shiftKey
                ,	CTRL	= evt.ctrlKey
                ,	CURSOR	= (CTRL && code >= 37 && code <= 40)
                ,	o, k, m, pane
                ;

            if (CURSOR && options[PANE[code]].enableCursorHotkey) // valid cursor-hotkey
                pane = PANE[code];
            else if (CTRL || SHIFT) // check to see if this matches a custom-hotkey
                $.each(_c.borderPanes, function (i, p) { // loop each pane to check its hotkey
                    o = options[p];
                    k = o.customHotkey;
                    m = o.customHotkeyModifier; // if missing or invalid, treated as "CTRL+SHIFT"
                    if ((SHIFT && m=="SHIFT") || (CTRL && m=="CTRL") || (CTRL && SHIFT)) { // Modifier matches
                        if (k && code === (isNaN(k) || k <= 9 ? k.toUpperCase().charCodeAt(0) : k)) { // Key matches
                            pane = p;
                            return false; // BREAK
                        }
                    }
                });

            // validate pane
            if (!pane || !$Ps[pane] || !options[pane].closable || state[pane].isHidden)
                return true;

            toggle(pane);

            evt.stopPropagation();
            evt.returnValue = false; // CANCEL key
            return false;
        };


        /*
         * ######################################
         *	UTILITY METHODS
         *	called externally or by initButtons
         * ######################################
         */

        /**
         * Change/reset a pane overflow setting & zIndex to allow popups/drop-downs to work
         *
         * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
         */
        function allowOverflow (el) {
            if (!isInitialized()) return;
            if (this && this.tagName) el = this; // BOUND to element
            var $P;
            if (isStr(el))
                $P = $Ps[el];
            else if ($(el).data("layoutRole"))
                $P = $(el);
            else
                $(el).parents().each(function(){
                    if ($(this).data("layoutRole")) {
                        $P = $(this);
                        return false; // BREAK
                    }
                });
            if (!$P || !$P.length) return; // INVALID

            var
                pane	= $P.data("layoutEdge")
                ,	s		= state[pane]
                ;

            // if pane is already raised, then reset it before doing it again!
            // this would happen if allowOverflow is attached to BOTH the pane and an element 
            if (s.cssSaved)
                resetOverflow(pane); // reset previous CSS before continuing

            // if pane is raised by sliding or resizing, or its closed, then abort
            if (s.isSliding || s.isResizing || s.isClosed) {
                s.cssSaved = false;
                return;
            }

            var
                newCSS	= { zIndex: (options.zIndexes.resizer_normal + 1) }
                ,	curCSS	= {}
                ,	of		= $P.css("overflow")
                ,	ofX		= $P.css("overflowX")
                ,	ofY		= $P.css("overflowY")
                ;
            // determine which, if any, overflow settings need to be changed
            if (of != "visible") {
                curCSS.overflow = of;
                newCSS.overflow = "visible";
            }
            if (ofX && !ofX.match(/(visible|auto)/)) {
                curCSS.overflowX = ofX;
                newCSS.overflowX = "visible";
            }
            if (ofY && !ofY.match(/(visible|auto)/)) {
                curCSS.overflowY = ofX;
                newCSS.overflowY = "visible";
            }

            // save the current overflow settings - even if blank!
            s.cssSaved = curCSS;

            // apply new CSS to raise zIndex and, if necessary, make overflow 'visible'
            $P.css( newCSS );

            // make sure the zIndex of all other panes is normal
            $.each(_c.allPanes, function(i, p) {
                if (p != pane) resetOverflow(p);
            });

        };
        /**
         * @param {Object=}   [el]	(optional) Can also be 'bound' to a click, mouseOver, or other event
         */
        function resetOverflow (el) {
            if (!isInitialized()) return;
            if (this && this.tagName) el = this; // BOUND to element
            var $P;
            if (isStr(el))
                $P = $Ps[el];
            else if ($(el).data("layoutRole"))
                $P = $(el);
            else
                $(el).parents().each(function(){
                    if ($(this).data("layoutRole")) {
                        $P = $(this);
                        return false; // BREAK
                    }
                });
            if (!$P || !$P.length) return; // INVALID

            var
                pane	= $P.data("layoutEdge")
                ,	s		= state[pane]
                ,	CSS		= s.cssSaved || {}
                ;
            // reset the zIndex
            if (!s.isSliding && !s.isResizing)
                $P.css("zIndex", options.zIndexes.pane_normal);

            // reset Overflow - if necessary
            $P.css( CSS );

            // clear var
            s.cssSaved = false;
        };

        /*
         * #####################
         * CREATE/RETURN LAYOUT
         * #####################
         */

        // validate that container exists
        var $N = $(this).eq(0); // FIRST matching Container element
        if (!$N.length) {
            return _log( options.errors.containerMissing );
        };

        // Users retrieve Instance of a layout with: $N.layout() OR $N.data("layout")
        // return the Instance-pointer if layout has already been initialized
        if ($N.data("layoutContainer") && $N.data("layout"))
            return $N.data("layout"); // cached pointer

        // init global vars
        var
            $Ps	= {}	// Panes x5		- set in initPanes()
            ,	$Cs	= {}	// Content x5	- set in initPanes()
            ,	$Rs	= {}	// Resizers x4	- set in initHandles()
            ,	$Ts	= {}	// Togglers x4	- set in initHandles()
            ,	$Ms	= $([])	// Masks - up to 2 masks per pane (IFRAME + DIV)
        //	aliases for code brevity
            ,	sC	= state.container // alias for easy access to 'container dimensions'
            ,	sID	= state.id // alias for unique layout ID/namespace - eg: "layout435"
            ;

        // create Instance object to expose data & option Properties, and primary action Methods
        var Instance = {
            //	layout data
            options:			options			// property - options hash
            ,	state:				state			// property - dimensions hash
            //	object pointers
            ,	container:			$N				// property - object pointers for layout container
            ,	panes:				$Ps				// property - object pointers for ALL Panes: panes.north, panes.center
            ,	contents:			$Cs				// property - object pointers for ALL Content: contents.north, contents.center
            ,	resizers:			$Rs				// property - object pointers for ALL Resizers, eg: resizers.north
            ,	togglers:			$Ts				// property - object pointers for ALL Togglers, eg: togglers.north
            //	border-pane open/close
            ,	hide:				hide			// method - ditto
            ,	show:				show			// method - ditto
            ,	toggle:				toggle			// method - pass a 'pane' ("north", "west", etc)
            ,	open:				open			// method - ditto
            ,	close:				close			// method - ditto
            ,	slideOpen:			slideOpen		// method - ditto
            ,	slideClose:			slideClose		// method - ditto
            ,	slideToggle:		slideToggle		// method - ditto
            //	pane actions
            ,	setSizeLimits:		setSizeLimits	// method - pass a 'pane' - update state min/max data
            ,	_sizePane:			sizePane		// method -intended for user by plugins only!
            ,	sizePane:			manualSizePane	// method - pass a 'pane' AND an 'outer-size' in pixels or percent, or 'auto'
            ,	sizeContent:		sizeContent		// method - pass a 'pane'
            ,	swapPanes:			swapPanes		// method - pass TWO 'panes' - will swap them
            ,	showMasks:			showMasks		// method - pass a 'pane' OR list of panes - default = all panes with mask option set
            ,	hideMasks:			hideMasks		// method - ditto'
            //	pane element methods
            ,	initContent:		initContent		// method - ditto
            ,	addPane:			addPane			// method - pass a 'pane'
            ,	removePane:			removePane		// method - pass a 'pane' to remove from layout, add 'true' to delete the pane-elem
            ,	createChildLayout:	createChildLayout// method - pass a 'pane' and (optional) layout-options (OVERRIDES options[pane].childOptions
            //	special pane option setting
            ,	enableClosable:		enableClosable	// method - pass a 'pane'
            ,	disableClosable:	disableClosable	// method - ditto
            ,	enableSlidable:		enableSlidable	// method - ditto
            ,	disableSlidable:	disableSlidable	// method - ditto
            ,	enableResizable:	enableResizable	// method - ditto
            ,	disableResizable:	disableResizable// method - ditto
            //	utility methods for panes
            ,	allowOverflow:		allowOverflow	// utility - pass calling element (this)
            ,	resetOverflow:		resetOverflow	// utility - ditto
            //	layout control
            ,	destroy:			destroy			// method - no parameters
            ,	initPanes:			isInitialized	// method - no parameters
            ,	resizeAll:			resizeAll		// method - no parameters
            //	callback triggering
            ,	runCallbacks:		_runCallbacks	// method - pass evtName & pane (if a pane-event), eg: trigger("onopen", "west")
            //	alias collections of options, state and children - created in addPane and extended elsewhere
            ,	hasParentLayout:	false			// set by initContainer()
            ,	children:			children		// pointers to child-layouts, eg: Instance.children["west"]
            ,	north:				false			// alias group: { name: pane, pane: $Ps[pane], options: options[pane], state: state[pane], child: children[pane] }
            ,	south:				false			// ditto
            ,	west:				false			// ditto
            ,	east:				false			// ditto
            ,	center:				false			// ditto
        };

        // create the border layout NOW
        if (_create() === 'cancel') // onload_start callback returned false to CANCEL layout creation
            return null;
        else // true OR false -- if layout-elements did NOT init (hidden or do not exist), can auto-init later
            return Instance; // return the Instance object

    }


    /*	OLD versions of jQuery only set $.support.boxModel after page is loaded
     *	so if this is IE, use support.boxModel to test for quirks-mode (ONLY IE changes boxModel).
     */
    $(function(){
        var b = $.layout.browser;
        if (b.msie) b.boxModel = $.support.boxModel;
    });


    /**
     * jquery.layout.state 1.0
     * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
     *
     * Copyright (c) 2010
     *   Kevin Dalman (http://allpro.net)
     *
     * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
     * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
     *
     * @dependancies: UI Layout 1.3.0.rc30.1 or higher
     * @dependancies: $.ui.cookie (above)
     *
     * @support: http://groups.google.com/group/jquery-ui-layout
     */
    /*
     *	State-management options stored in options.stateManagement, which includes a .cookie hash
     *	Default options saves ALL KEYS for ALL PANES, ie: pane.size, pane.isClosed, pane.isHidden
     *
     *	// STATE/COOKIE OPTIONS
     *	@example $(el).layout({
     stateManagement: {
     enabled:	true
     ,	stateKeys:	"east.size,west.size,east.isClosed,west.isClosed"
     ,	cookie:		{ name: "appLayout", path: "/" }
     }
     })
     *	@example $(el).layout({ stateManagement__enabled: true }) // enable auto-state-management using cookies
     *	@example $(el).layout({ stateManagement__cookie: { name: "appLayout", path: "/" } })
     *	@example $(el).layout({ stateManagement__cookie__name: "appLayout", stateManagement__cookie__path: "/" })
     *
     *	// STATE/COOKIE METHODS
     *	@example myLayout.saveCookie( "west.isClosed,north.size,south.isHidden", {expires: 7} );
     *	@example myLayout.loadCookie();
     *	@example myLayout.deleteCookie();
     *	@example var JSON = myLayout.readState();	// CURRENT Layout State
     *	@example var JSON = myLayout.readCookie();	// SAVED Layout State (from cookie)
     *	@example var JSON = myLayout.state.stateData;	// LAST LOADED Layout State (cookie saved in layout.state hash)
     *
     *	CUSTOM STATE-MANAGEMENT (eg, saved in a database)
     *	@example var JSON = myLayout.readState( "west.isClosed,north.size,south.isHidden" );
     *	@example myLayout.loadState( JSON );
     */

    /**
     *	UI COOKIE UTILITY
     *
     *	A $.cookie OR $.ui.cookie namespace *should be standard*, but until then...
     *	This creates $.ui.cookie so Layout does not need the cookie.jquery.js plugin
     *	NOTE: This utility is REQUIRED by the layout.state plugin
     *
     *	Cookie methods in Layout are created as part of State Management
     */
    if (!$.ui) $.ui = {};
    $.ui.cookie = {

        // cookieEnabled is not in DOM specs, but DOES works in all browsers,including IE6
        acceptsCookies: !!navigator.cookieEnabled

        ,	read: function (name) {
            var
                c		= document.cookie
                ,	cs		= c ? c.split(';') : []
                ,	pair	// loop var
                ;
            for (var i=0, n=cs.length; i < n; i++) {
                pair = $.trim(cs[i]).split('='); // name=value pair
                if (pair[0] == name) // found the layout cookie
                    return decodeURIComponent(pair[1]);

            }
            return null;
        }

        ,	write: function (name, val, cookieOpts) {
            var
                params	= ''
                ,	date	= ''
                ,	clear	= false
                ,	o		= cookieOpts || {}
                ,	x		= o.expires
                ;
            if (x && x.toUTCString)
                date = x;
            else if (x === null || typeof x === 'number') {
                date = new Date();
                if (x > 0)
                    date.setDate(date.getDate() + x);
                else {
                    date.setFullYear(1970);
                    clear = true;
                }
            }
            if (date)		params += ';expires='+ date.toUTCString();
            if (o.path)		params += ';path='+ o.path;
            if (o.domain)	params += ';domain='+ o.domain;
            if (o.secure)	params += ';secure';
            document.cookie = name +'='+ (clear ? "" : encodeURIComponent( val )) + params; // write or clear cookie
        }

        ,	clear: function (name) {
            $.ui.cookie.write(name, '', {expires: -1});
        }

    };
// if cookie.jquery.js is not loaded, create an alias to replicate it
// this may be useful to other plugins or code dependent on that plugin
    if (!$.cookie) $.cookie = function (k, v, o) {
        var C = $.ui.cookie;
        if (v === null)
            C.clear(k);
        else if (v === undefined)
            return C.read(k);
        else
            C.write(k, v, o);
    };


// tell Layout that the state plugin is available
    $.layout.plugins.stateManagement = true;

//	Add State-Management options to layout.defaults
    $.layout.config.optionRootKeys.push("stateManagement");
    $.layout.defaults.stateManagement = {
        enabled:	false	// true = enable state-management, even if not using cookies
        ,	autoSave:	true	// Save a state-cookie when page exits?
        ,	autoLoad:	true	// Load the state-cookie when Layout inits?
        // List state-data to save - must be pane-specific
        ,	stateKeys:	"north.size,south.size,east.size,west.size,"+
            "north.isClosed,south.isClosed,east.isClosed,west.isClosed,"+
            "north.isHidden,south.isHidden,east.isHidden,west.isHidden"
        ,	cookie: {
            name:	""	// If not specified, will use Layout.name, else just "Layout"
            ,	domain:	""	// blank = current domain
            ,	path:	""	// blank = current page, '/' = entire website
            ,	expires: ""	// 'days' to keep cookie - leave blank for 'session cookie'
            ,	secure:	false
        }
    };
// Set stateManagement as a layout-option, NOT a pane-option
    $.layout.optionsMap.layout.push("stateManagement");

    /*
     *	State Management methods
     */
    $.layout.state = {

        /**
         * Get the current layout state and save it to a cookie
         *
         * myLayout.saveCookie( keys, cookieOpts )
         *
         * @param {Object}			inst
         * @param {(string|Array)=}	keys
         * @param {Object=}			cookieOpts
         */
        saveCookie: function (inst, keys, cookieOpts) {
            var o	= inst.options
                ,	oS	= o.stateManagement
                ,	oC	= $.extend(true, {}, oS.cookie, cookieOpts || null)
                ,	data = inst.state.stateData = inst.readState( keys || oS.stateKeys ) // read current panes-state
                ;
            $.ui.cookie.write( oC.name || o.name || "Layout", $.layout.state.encodeJSON(data), oC );
            return $.extend(true, {}, data); // return COPY of state.stateData data
        }

        /**
         * Remove the state cookie
         *
         * @param {Object}	inst
         */
        ,	deleteCookie: function (inst) {
            var o = inst.options;
            $.ui.cookie.clear( o.stateManagement.cookie.name || o.name || "Layout" );
        }

        /**
         * Read & return data from the cookie - as JSON
         *
         * @param {Object}	inst
         */
        ,	readCookie: function (inst) {
            var o = inst.options;
            var c = $.ui.cookie.read( o.stateManagement.cookie.name || o.name || "Layout" );
            // convert cookie string back to a hash and return it
            return c ? $.layout.state.decodeJSON(c) : {};
        }

        /**
         * Get data from the cookie and USE IT to loadState
         *
         * @param {Object}	inst
         */
        ,	loadCookie: function (inst) {
            var c = $.layout.state.readCookie(inst); // READ the cookie
            if (c) {
                inst.state.stateData = $.extend(true, {}, c); // SET state.stateData
                inst.loadState(c); // LOAD the retrieved state
            }
            return c;
        }

        /**
         * Update layout options from the cookie, if one exists
         *
         * @param {Object}		inst
         * @param {Object=}		stateData
         * @param {boolean=}	animate
         */
        ,	loadState: function (inst, stateData, animate) {
            stateData = $.layout.transformData( stateData ); // panes = default subkey
            if ($.isEmptyObject( stateData )) return;
            $.extend(true, inst.options, stateData); // update layout options
            // if layout has already been initialized, then UPDATE layout state
            if (inst.state.initialized) {
                var pane, vis, o, s, h, c
                    ,	noAnimate = (animate===false)
                    ;
                $.each($.layout.config.borderPanes, function (idx, pane) {
                    state = inst.state[pane];
                    o = stateData[ pane ];
                    if (typeof o != 'object') return; // no key, continue
                    s	= o.size;
                    c	= o.initClosed;
                    h	= o.initHidden;
                    vis	= state.isVisible;
                    // resize BEFORE opening
                    if (!vis)
                        inst.sizePane(pane, s, false, false);
                    if (h === true)			inst.hide(pane, noAnimate);
                    else if (c === false)	inst.open (pane, false, noAnimate);
                    else if (c === true)	inst.close(pane, false, noAnimate);
                    else if (h === false)	inst.show (pane, false, noAnimate);
                    // resize AFTER any other actions
                    if (vis)
                        inst.sizePane(pane, s, false, noAnimate); // animate resize if option passed
                });
            };
        }

        /**
         * Get the *current layout state* and return it as a hash
         *
         * @param {Object=}			inst
         * @param {(string|Array)=}	keys
         */
        ,	readState: function (inst, keys) {
            var
                data	= {}
                ,	alt		= { isClosed: 'initClosed', isHidden: 'initHidden' }
                ,	state	= inst.state
                ,	panes	= $.layout.config.allPanes
                ,	pair, pane, key, val
                ;
            if (!keys) keys = inst.options.stateManagement.stateKeys; // if called by user
            if ($.isArray(keys)) keys = keys.join(",");
            // convert keys to an array and change delimiters from '__' to '.'
            keys = keys.replace(/__/g, ".").split(',');
            // loop keys and create a data hash
            for (var i=0, n=keys.length; i < n; i++) {
                pair = keys[i].split(".");
                pane = pair[0];
                key  = pair[1];
                if ($.inArray(pane, panes) < 0) continue; // bad pane!
                val = state[ pane ][ key ];
                if (val == undefined) continue;
                if (key=="isClosed" && state[pane]["isSliding"])
                    val = true; // if sliding, then *really* isClosed
                ( data[pane] || (data[pane]={}) )[ alt[key] ? alt[key] : key ] = val;
            }
            return data;
        }

        /**
         *	Stringify a JSON hash so can save in a cookie or db-field
         */
        ,	encodeJSON: function (JSON) {
            return parse(JSON);
            function parse (h) {
                var D=[], i=0, k, v, t; // k = key, v = value
                for (k in h) {
                    v = h[k];
                    t = typeof v;
                    if (t == 'string')		// STRING - add quotes
                        v = '"'+ v +'"';
                    else if (t == 'object')	// SUB-KEY - recurse into it
                        v = parse(v);
                    D[i++] = '"'+ k +'":'+ v;
                }
                return '{'+ D.join(',') +'}';
            };
        }

        /**
         *	Convert stringified JSON back to a hash object
         *	@see		$.parseJSON(), adding in jQuery 1.4.1
         */
        ,	decodeJSON: function (str) {
            try { return $.parseJSON ? $.parseJSON(str) : window["eval"]("("+ str +")") || {}; }
            catch (e) { return {}; }
        }


        ,	_create: function (inst) {
            var _	= $.layout.state;
            //	ADD State-Management plugin methods to inst
            $.extend( inst, {
                //	readCookie - update options from cookie - returns hash of cookie data
                readCookie:		function () { return _.readCookie(inst); }
                //	deleteCookie
                ,	deleteCookie:	function () { _.deleteCookie(inst); }
                //	saveCookie - optionally pass keys-list and cookie-options (hash)
                ,	saveCookie:		function (keys, cookieOpts) { return _.saveCookie(inst, keys, cookieOpts); }
                //	loadCookie - readCookie and use to loadState() - returns hash of cookie data
                ,	loadCookie:		function () { return _.loadCookie(inst); }
                //	loadState - pass a hash of state to use to update options
                ,	loadState:		function (stateData, animate) { _.loadState(inst, stateData, animate); }
                //	readState - returns hash of current layout-state
                ,	readState:		function (keys) { return _.readState(inst, keys); }
                //	add JSON utility methods too...
                ,	encodeJSON:		_.encodeJSON
                ,	decodeJSON:		_.decodeJSON
            });

            // init state.stateData key, even if plugin is initially disabled
            inst.state.stateData = {};

            // read and load cookie-data per options
            var oS = inst.options.stateManagement;
            if (oS.enabled) {
                if (oS.autoLoad) // update the options from the cookie
                    inst.loadCookie();
                else // don't modify options - just store cookie data in state.stateData
                    inst.state.stateData = inst.readCookie();
            }
        }

        ,	_unload: function (inst) {
            var oS = inst.options.stateManagement;
            if (oS.enabled) {
                if (oS.autoSave) // save a state-cookie automatically
                    inst.saveCookie();
                else // don't save a cookie, but do store state-data in state.stateData key
                    inst.state.stateData = inst.readState();
            }
        }

    };

// add state initialization method to Layout's onCreate array of functions
    $.layout.onCreate.push( $.layout.state._create );
    $.layout.onUnload.push( $.layout.state._unload );




    /**
     * jquery.layout.buttons 1.0
     * $Date: 2011-07-16 08:00:00 (Sat, 16 July 2011) $
     *
     * Copyright (c) 2010
     *   Kevin Dalman (http://allpro.net)
     *
     * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
     * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
     *
     * @dependancies: UI Layout 1.3.0.rc30.1 or higher
     *
     * @support: http://groups.google.com/group/jquery-ui-layout
     *
     * Docs: [ to come ]
     * Tips: [ to come ]
     */

// tell Layout that the state plugin is available
    $.layout.plugins.buttons = true;

//	Add buttons options to layout.defaults
    $.layout.defaults.autoBindCustomButtons = false;
// Specify autoBindCustomButtons as a layout-option, NOT a pane-option
    $.layout.optionsMap.layout.push("autoBindCustomButtons");

    /*
     *	Button methods
     */
    $.layout.buttons = {

        /**
         * Searches for .ui-layout-button-xxx elements and auto-binds them as layout-buttons
         *
         * @see  _create()
         *
         * @param  {Object}		inst	Layout Instance object
         */
        init: function (inst) {
            var pre		= "ui-layout-button-"
                ,	layout	= inst.options.name || ""
                ,	name;
            $.each("toggle,open,close,pin,toggle-slide,open-slide".split(","), function (i, action) {
                $.each($.layout.config.borderPanes, function (ii, pane) {
                    $("."+pre+action+"-"+pane).each(function(){
                        // if button was previously 'bound', data.layoutName was set, but is blank if layout has no 'name'
                        name = $(this).data("layoutName") || $(this).attr("layoutName");
                        if (name == undefined || name === layout)
                            inst.bindButton(this, action, pane);
                    });
                });
            });
        }

        /**
         * Helper function to validate params received by addButton utilities
         *
         * Two classes are added to the element, based on the buttonClass...
         * The type of button is appended to create the 2nd className:
         *  - ui-layout-button-pin		// action btnClass
         *  - ui-layout-button-pin-west	// action btnClass + pane
         *  - ui-layout-button-toggle
         *  - ui-layout-button-open
         *  - ui-layout-button-close
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
         *
         * @return {Array.<Object>}	If both params valid, the element matching 'selector' in a jQuery wrapper - otherwise returns null
         */
        ,	get: function (inst, selector, pane, action) {
            var $E	= $(selector)
                ,	o	= inst.options
                ,	err	= o.errors.addButtonError
                ;
            if (!$E.length) { // element not found
                $.layout.msg(err +" "+ o.errors.selector +": "+ selector, true);
            }
            else if ($.inArray(pane, $.layout.config.borderPanes) < 0) { // invalid 'pane' sepecified
                $.layout.msg(err +" "+ o.errors.pane +": "+ pane, true);
                $E = $("");  // NO BUTTON
            }
            else { // VALID
                var btn = o[pane].buttonClass +"-"+ action;
                $E	.addClass( btn +" "+ btn +"-"+ pane )
                    .data("layoutName", o.name); // add layout identifier - even if blank!
            }
            return $E;
        }


        /**
         * NEW syntax for binding layout-buttons - will eventually replace addToggle, addOpen, etc.
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}			action
         * @param {string}			pane
         */
        ,	bind: function (inst, selector, action, pane) {
            var _ = $.layout.buttons;
            switch (action.toLowerCase()) {
                case "toggle":			_.addToggle	(inst, selector, pane); break;
                case "open":			_.addOpen	(inst, selector, pane); break;
                case "close":			_.addClose	(inst, selector, pane); break;
                case "pin":				_.addPin	(inst, selector, pane); break;
                case "toggle-slide":	_.addToggle	(inst, selector, pane, true); break;
                case "open-slide":		_.addOpen	(inst, selector, pane, true); break;
            }
            return inst;
        }

        /**
         * Add a custom Toggler button for a pane
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}  			pane 		Name of the pane the button is for: 'north', 'south', etc.
         * @param {boolean=}			slide 		true = slide-open, false = pin-open
         */
        ,	addToggle: function (inst, selector, pane, slide) {
            $.layout.buttons.get(inst, selector, pane, "toggle")
                .click(function(evt){
                    inst.toggle(pane, !!slide);
                    evt.stopPropagation();
                });
            return inst;
        }

        /**
         * Add a custom Open button for a pane
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}			pane 		Name of the pane the button is for: 'north', 'south', etc.
         * @param {boolean=}			slide 		true = slide-open, false = pin-open
         */
        ,	addOpen: function (inst, selector, pane, slide) {
            $.layout.buttons.get(inst, selector, pane, "open")
                .attr("title", inst.options[pane].tips.Close)
                .click(function (evt) {
                    inst.open(pane, !!slide);
                    evt.stopPropagation();
                });
            return inst;
        }

        /**
         * Add a custom Close button for a pane
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}   		pane 		Name of the pane the button is for: 'north', 'south', etc.
         */
        ,	addClose: function (inst, selector, pane) {
            $.layout.buttons.get(inst, selector, pane, "close")
                .attr("title", inst.options[pane].tips.Open)
                .click(function (evt) {
                    inst.close(pane);
                    evt.stopPropagation();
                });
            return inst;
        }

        /**
         * Add a custom Pin button for a pane
         *
         * Four classes are added to the element, based on the paneClass for the associated pane...
         * Assuming the default paneClass and the pin is 'up', these classes are added for a west-pane pin:
         *  - ui-layout-pane-pin
         *  - ui-layout-pane-west-pin
         *  - ui-layout-pane-pin-up
         *  - ui-layout-pane-west-pin-up
         *
         * @param {Object}			inst		Layout Instance object
         * @param {(string|!Object)}	selector	jQuery selector (or element) for button, eg: ".ui-layout-north .toggle-button"
         * @param {string}   		pane 		Name of the pane the pin is for: 'north', 'south', etc.
         */
        ,	addPin: function (inst, selector, pane) {
            var	_	= $.layout.buttons
                ,	$E	= _.get(inst, selector, pane, "pin");
            if ($E.length) {
                var s = inst.state[pane];
                $E.click(function (evt) {
                    _.setPinState(inst, $(this), pane, (s.isSliding || s.isClosed));
                    if (s.isSliding || s.isClosed) inst.open( pane ); // change from sliding to open
                    else inst.close( pane ); // slide-closed
                    evt.stopPropagation();
                });
                // add up/down pin attributes and classes
                _.setPinState(inst, $E, pane, (!s.isClosed && !s.isSliding));
                // add this pin to the pane data so we can 'sync it' automatically
                // PANE.pins key is an array so we can store multiple pins for each pane
                s.pins.push( selector ); // just save the selector string
            }
            return inst;
        }

        /**
         * Change the class of the pin button to make it look 'up' or 'down'
         *
         * @see  addPin(), syncPins()
         *
         * @param {Object}			inst	Layout Instance object
         * @param {Array.<Object>}	$Pin	The pin-span element in a jQuery wrapper
         * @param {string}			pane	These are the params returned to callbacks by layout()
         * @param {boolean}			doPin	true = set the pin 'down', false = set it 'up'
         */
        ,	setPinState: function (inst, $Pin, pane, doPin) {
            var updown = $Pin.attr("pin");
            if (updown && doPin === (updown=="down")) return; // already in correct state
            var
                o		= inst.options[pane]
                ,	pin		= o.buttonClass +"-pin"
                ,	side	= pin +"-"+ pane
                ,	UP		= pin +"-up "+	side +"-up"
                ,	DN		= pin +"-down "+side +"-down"
                ;
            $Pin
                .attr("pin", doPin ? "down" : "up") // logic
                .attr("title", doPin ? o.tips.Unpin : o.tips.Pin)
                .removeClass( doPin ? UP : DN )
                .addClass( doPin ? DN : UP )
            ;
        }

        /**
         * INTERNAL function to sync 'pin buttons' when pane is opened or closed
         * Unpinned means the pane is 'sliding' - ie, over-top of the adjacent panes
         *
         * @see  open(), close()
         *
         * @param {Object}			inst	Layout Instance object
         * @param {string}	pane	These are the params returned to callbacks by layout()
         * @param {boolean}	doPin	True means set the pin 'down', False means 'up'
         */
        ,	syncPinBtns: function (inst, pane, doPin) {
            // REAL METHOD IS _INSIDE_ LAYOUT - THIS IS HERE JUST FOR REFERENCE
            $.each(inst.state[pane].pins, function (i, selector) {
                $.layout.buttons.setPinState(inst, $(selector), pane, doPin);
            });
        }


        ,	_load: function (inst) {
            var	_	= $.layout.buttons;
            // ADD Button methods to Layout Instance
            // Note: sel = jQuery Selector string
            $.extend( inst, {
                bindButton:		function (sel, action, pane) { return _.bind(inst, sel, action, pane); }
                //	DEPRECATED METHODS
                ,	addToggleBtn:	function (sel, pane, slide) { return _.addToggle(inst, sel, pane, slide); }
                ,	addOpenBtn:		function (sel, pane, slide) { return _.addOpen(inst, sel, pane, slide); }
                ,	addCloseBtn:	function (sel, pane) { return _.addClose(inst, sel, pane); }
                ,	addPinBtn:		function (sel, pane) { return _.addPin(inst, sel, pane); }
            });

            // init state array to hold pin-buttons
            for (var i=0; i<4; i++) {
                var pane = $.layout.config.borderPanes[i];
                inst.state[pane].pins = [];
            }

            // auto-init buttons onLoad if option is enabled
            if ( inst.options.autoBindCustomButtons )
                _.init(inst);
        }

        ,	_unload: function (inst) {
            // TODO: unbind all buttons???
        }

    };

// add initialization method to Layout's onLoad array of functions
    $.layout.onLoad.push(  $.layout.buttons._load );
//$.layout.onUnload.push( $.layout.buttons._unload );



    /**
     * jquery.layout.browserZoom 1.0
     * $Date: 2011-12-29 08:00:00 (Thu, 29 Dec 2011) $
     *
     * Copyright (c) 2012
     *   Kevin Dalman (http://allpro.net)
     *
     * Dual licensed under the GPL (http://www.gnu.org/licenses/gpl.html)
     * and MIT (http://www.opensource.org/licenses/mit-license.php) licenses.
     *
     * @dependancies: UI Layout 1.3.0.rc30.1 or higher
     *
     * @support: http://groups.google.com/group/jquery-ui-layout
     *
     * @todo: Extend logic to handle other problematic zooming in browsers
     * @todo: Add hotkey/mousewheel bindings to _instantly_ respond to these zoom event
     */

// tell Layout that the plugin is available
    $.layout.plugins.browserZoom = true;

    $.layout.defaults.browserZoomCheckInterval = 1000;
    $.layout.optionsMap.layout.push("browserZoomCheckInterval");

    /*
     *	browserZoom methods
     */
    $.layout.browserZoom = {

        _init: function (inst) {
            // abort if browser does not need this check
            if ($.layout.browserZoom.ratio() !== false)
                $.layout.browserZoom._setTimer(inst);
        }

        ,	_setTimer: function (inst) {
            // abort if layout destroyed or browser does not need this check
            if (inst.destroyed) return;
            var o	= inst.options
                ,	s	= inst.state
            //	don't need check if inst has parentLayout, but check occassionally in case parent destroyed!
            //	MINIMUM 100ms interval, for performance
                ,	ms	= inst.hasParentLayout ?  5000 : Math.max( o.browserZoomCheckInterval, 100 )
                ;
            // set the timer
            setTimeout(function(){
                    if (inst.destroyed || !o.resizeWithWindow) return;
                    var d = $.layout.browserZoom.ratio();
                    if (d !== s.browserZoom) {
                        s.browserZoom = d;
                        inst.resizeAll();
                    }
                    // set a NEW timeout
                    $.layout.browserZoom._setTimer(inst);
                }
                ,	ms );
        }

        ,	ratio: function () {
            var w	= window
                ,	s	= screen
                ,	d	= document
                ,	dE	= d.documentElement || d.body
                ,	b	= $.layout.browser
                ,	v	= b.version
                ,	r, sW, cW
                ;
            // we can ignore all browsers that fire window.resize event onZoom
            if ((b.msie && v > 8)
                ||	!b.msie
                ) return false; // don't need to track zoom

            if (s.deviceXDPI)
                return calc(s.deviceXDPI, s.systemXDPI);
            // everything below is just for future reference!
            if (b.webkit && (r = d.body.getBoundingClientRect))
                return calc((r.left - r.right), d.body.offsetWidth);
            if (b.webkit && (sW = w.outerWidth))
                return calc(sW, w.innerWidth);
            if ((sW = s.width) && (cW = dE.clientWidth))
                return calc(sW, cW);
            return false; // no match, so cannot - or don't need to - track zoom

            function calc (x,y) { return (parseInt(x,10) / parseInt(y,10) * 100).toFixed(); }
        }

    };
// add initialization method to Layout's onLoad array of functions
    $.layout.onReady.push( $.layout.browserZoom._init );



})( jQuery );
define("ext/jquery-layout/jquery.layout", function(){});

define('modules/view/datasourcewindow',[
    "jquery"
  , "lib/util/ui"
  , "text!templates/layout.datasource.html"
  , 'ext/jquery-ui/jquery.ui'
  , "ext/jquery-layout/jquery.layout"
],

function($, ui, tplDialog) {
  return function(ctx) {
    var $dialog
//      , $tabs
      ;

    function init() {
      if($dialog) return false;
      $dialog = $(tplDialog).appendTo('body')
        .dialog({
            modal : true
          , autoOpen : true
          , resizable : false
          , width : 800
          , height : 600
          , dialogClass : "rg-el"
          , closeOnEscape : true
          , title : "import data"
          , buttons : [{
              text : "Close",
              click : function() {
                $dialog.dialog("close");
                return true;
              }
            }]
          , position : "center"
        });
//      $tabs = $dialog.find(".tabs").tabs();
      $dialog.find(".main-container").layout({
          west : {
              size : 240
            , initClosed : false
            , resizable : false
//            , spacing_open: 0
//            , spacing_closed: 0
          }
      });
      $dialog.find(".datasources").layout({
        north : {
            resizable : false
          , closable : false
          , slidable : false
          , size: 50
          , spacing_open: 0
          , spacing_closed: 0
        }
      });
      $dialog.find(".main-splitter").layout({
        north : {
            resizable : false
          , closable : false
          , slidable : false
          , size: 200
          , spacing_open: 0
          , spacing_closed: 0
        }
      });

      ctx.trigger("view.data.tree", $dialog.find(".tree"));
      ctx.trigger("view.data.toolbar-description", $dialog.find(".datasources .toolbar-description"));
      ctx.trigger("view.data.toolbar-main", $dialog.find(".datasources .toolbar-main"));
      ctx.trigger("view.data.toolbar-context", $dialog.find(".datasources .toolbar-context"));

      ctx.trigger("view.data.datasource", $dialog.find(".datasource"));
      ctx.trigger("view.data.dataviewer", $dialog.find(".dataviewer"));

      return true;
    }

    ctx.on("view.main.toolbar-context", function(el) {
      ui.button(el, {
          icon : "ui-icon-arrowthickstop-1-n",
          description : "import/manage data sources"
        }).click(function() {
          if(!init()) {
            $dialog.dialog("open");
          }
        });
    });
  };
});
define('modules/view/thememenu',[
    "jquery"
  , "config/themes"
  , "lib/util/ui"
],

function($, themes, ui) {

  function buildItems(ctx, menu, groups) {
    $.each(groups, function(key) {
      menu.append('<li class="ui-state-disabled ui-menu-item" role="presentation"><a href="#">'+key+' themes:</a></li>');
      $.each(this, function() {
        menu.append('<li data-theme="'+this.token+'" class="ui-menu-item" role="presentation"><a href="#">'+this.name+'</a></li>');
      })
    });
    menu.find("li[data-theme] a").each(function() {
      $(this).click(function() {
        var theme = $(this).parent().attr("data-theme");
        ctx.trigger("theme.change", theme);
      });
    });
  }

  return function(ctx) {
    var menu = ui.contextmenu('<div class="rg-widget settings-menu"></div>');
    buildItems(ctx, menu.find("ul:first"), themes.groups);

    ctx.on("view.main.toolbar-context", function(el) {
      ui.button(el, {
        icon : "ui-icon-gear",
        description : "change theme"
      }).click(function() {
          var pos = $(this).offset(),
            w = $(this).outerWidth(),
            h = $(this).outerHeight();
          menu.css({
            position : "absolute",
            top : (pos.top + h) + "px",
            left : (pos.left + w - menu.outerWidth()) + "px"
          }).show();
      });
    });

    ctx.on("theme.changing", function(theme) {
      menu.find('li[data-theme]').each(function() {
        if($(this).attr("data-theme") === theme) {
          $(this).addClass('ui-state-active');
        } else {
          $(this).removeClass('ui-state-active');
        }
      });
    });
  }
});
define('text!templates/layout.full.html',[],function () { return '<div class="rg-builder ui-layout-container">\n    <div class="mainbar ui-layout-north pane ui-widget-header">\n        <div class="toolbar-main"></div>\n        <div class="toolbar-context"></div>\n    </div>\n    <div class="reports ui-layout-west pane">\n        <div class="toolbar toolbar-tall ui-layout-north pane ui-widget-header">\n            <div class="toolbar-description">reports</div>\n            <div class="toolbar-main"></div>\n            <div class="toolbar-context"></div>\n        </div>\n        <div class="tree ui-layout-center pane"></div>\n    </div>\n    <div class="main ui-layout-center pane">\n        <div class="builder ui-layout-center pane">\n            <div class="toolbar ui-widget-header ui-layout-north">\n                <div class="toolbar-actions tabs-container">\n                    <div class="editor-tabs">\n                        <ul></ul>\n                    </div>\n                </div>\n                <div class="toolbar-context">\n                </div>\n            </div>\n            <div class="editor ui-layout-center pane">\n\n            </div>\n        </div>\n    </div>\n</div>';});

define('modules/view/layout',[
    "jquery"
  , "text!templates/layout.full.html"

  , 'ext/jquery-ui/jquery.ui'
  , "ext/jquery-layout/jquery.layout"
],

function($, tplLayout) {
  var toolbarMainHeight = 38,
      toolbar = {
          resizable : false
        , closable : false
        , slidable : false
        , size: 36
        , spacing_open: 0
        , spacing_closed: 0
      },
      toolbarDouble = {
          resizable : false
        , closable : false
        , slidable : false
        , size: 50
        , spacing_open: 0
        , spacing_closed: 0
      };

  return function(ctx) {
    var layouts = [],
        $container;

    function create(el, o) {
      layouts.push(el.layout(o, {
        defaults : {
            initClosed : false
          , resizable : true
          , slidable : true
        }
      }));
    }

    function resize() {
      var $parent = $container.parent();
      $container.css({
        position : "absolute",
        width : $parent.innerWidth() + "px",
        height : $parent.innerHeight() + "px"
      });
    }

    function refresh() {
      for(var i = 0; i < layouts.length; i++) {
        layouts[i].resizeAll();
      }
    }

    function themechanged() {
      if(!$container) {
        clearInterval(this.killTimer);
        killTimer = setTimeout(init, 20);
        return;
      }
      refresh();
    }

    function init(el) {
      var $el = $(el);
      $el.css({
        position : "relative",
        padding  : 0
      });

      if($el.is("body")) {
        $el.css({
          margin   : 0,
          width    : "100%",
          height   : "100%",
          overflow : "hidden",
          border   : "none"
        });
        $el.parent().css({
          height   : "100%",
          overflow : "hidden"
        });
      }
      $container = $(tplLayout);

      $el.append($container);

      resize();
      create($container, {
        north : $.extend({}, toolbar, { size : toolbarMainHeight }),
        west : {
            size : 240
          , initClosed : false
        }
      });

      create($container.find('.reports'), {
        north : toolbarDouble
      });

      create($container.find('.main'));



      create($container.find('.builder'), {
        north : toolbar
      });

      $container.addClass("ui-widget-content")
        .find(".pane")
        .addClass("ui-widget-content");
      $container.find(".ui-layout-toggler")
        .mouseenter(function() { $(this).addClass("ui-state-hover"); })
        .mouseleave(function() { $(this).removeClass("ui-state-hover"); })
        .addClass("ui-widget-header");
      $container.find(".ui-layout-resizer")
        .addClass("ui-widget-shadow");
      $container.find(".ui-layout-resizer-dragging")
        .addClass("ui-state-hover")
      ;

      // trigger events
      ctx.trigger("view.main.toolbar-main", $container.find(".mainbar .toolbar-main"));
      ctx.trigger("view.main.toolbar-context", $container.find(".mainbar .toolbar-context"));

      ctx.trigger("view.reports.tree", $container.find(".reports .tree"));
      ctx.trigger("view.reports.toolbar-description", $container.find(".reports .toolbar-description"));
      ctx.trigger("view.reports.toolbar-main", $container.find(".reports .toolbar-main"));
      ctx.trigger("view.reports.toolbar-context", $container.find(".reports .toolbar-context"));

      ctx.trigger("view.support.pane", $container.find(".main .support"));

      ctx.trigger("view.editor.pane", $container.find(".main .editor"));
      ctx.trigger("view.editor.tabs", $container.find(".builder .tabs-container"));
      ctx.trigger("view.editor.toolbar-context", $container.find(".builder .toolbar-context:first"));

      $(window).resize(resize);

      setTimeout(refresh, 100);

      var $overlay = $('<div class="overlay"></div>');
      $el.append($overlay);
      $overlay.css({
        display : "block",
        position : "absolute",
        width : $el.outerWidth() + "px",
        height : $el.outerHeight() + "px",
        backgroundColor : "rgba(50,50,50,0.75)",
        zIndex : 100000
      });
      setTimeout(function() {
        $overlay.remove();
      }, 1000);
    }

    ctx.on("view.container.ready", init);
    ctx.on("theme.changed", themechanged);
  };
});
define('modules/view/editor/tabs',[
    "jquery"
  , "lib/util/ui"
],

function($, ui) {
  return function(ctx) {
    var tabs, context;


    function init() {
      tabs.on({
        click : function(){
          var index = $("li", tabs).index($(this).parent());
//          editors.remove(index);
        }
      }, '.ui-icon-close');

      tabs.on({
        click : function() {
          var index = $("li", tabs).index($(this).parent());
//          editors.activate(index);
        }
      }, 'li a');
/*
      ui.button(context, {
        icon : "ui-icon-disk"
      });
*/
      // fake
      tabs.tabs("add", "#pg-editor-tab", "chart");
    }

    ctx.on("view.editor.tabs", function(el) {
      tabs = ui.tabs($(el), {
        tabTemplate: "<li><a href='#{href}'>#{label}</a> <span class='ui-icon ui-icon-close pg-tab-close'>Remove Tab</span></li>",
        add: function(event, ui) {
          var index = ui.index;
        }
      });
      tabs.hide();
    });
    ctx.on("view.editor.toolbar-context", function(el) {
      context = $(el);
    });
    $.when(ctx.on("view.editor.tabs"), ctx.on("view.editor.toolbar-context")).then(init);
  };
});
define('text!templates/layout.editor.html',[],function () { return '    <div class="chart-splitter ui-layout-center pane ui-layout-container">\n        <div class="chart-container ui-layout-center pane">\n\n        </div>\n        <div class="dimensions-container ui-layout-south pane ui-widget-header">\n\n        </div>\n    </div>\n    <div class="options-container ui-layout-east pane ui-widget-content">\n\n    </div>\n';});

define('modules/view/editorpane',[
    "jquery"
  , "text!templates/layout.editor.html"

  , 'ext/jquery-ui/jquery.ui'
  , "ext/jquery-layout/jquery.layout"
],

function($, tplEditor) {

  return function(ctx) {
    var map = {};
    function init(el) {
      var $layout = $(tplEditor).appendTo(el),
          $splitter = el.find(".chart-splitter"),
          $chart = el.find(".chart-container"),
          $dimensions = el.find(".dimensions-container"),
          $options = el.find(".options-container");

      el.layout({
        east : {
            size : 300
          , initClosed : false
          , resizable: false
          , closable : false
          , slidable : false
          , spacing_open : 0
        }
      });

      $splitter.layout({
        south : {
            size : 100
          , initClosed : false
          , resizable: false
          , closable : false
          , slidable : false
          , spacing_open : 0
        }
      });

     var $selectors = $('<div class="selectors pane"></div>').appendTo($dimensions);
      ctx.trigger("view.editor.chartselector", $('<div class="chartselector-container"></div>').appendTo($selectors));
      ctx.trigger("view.editor.datasourceselector", $('<div class="dataosurceselector-container"></div>').appendTo($selectors));
      ctx.trigger("view.editor.dimensions", $('<div class="pane dimensionsoptions-container"></div>').appendTo($dimensions));
      ctx.trigger("view.editor.options", $options);
      ctx.trigger("view.editor.chart", $chart);

      el.mousedown(function() { if(ReportGrid.tooltip) ReportGrid.tooltip.hide(); });
    }

    ctx.on("view.editor.pane", init);
  }
});
define('modules/view/chartselector',[
    "jquery"
  , "lib/util/ui"
  , "config/charts"
],


function($, ui, charts) {

  return function(ctx) {
    function init(el) {
      var menu = ui.selectmenu(el, {
        data : charts.list,
        labelWidth : 160,
        position : {
          menu : "left bottom",
          at : "left bottom"
        },
        format : function(item) {
          return '<span class="chart-icon icon-'+item.type+'"></span><span class="text">'+item.label+'</span>';
        }
      });
      $(menu).on("select", function(e, data) {
        ctx.trigger("chart.type.change", data.type);
      });

      ctx.on("chart.type.change", function(type) {
        menu.selectIndex(charts.map[type].index);
      });

      ctx.trigger("chart.type.change", "barchart");
    }

    ctx.on("view.editor.chartselector", init);
  }
});
define('modules/view/datasourceselector',[
    "jquery"
  , "lib/util/ui"
],


function($, ui) {

  return function(ctx) {
    var queue = [],
        items = [],
        menu;

    function dequeue() {
      while(queue.length > 0)
        add(queue.shift());
    }

    function init(el) {
      menu = ui.selectmenu(el, {
        data : [],
        selectMessage : "select the data source",
        labelWidth : 160,
        position : {
          menu : "left bottom",
          at : "left bottom"
        },
        format : function(item) {
          return '<span class="text">'+item.data.name.split("/").pop()+'</span>';
        },
        id : function(value, item) {
          return value === item.data.path;
        }
      });
      $(menu).on("select", function(e, data) {
        ctx.trigger("chart.datasource.change", data);
      });

      dequeue();

      ctx.on("data.datasource.add", add);
      ctx.on("data.datasource.remove", remove);

      ctx.off("data.datasource.add", addToQueue);
      ctx.off("data.datasource.remove", removeFromQueue);

      ctx.on("chart.datasource.change", function(datasource) {
        menu.selectValue((datasource && datasource.path) || null);
      });
    }

    function addToQueue(item) {
      queue.push(item);
    }

    function add(item) {
      items.push(item);
      menu.add({ content : item.name.split("/").pop(), data : item });
    }

    function removeFromArray(arr, item) {
      var j = -1;
      for(var i = 0; i < arr.length; i++) {
        if(arr[i].name == item.name) {
          j = -1;
          break;
        }
      }
      if(j > 0)
        arr.splice(j, 1);

    }

    function removeFromQueue(item) {
      removeFromArray(queue, item);
    }

    function remove(item) {
      removeFromArray(items, item);
      console.log("TODO: REMOVE ITEM FROM SELECTOR");
    }

    ctx.on("data.datasource.add", addToQueue);
    ctx.on("data.datasource.remove", removeFromQueue);

    ctx.on("view.editor.datasourceselector", init);
  }
});
/*! 
 * jquery.event.drag - v 2.0.0 
 * Copyright (c) 2010 Three Dub Media - http://threedubmedia.com
 * Open Source MIT License - http://threedubmedia.com/code/license
 */
;(function(f){f.fn.drag=function(b,a,d){var e=typeof b=="string"?b:"",k=f.isFunction(b)?b:f.isFunction(a)?a:null;if(e.indexOf("drag")!==0)e="drag"+e;d=(b==k?a:d)||{};return k?this.bind(e,d,k):this.trigger(e)};var i=f.event,h=i.special,c=h.drag={defaults:{which:1,distance:0,not:":input",handle:null,relative:false,drop:true,click:false},datakey:"dragdata",livekey:"livedrag",add:function(b){var a=f.data(this,c.datakey),d=b.data||{};a.related+=1;if(!a.live&&b.selector){a.live=true;i.add(this,"draginit."+ c.livekey,c.delegate)}f.each(c.defaults,function(e){if(d[e]!==undefined)a[e]=d[e]})},remove:function(){f.data(this,c.datakey).related-=1},setup:function(){if(!f.data(this,c.datakey)){var b=f.extend({related:0},c.defaults);f.data(this,c.datakey,b);i.add(this,"mousedown",c.init,b);this.attachEvent&&this.attachEvent("ondragstart",c.dontstart)}},teardown:function(){if(!f.data(this,c.datakey).related){f.removeData(this,c.datakey);i.remove(this,"mousedown",c.init);i.remove(this,"draginit",c.delegate);c.textselect(true); this.detachEvent&&this.detachEvent("ondragstart",c.dontstart)}},init:function(b){var a=b.data,d;if(!(a.which>0&&b.which!=a.which))if(!f(b.target).is(a.not))if(!(a.handle&&!f(b.target).closest(a.handle,b.currentTarget).length)){a.propagates=1;a.interactions=[c.interaction(this,a)];a.target=b.target;a.pageX=b.pageX;a.pageY=b.pageY;a.dragging=null;d=c.hijack(b,"draginit",a);if(a.propagates){if((d=c.flatten(d))&&d.length){a.interactions=[];f.each(d,function(){a.interactions.push(c.interaction(this,a))})}a.propagates= a.interactions.length;a.drop!==false&&h.drop&&h.drop.handler(b,a);c.textselect(false);i.add(document,"mousemove mouseup",c.handler,a);return false}}},interaction:function(b,a){return{drag:b,callback:new c.callback,droppable:[],offset:f(b)[a.relative?"position":"offset"]()||{top:0,left:0}}},handler:function(b){var a=b.data;switch(b.type){case !a.dragging&&"mousemove":if(Math.pow(b.pageX-a.pageX,2)+Math.pow(b.pageY-a.pageY,2)<Math.pow(a.distance,2))break;b.target=a.target;c.hijack(b,"dragstart",a); if(a.propagates)a.dragging=true;case "mousemove":if(a.dragging){c.hijack(b,"drag",a);if(a.propagates){a.drop!==false&&h.drop&&h.drop.handler(b,a);break}b.type="mouseup"}case "mouseup":i.remove(document,"mousemove mouseup",c.handler);if(a.dragging){a.drop!==false&&h.drop&&h.drop.handler(b,a);c.hijack(b,"dragend",a)}c.textselect(true);if(a.click===false&&a.dragging){jQuery.event.triggered=true;setTimeout(function(){jQuery.event.triggered=false},20);a.dragging=false}break}},delegate:function(b){var a= [],d,e=f.data(this,"events")||{};f.each(e.live||[],function(k,j){if(j.preType.indexOf("drag")===0)if(d=f(b.target).closest(j.selector,b.currentTarget)[0]){i.add(d,j.origType+"."+c.livekey,j.origHandler,j.data);f.inArray(d,a)<0&&a.push(d)}});if(!a.length)return false;return f(a).bind("dragend."+c.livekey,function(){i.remove(this,"."+c.livekey)})},hijack:function(b,a,d,e,k){if(d){var j={event:b.originalEvent,type:b.type},n=a.indexOf("drop")?"drag":"drop",l,o=e||0,g,m;e=!isNaN(e)?e:d.interactions.length; b.type=a;b.originalEvent=null;d.results=[];do if(g=d.interactions[o])if(!(a!=="dragend"&&g.cancelled)){m=c.properties(b,d,g);g.results=[];f(k||g[n]||d.droppable).each(function(q,p){l=(m.target=p)?i.handle.call(p,b,m):null;if(l===false){if(n=="drag"){g.cancelled=true;d.propagates-=1}if(a=="drop")g[n][q]=null}else if(a=="dropinit")g.droppable.push(c.element(l)||p);if(a=="dragstart")g.proxy=f(c.element(l)||g.drag)[0];g.results.push(l);delete b.result;if(a!=="dropinit")return l});d.results[o]=c.flatten(g.results); if(a=="dropinit")g.droppable=c.flatten(g.droppable);a=="dragstart"&&!g.cancelled&&m.update()}while(++o<e);b.type=j.type;b.originalEvent=j.event;return c.flatten(d.results)}},properties:function(b,a,d){var e=d.callback;e.drag=d.drag;e.proxy=d.proxy||d.drag;e.startX=a.pageX;e.startY=a.pageY;e.deltaX=b.pageX-a.pageX;e.deltaY=b.pageY-a.pageY;e.originalX=d.offset.left;e.originalY=d.offset.top;e.offsetX=b.pageX-(a.pageX-e.originalX);e.offsetY=b.pageY-(a.pageY-e.originalY);e.drop=c.flatten((d.drop||[]).slice()); e.available=c.flatten((d.droppable||[]).slice());return e},element:function(b){if(b&&(b.jquery||b.nodeType==1))return b},flatten:function(b){return f.map(b,function(a){return a&&a.jquery?f.makeArray(a):a&&a.length?c.flatten(a):a})},textselect:function(b){f(document)[b?"unbind":"bind"]("selectstart",c.dontstart).attr("unselectable",b?"off":"on").css("MozUserSelect",b?"":"none")},dontstart:function(){return false},callback:function(){}};c.callback.prototype={update:function(){h.drop&&this.available.length&& f.each(this.available,function(b){h.drop.locate(this,b)})}};h.draginit=h.dragstart=h.dragend=c})(jQuery);
define("ext/jquery-slickgrid/jquery.event.drag-2.0.min", function(){});

/***
 * Contains core SlickGrid classes.
 * @module Core
 * @namespace Slick
 */

(function ($) {
  // register namespace
  $.extend(true, window, {
    "Slick": {
      "Event": Event,
      "EventData": EventData,
      "EventHandler": EventHandler,
      "Range": Range,
      "NonDataRow": NonDataItem,
      "Group": Group,
      "GroupTotals": GroupTotals,
      "EditorLock": EditorLock,

      /***
       * A global singleton editor lock.
       * @class GlobalEditorLock
       * @static
       * @constructor
       */
      "GlobalEditorLock": new EditorLock()
    }
  });

  /***
   * An event object for passing data to event handlers and letting them control propagation.
   * <p>This is pretty much identical to how W3C and jQuery implement events.</p>
   * @class EventData
   * @constructor
   */
  function EventData() {
    var isPropagationStopped = false;
    var isImmediatePropagationStopped = false;

    /***
     * Stops event from propagating up the DOM tree.
     * @method stopPropagation
     */
    this.stopPropagation = function () {
      isPropagationStopped = true;
    };

    /***
     * Returns whether stopPropagation was called on this event object.
     * @method isPropagationStopped
     * @return {Boolean}
     */
    this.isPropagationStopped = function () {
      return isPropagationStopped;
    };

    /***
     * Prevents the rest of the handlers from being executed.
     * @method stopImmediatePropagation
     */
    this.stopImmediatePropagation = function () {
      isImmediatePropagationStopped = true;
    };

    /***
     * Returns whether stopImmediatePropagation was called on this event object.\
     * @method isImmediatePropagationStopped
     * @return {Boolean}
     */
    this.isImmediatePropagationStopped = function () {
      return isImmediatePropagationStopped;
    }
  }

  /***
   * A simple publisher-subscriber implementation.
   * @class Event
   * @constructor
   */
  function Event() {
    var handlers = [];

    /***
     * Adds an event handler to be called when the event is fired.
     * <p>Event handler will receive two arguments - an <code>EventData</code> and the <code>data</code>
     * object the event was fired with.<p>
     * @method subscribe
     * @param fn {Function} Event handler.
     */
    this.subscribe = function (fn) {
      handlers.push(fn);
    };

    /***
     * Removes an event handler added with <code>subscribe(fn)</code>.
     * @method unsubscribe
     * @param fn {Function} Event handler to be removed.
     */
    this.unsubscribe = function (fn) {
      for (var i = handlers.length - 1; i >= 0; i--) {
        if (handlers[i] === fn) {
          handlers.splice(i, 1);
        }
      }
    };

    /***
     * Fires an event notifying all subscribers.
     * @method notify
     * @param args {Object} Additional data object to be passed to all handlers.
     * @param e {EventData}
     *      Optional.
     *      An <code>EventData</code> object to be passed to all handlers.
     *      For DOM events, an existing W3C/jQuery event object can be passed in.
     * @param scope {Object}
     *      Optional.
     *      The scope ("this") within which the handler will be executed.
     *      If not specified, the scope will be set to the <code>Event</code> instance.
     */
    this.notify = function (args, e, scope) {
      e = e || new EventData();
      scope = scope || this;

      var returnValue;
      for (var i = 0; i < handlers.length && !(e.isPropagationStopped() || e.isImmediatePropagationStopped()); i++) {
        returnValue = handlers[i].call(scope, e, args);
      }

      return returnValue;
    };
  }

  function EventHandler() {
    var handlers = [];

    this.subscribe = function (event, handler) {
      handlers.push({
        event: event,
        handler: handler
      });
      event.subscribe(handler);

      return this;  // allow chaining
    };

    this.unsubscribe = function (event, handler) {
      var i = handlers.length;
      while (i--) {
        if (handlers[i].event === event &&
            handlers[i].handler === handler) {
          handlers.splice(i, 1);
          event.unsubscribe(handler);
          return;
        }
      }

      return this;  // allow chaining
    };

    this.unsubscribeAll = function () {
      var i = handlers.length;
      while (i--) {
        handlers[i].event.unsubscribe(handlers[i].handler);
      }
      handlers = [];

      return this;  // allow chaining
    }
  }

  /***
   * A structure containing a range of cells.
   * @class Range
   * @constructor
   * @param fromRow {Integer} Starting row.
   * @param fromCell {Integer} Starting cell.
   * @param toRow {Integer} Optional. Ending row. Defaults to <code>fromRow</code>.
   * @param toCell {Integer} Optional. Ending cell. Defaults to <code>fromCell</code>.
   */
  function Range(fromRow, fromCell, toRow, toCell) {
    if (toRow === undefined && toCell === undefined) {
      toRow = fromRow;
      toCell = fromCell;
    }

    /***
     * @property fromRow
     * @type {Integer}
     */
    this.fromRow = Math.min(fromRow, toRow);

    /***
     * @property fromCell
     * @type {Integer}
     */
    this.fromCell = Math.min(fromCell, toCell);

    /***
     * @property toRow
     * @type {Integer}
     */
    this.toRow = Math.max(fromRow, toRow);

    /***
     * @property toCell
     * @type {Integer}
     */
    this.toCell = Math.max(fromCell, toCell);

    /***
     * Returns whether a range represents a single row.
     * @method isSingleRow
     * @return {Boolean}
     */
    this.isSingleRow = function () {
      return this.fromRow == this.toRow;
    };

    /***
     * Returns whether a range represents a single cell.
     * @method isSingleCell
     * @return {Boolean}
     */
    this.isSingleCell = function () {
      return this.fromRow == this.toRow && this.fromCell == this.toCell;
    };

    /***
     * Returns whether a range contains a given cell.
     * @method contains
     * @param row {Integer}
     * @param cell {Integer}
     * @return {Boolean}
     */
    this.contains = function (row, cell) {
      return row >= this.fromRow && row <= this.toRow &&
          cell >= this.fromCell && cell <= this.toCell;
    };

    /***
     * Returns a readable representation of a range.
     * @method toString
     * @return {String}
     */
    this.toString = function () {
      if (this.isSingleCell()) {
        return "(" + this.fromRow + ":" + this.fromCell + ")";
      }
      else {
        return "(" + this.fromRow + ":" + this.fromCell + " - " + this.toRow + ":" + this.toCell + ")";
      }
    }
  }


  /***
   * A base class that all special / non-data rows (like Group and GroupTotals) derive from.
   * @class NonDataItem
   * @constructor
   */
  function NonDataItem() {
    this.__nonDataRow = true;
  }


  /***
   * Information about a group of rows.
   * @class Group
   * @extends Slick.NonDataItem
   * @constructor
   */
  function Group() {
    this.__group = true;
    this.__updated = false;

    /***
     * Number of rows in the group.
     * @property count
     * @type {Integer}
     */
    this.count = 0;

    /***
     * Grouping value.
     * @property value
     * @type {Object}
     */
    this.value = null;

    /***
     * Formatted display value of the group.
     * @property title
     * @type {String}
     */
    this.title = null;

    /***
     * Whether a group is collapsed.
     * @property collapsed
     * @type {Boolean}
     */
    this.collapsed = false;

    /***
     * GroupTotals, if any.
     * @property totals
     * @type {GroupTotals}
     */
    this.totals = null;
  }

  Group.prototype = new NonDataItem();

  /***
   * Compares two Group instances.
   * @method equals
   * @return {Boolean}
   * @param group {Group} Group instance to compare to.
   */
  Group.prototype.equals = function (group) {
    return this.value === group.value &&
        this.count === group.count &&
        this.collapsed === group.collapsed;
  };

  /***
   * Information about group totals.
   * An instance of GroupTotals will be created for each totals row and passed to the aggregators
   * so that they can store arbitrary data in it.  That data can later be accessed by group totals
   * formatters during the display.
   * @class GroupTotals
   * @extends Slick.NonDataItem
   * @constructor
   */
  function GroupTotals() {
    this.__groupTotals = true;

    /***
     * Parent Group.
     * @param group
     * @type {Group}
     */
    this.group = null;
  }

  GroupTotals.prototype = new NonDataItem();

  /***
   * A locking helper to track the active edit controller and ensure that only a single controller
   * can be active at a time.  This prevents a whole class of state and validation synchronization
   * issues.  An edit controller (such as SlickGrid) can query if an active edit is in progress
   * and attempt a commit or cancel before proceeding.
   * @class EditorLock
   * @constructor
   */
  function EditorLock() {
    var activeEditController = null;

    /***
     * Returns true if a specified edit controller is active (has the edit lock).
     * If the parameter is not specified, returns true if any edit controller is active.
     * @method isActive
     * @param editController {EditController}
     * @return {Boolean}
     */
    this.isActive = function (editController) {
      return (editController ? activeEditController === editController : activeEditController !== null);
    };

    /***
     * Sets the specified edit controller as the active edit controller (acquire edit lock).
     * If another edit controller is already active, and exception will be thrown.
     * @method activate
     * @param editController {EditController} edit controller acquiring the lock
     */
    this.activate = function (editController) {
      if (editController === activeEditController) { // already activated?
        return;
      }
      if (activeEditController !== null) {
        throw "SlickGrid.EditorLock.activate: an editController is still active, can't activate another editController";
      }
      if (!editController.commitCurrentEdit) {
        throw "SlickGrid.EditorLock.activate: editController must implement .commitCurrentEdit()";
      }
      if (!editController.cancelCurrentEdit) {
        throw "SlickGrid.EditorLock.activate: editController must implement .cancelCurrentEdit()";
      }
      activeEditController = editController;
    };

    /***
     * Unsets the specified edit controller as the active edit controller (release edit lock).
     * If the specified edit controller is not the active one, an exception will be thrown.
     * @method deactivate
     * @param editController {EditController} edit controller releasing the lock
     */
    this.deactivate = function (editController) {
      if (activeEditController !== editController) {
        throw "SlickGrid.EditorLock.deactivate: specified editController is not the currently active one";
      }
      activeEditController = null;
    };

    /***
     * Attempts to commit the current edit by calling "commitCurrentEdit" method on the active edit
     * controller and returns whether the commit attempt was successful (commit may fail due to validation
     * errors, etc.).  Edit controller's "commitCurrentEdit" must return true if the commit has succeeded
     * and false otherwise.  If no edit controller is active, returns true.
     * @method commitCurrentEdit
     * @return {Boolean}
     */
    this.commitCurrentEdit = function () {
      return (activeEditController ? activeEditController.commitCurrentEdit() : true);
    };

    /***
     * Attempts to cancel the current edit by calling "cancelCurrentEdit" method on the active edit
     * controller and returns whether the edit was successfully cancelled.  If no edit controller is
     * active, returns true.
     * @method cancelCurrentEdit
     * @return {Boolean}
     */
    this.cancelCurrentEdit = function cancelCurrentEdit() {
      return (activeEditController ? activeEditController.cancelCurrentEdit() : true);
    };
  }
})(jQuery);



define("ext/jquery-slickgrid/slick.core", function(){});

/**
 * @license
 * (c) 2009-2012 Michael Leibman
 * michael{dot}leibman{at}gmail{dot}com
 * http://github.com/mleibman/slickgrid
 *
 * Distributed under MIT license.
 * All rights reserved.
 *
 * SlickGrid v2.1
 *
 * NOTES:
 *     Cell/row DOM manipulations are done directly bypassing jQuery's DOM manipulation methods.
 *     This increases the speed dramatically, but can only be done safely because there are no event handlers
 *     or data associated with any cell/row DOM nodes.  Cell editors must make sure they implement .destroy()
 *     and do proper cleanup.
 */

// make sure required JavaScript modules are loaded
if (typeof jQuery === "undefined") {
  throw "SlickGrid requires jquery module to be loaded";
}
if (!jQuery.fn.drag) {
  throw "SlickGrid requires jquery.event.drag module to be loaded";
}
if (typeof Slick === "undefined") {
  throw "slick.core.js not loaded";
}


(function ($) {
  // Slick.Grid
  $.extend(true, window, {
    Slick: {
      Grid: SlickGrid
    }
  });

  // shared across all grids on the page
  var scrollbarDimensions;
  var maxSupportedCssHeight;  // browser's breaking point

  //////////////////////////////////////////////////////////////////////////////////////////////
  // SlickGrid class implementation (available as Slick.Grid)

  /**
   * Creates a new instance of the grid.
   * @class SlickGrid
   * @constructor
   * @param {Node}              container   Container node to create the grid in.
   * @param {Array,Object}      data        An array of objects for databinding.
   * @param {Array}             columns     An array of column definitions.
   * @param {Object}            options     Grid options.
   **/
  function SlickGrid(container, data, columns, options) {
    // settings
    var defaults = {
      explicitInitialization: false,
      rowHeight: 25,
      defaultColumnWidth: 80,
      enableAddRow: false,
      leaveSpaceForNewRows: false,
      editable: false,
      autoEdit: true,
      enableCellNavigation: true,
      enableColumnReorder: true,
      asyncEditorLoading: false,
      asyncEditorLoadDelay: 100,
      forceFitColumns: false,
      enableAsyncPostRender: false,
      asyncPostRenderDelay: 50,
      autoHeight: false,
      editorLock: Slick.GlobalEditorLock,
      showHeaderRow: false,
      headerRowHeight: 25,
      showTopPanel: false,
      topPanelHeight: 25,
      formatterFactory: null,
      editorFactory: null,
      cellFlashingCssClass: "flashing",
      selectedCellCssClass: "selected",
      multiSelect: true,
      enableTextSelectionOnCells: false,
      dataItemColumnValueExtractor: null,
      fullWidthRows: false,
      multiColumnSort: false,
      defaultFormatter: defaultFormatter
    };

    var columnDefaults = {
      name: "",
      resizable: true,
      sortable: false,
      minWidth: 30,
      rerenderOnResize: false,
      headerCssClass: null
    };

    // scroller
    var th;   // virtual height
    var h;    // real scrollable height
    var ph;   // page height
    var n;    // number of pages
    var cj;   // "jumpiness" coefficient

    var page = 0;       // current page
    var offset = 0;     // current page offset
    var vScrollDir = 1;

    // private
    var initialized = false;
    var $container;
    var uid = "slickgrid_" + Math.round(1000000 * Math.random());
    var self = this;
    var $focusSink;
    var $headerScroller;
    var $headers;
    var $headerRow, $headerRowScroller;
    var $topPanelScroller;
    var $topPanel;
    var $viewport;
    var $canvas;
    var $style;
    var stylesheet, columnCssRulesL, columnCssRulesR;
    var viewportH, viewportW;
    var canvasWidth;
    var viewportHasHScroll, viewportHasVScroll;
    var headerColumnWidthDiff = 0, headerColumnHeightDiff = 0, // border+padding
        cellWidthDiff = 0, cellHeightDiff = 0;
    var absoluteColumnMinWidth;
    var numberOfRows = 0;

    var activePosX;
    var activeRow, activeCell;
    var activeCellNode = null;
    var currentEditor = null;
    var serializedEditorValue;
    var editController;

    var rowsCache = {};
    var renderedRows = 0;
    var numVisibleRows;
    var prevScrollTop = 0;
    var scrollTop = 0;
    var lastRenderedScrollTop = 0;
    var lastRenderedScrollLeft = 0;
    var prevScrollLeft = 0;
    var scrollLeft = 0;

    var selectionModel;
    var selectedRows = [];

    var plugins = [];
    var cellCssClasses = {};

    var columnsById = {};
    var sortColumns = [];
    var columnPosLeft = [];
    var columnPosRight = [];


    // async call handles
    var h_editorLoader = null;
    var h_render = null;
    var h_postrender = null;
    var postProcessedRows = {};
    var postProcessToRow = null;
    var postProcessFromRow = null;

    // perf counters
    var counter_rows_rendered = 0;
    var counter_rows_removed = 0;


    //////////////////////////////////////////////////////////////////////////////////////////////
    // Initialization

    function init() {
      $container = $(container);
      if ($container.length < 1) {
        throw new Error("SlickGrid requires a valid container, " + container + " does not exist in the DOM.");
      }

      // calculate these only once and share between grid instances
      maxSupportedCssHeight = maxSupportedCssHeight || getMaxSupportedCssHeight();
      scrollbarDimensions = scrollbarDimensions || measureScrollbar();

      options = $.extend({}, defaults, options);
      columnDefaults.width = options.defaultColumnWidth;

      columnsById = {};
      for (var i = 0; i < columns.length; i++) {
        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);
        columnsById[m.id] = i;
      }

      // validate loaded JavaScript modules against requested options
      if (options.enableColumnReorder && !$.fn.sortable) {
        throw new Error("SlickGrid's 'enableColumnReorder = true' option requires jquery-ui.sortable module to be loaded");
      }

      editController = {
        "commitCurrentEdit": commitCurrentEdit,
        "cancelCurrentEdit": cancelCurrentEdit
      };

      $container
          .empty()
          .css("overflow", "hidden")
          .css("outline", 0)
          .addClass(uid)
          .addClass("ui-widget");

      // set up a positioning container if needed
      if (!/relative|absolute|fixed/.test($container.css("position"))) {
        $container.css("position", "relative");
      }

      $focusSink = $("<div tabIndex='0' hideFocus style='position:fixed;width:0;height:0;top:0;left:0;outline:0;'></div>").appendTo($container);

      $headerScroller = $("<div class='slick-header ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
      $headers = $("<div class='slick-header-columns' style='left:-1000px' />").appendTo($headerScroller);
      $headers.width(getHeadersWidth());

      $headerRowScroller = $("<div class='slick-headerrow ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
      $headerRow = $("<div class='slick-headerrow-columns' />").appendTo($headerRowScroller);

      $topPanelScroller = $("<div class='slick-top-panel-scroller ui-state-default' style='overflow:hidden;position:relative;' />").appendTo($container);
      $topPanel = $("<div class='slick-top-panel' style='width:10000px' />").appendTo($topPanelScroller);

      if (!options.showTopPanel) {
        $topPanelScroller.hide();
      }

      if (!options.showHeaderRow) {
        $headerRowScroller.hide();
      }

      $viewport = $("<div class='slick-viewport' style='width:100%;overflow:auto;outline:0;position:relative;;'>").appendTo($container);
      $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto");

      $canvas = $("<div class='grid-canvas' />").appendTo($viewport);

      if (!options.explicitInitialization) {
        finishInitialization();
      }
    }

    function finishInitialization() {
      if (!initialized) {
        initialized = true;

        viewportW = parseFloat($.css($container[0], "width", true));

        // header columns and cells may have different padding/border skewing width calculations (box-sizing, hello?)
        // calculate the diff so we can set consistent sizes
        measureCellPaddingAndBorder();

        // for usability reasons, all text selection in SlickGrid is disabled
        // with the exception of input and textarea elements (selection must
        // be enabled there so that editors work as expected); note that
        // selection in grid cells (grid body) is already unavailable in
        // all browsers except IE
        disableSelection($headers); // disable all text selection in header (including input and textarea)

        if (!options.enableTextSelectionOnCells) {
          // disable text selection in grid cells except in input and textarea elements
          // (this is IE-specific, because selectstart event will only fire in IE)
          $viewport.bind("selectstart.ui", function (event) {
            return $(event.target).is("input,textarea");
          });
        }

        updateColumnCaches();
        createColumnHeaders();
        setupColumnSort();
        createCssRules();
        resizeCanvas();
        bindAncestorScrollEvents();

        $container
            .bind("resize.slickgrid", resizeCanvas);
        $viewport
            .bind("scroll.slickgrid", handleScroll);
        $headerScroller
            .bind("contextmenu.slickgrid", handleHeaderContextMenu)
            .bind("click.slickgrid", handleHeaderClick)
            .delegate(".slick-header-column", "mouseenter", handleHeaderMouseEnter)
            .delegate(".slick-header-column", "mouseleave", handleHeaderMouseLeave);
        $focusSink
            .bind("keydown.slickgrid", handleKeyDown);
        $canvas
            .bind("keydown.slickgrid", handleKeyDown)
            .bind("click.slickgrid", handleClick)
            .bind("dblclick.slickgrid", handleDblClick)
            .bind("contextmenu.slickgrid", handleContextMenu)
            .bind("draginit", handleDragInit)
            .bind("dragstart", handleDragStart)
            .bind("drag", handleDrag)
            .bind("dragend", handleDragEnd)
            .delegate(".slick-cell", "mouseenter", handleMouseEnter)
            .delegate(".slick-cell", "mouseleave", handleMouseLeave);
      }
    }

    function registerPlugin(plugin) {
      plugins.unshift(plugin);
      plugin.init(self);
    }

    function unregisterPlugin(plugin) {
      for (var i = plugins.length; i >= 0; i--) {
        if (plugins[i] === plugin) {
          if (plugins[i].destroy) {
            plugins[i].destroy();
          }
          plugins.splice(i, 1);
          break;
        }
      }
    }

    function setSelectionModel(model) {
      if (selectionModel) {
        selectionModel.onSelectedRangesChanged.unsubscribe(handleSelectedRangesChanged);
        if (selectionModel.destroy) {
          selectionModel.destroy();
        }
      }

      selectionModel = model;
      if (selectionModel) {
        selectionModel.init(self);
        selectionModel.onSelectedRangesChanged.subscribe(handleSelectedRangesChanged);
      }
    }

    function getSelectionModel() {
      return selectionModel;
    }

    function getCanvasNode() {
      return $canvas[0];
    }

    function measureScrollbar() {
      var $c = $("<div style='position:absolute; top:-10000px; left:-10000px; width:100px; height:100px; overflow:scroll;'></div>").appendTo("body");
      var dim = {
        width: $c.width() - $c[0].clientWidth,
        height: $c.height() - $c[0].clientHeight
      };
      $c.remove();
      return dim;
    }

    function getHeadersWidth() {
      var headersWidth = 0;
      for (var i = 0, ii = columns.length; i < ii; i++) {
        var width = columns[i].width;
        headersWidth += width;
      }
      headersWidth += scrollbarDimensions.width;
      return Math.max(headersWidth, viewportW) + 1000;
    }

    function getCanvasWidth() {
      var availableWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;
      var rowWidth = 0;
      var i = columns.length;
      while (i--) {
        rowWidth += columns[i].width;
      }
      return options.fullWidthRows ? Math.max(rowWidth, availableWidth) : rowWidth;
    }

    function updateCanvasWidth(forceColumnWidthsUpdate) {
      var oldCanvasWidth = canvasWidth;
      canvasWidth = getCanvasWidth();

      if (canvasWidth != oldCanvasWidth) {
        $canvas.width(canvasWidth);
        $headerRow.width(canvasWidth);
        $headers.width(getHeadersWidth());
        viewportHasHScroll = (canvasWidth > viewportW - scrollbarDimensions.width);
      }

      if (canvasWidth != oldCanvasWidth || forceColumnWidthsUpdate) {
        applyColumnWidths();
      }
    }

    function disableSelection($target) {
      if ($target && $target.jquery) {
        $target
            .attr("unselectable", "on")
            .css("MozUserSelect", "none")
            .bind("selectstart.ui", function () {
              return false;
            }); // from jquery:ui.core.js 1.7.2
      }
    }

    function getMaxSupportedCssHeight() {
      var supportedHeight = 1000000;
      // FF reports the height back but still renders blank after ~6M px
      var testUpTo = ($.browser.mozilla) ? 6000000 : 1000000000;
      var div = $("<div style='display:none' />").appendTo(document.body);

      while (true) {
        var test = supportedHeight * 2;
        div.css("height", test);
        if (test > testUpTo || div.height() !== test) {
          break;
        } else {
          supportedHeight = test;
        }
      }

      div.remove();
      return supportedHeight;
    }

    // TODO:  this is static.  need to handle page mutation.
    function bindAncestorScrollEvents() {
      var elem = $canvas[0];
      while ((elem = elem.parentNode) != document.body && elem != null) {
        // bind to scroll containers only
        if (elem == $viewport[0] || elem.scrollWidth != elem.clientWidth || elem.scrollHeight != elem.clientHeight) {
          $(elem).bind("scroll.slickgrid", handleActiveCellPositionChange);
        }
      }
    }

    function unbindAncestorScrollEvents() {
      $canvas.parents().unbind("scroll.slickgrid");
    }

    function updateColumnHeader(columnId, title, toolTip) {
      if (!initialized) { return; }
      var idx = getColumnIndex(columnId);
      var columnDef = columns[idx];
      var $header = $headers.children().eq(idx);
      if ($header) {
        if (title !== undefined) {
          columns[idx].name = title;
        }
        if (toolTip !== undefined) {
          columns[idx].toolTip = toolTip;
        }

        trigger(self.onBeforeHeaderDestroy, {
          "headerNode": $header[0],
          "column": columnDef
        });

        $header
            .attr("title", toolTip || "")
            .children().eq(0).html(title);

        trigger(self.onHeaderRendered, {
          "headerNode": $header[0],
          "column": columnDef
        });
      }
    }

    function getHeaderRow() {
      return $headerRow[0];
    }

    function getHeaderRowColumn(columnId) {
      var idx = getColumnIndex(columnId);
      var $header = $headerRow.children().eq(idx);
      return $header && $header[0];
    }

    function createColumnHeaders() {
      function hoverBegin() {
        $(this).addClass("ui-state-hover");
      }

      function hoverEnd() {
        $(this).removeClass("ui-state-hover");
      }

      $headers.find(".slick-header-column")
        .each(function() {
          var columnDef = $(this).data("column");
          if (columnDef) {
            trigger(self.onBeforeHeaderDestroy, {
              "headerNode": this,
              "column": columnDef
            });
          }
        });

      $headers.empty();
      $headers.width(getHeadersWidth());
      $headerRow.empty();

      for (var i = 0; i < columns.length; i++) {
        var m = columns[i];

        var header = $("<div class='ui-state-default slick-header-column' id='" + uid + m.id + "' />")
            .html("<span class='slick-column-name'>" + m.name + "</span>")
            .width(m.width - headerColumnWidthDiff)
            .attr("title", m.toolTip || "")
            .data("column", m)
            .addClass(m.headerCssClass || "")
            .appendTo($headers);

        if (options.enableColumnReorder || m.sortable) {
          header.hover(hoverBegin, hoverEnd);
        }

        if (m.sortable) {
          header.append("<span class='slick-sort-indicator' />");
        }

        trigger(self.onHeaderRendered, {
          "headerNode": header[0],
          "column": m
        });

        if (options.showHeaderRow) {
          $("<div class='ui-state-default slick-headerrow-column l" + i + " r" + i + "'></div>")
              .appendTo($headerRow);
        }
      }

      if (options.showHeaderRow) {
        // add a spacer to let the container scroll beyond the header row columns width
        $("<div style='display:block;height:1px;width:10000px;position:absolute;top:0;left:0;'></div>")
            .appendTo($headerRowScroller);
      }

      setSortColumns(sortColumns);
      setupColumnResize();
      if (options.enableColumnReorder) {
        setupColumnReorder();
      }
    }

    function setupColumnSort() {
      $headers.click(function (e) {
        // temporary workaround for a bug in jQuery 1.7.1 (http://bugs.jquery.com/ticket/11328)
        e.metaKey = e.metaKey || e.ctrlKey;

        if ($(e.target).hasClass("slick-resizable-handle")) {
          return;
        }

        var $col = $(e.target).closest(".slick-header-column");
        if (!$col.length) {
          return;
        }

        var column = $col.data("column");
        if (column.sortable) {
          if (!getEditorLock().commitCurrentEdit()) {
            return;
          }

          var sortOpts = null;
          var i = 0;
          for (; i < sortColumns.length; i++) {
            if (sortColumns[i].columnId == column.id) {
              sortOpts = sortColumns[i];
              sortOpts.sortAsc = !sortOpts.sortAsc;
              break;
            }
          }

          if (e.metaKey && options.multiColumnSort) {
            if (sortOpts) {
              sortColumns.splice(i, 1);
            }
          }
          else {
            if ((!e.shiftKey && !e.metaKey) || !options.multiColumnSort) {
              sortColumns = [];
            }

            if (!sortOpts) {
              sortOpts = { columnId: column.id, sortAsc: true };
              sortColumns.push(sortOpts);
            } else if (sortColumns.length == 0) {
              sortColumns.push(sortOpts);
            }
          }

          setSortColumns(sortColumns);

          if (!options.multiColumnSort) {
            trigger(self.onSort, {
              multiColumnSort: false,
              sortCol: column,
              sortAsc: sortOpts.sortAsc}, e);
          } else {
            trigger(self.onSort, {
              multiColumnSort: true,
              sortCols: $.map(sortColumns, function(col) {
                return {sortCol: columns[getColumnIndex(col.columnId)], sortAsc: col.sortAsc };
              })}, e);
          }
        }
      });
    }

    function setupColumnReorder() {
      $headers.sortable({
        containment: "parent",
        axis: "x",
        cursor: "default",
        tolerance: "intersection",
        helper: "clone",
        placeholder: "slick-sortable-placeholder ui-state-default slick-header-column",
        forcePlaceholderSize: true,
        start: function (e, ui) {
          $(ui.helper).addClass("slick-header-column-active");
        },
        beforeStop: function (e, ui) {
          $(ui.helper).removeClass("slick-header-column-active");
        },
        stop: function (e) {
          if (!getEditorLock().commitCurrentEdit()) {
            $(this).sortable("cancel");
            return;
          }

          var reorderedIds = $headers.sortable("toArray");
          var reorderedColumns = [];
          for (var i = 0; i < reorderedIds.length; i++) {
            reorderedColumns.push(columns[getColumnIndex(reorderedIds[i].replace(uid, ""))]);
          }
          setColumns(reorderedColumns);

          trigger(self.onColumnsReordered, {});
          e.stopPropagation();
          setupColumnResize();
        }
      });
    }

    function setupColumnResize() {
      var $col, j, c, pageX, columnElements, minPageX, maxPageX, firstResizable, lastResizable;
      columnElements = $headers.children();
      columnElements.find(".slick-resizable-handle").remove();
      columnElements.each(function (i, e) {
        if (columns[i].resizable) {
          if (firstResizable === undefined) {
            firstResizable = i;
          }
          lastResizable = i;
        }
      });
      if (firstResizable === undefined) {
        return;
      }
      columnElements.each(function (i, e) {
        if (i < firstResizable || (options.forceFitColumns && i >= lastResizable)) {
          return;
        }
        $col = $(e);
        $("<div class='slick-resizable-handle' />")
            .appendTo(e)
            .bind("dragstart", function (e, dd) {
              if (!getEditorLock().commitCurrentEdit()) {
                return false;
              }
              pageX = e.pageX;
              $(this).parent().addClass("slick-header-column-active");
              var shrinkLeewayOnRight = null, stretchLeewayOnRight = null;
              // lock each column's width option to current width
              columnElements.each(function (i, e) {
                columns[i].previousWidth = $(e).outerWidth();
              });
              if (options.forceFitColumns) {
                shrinkLeewayOnRight = 0;
                stretchLeewayOnRight = 0;
                // colums on right affect maxPageX/minPageX
                for (j = i + 1; j < columnElements.length; j++) {
                  c = columns[j];
                  if (c.resizable) {
                    if (stretchLeewayOnRight !== null) {
                      if (c.maxWidth) {
                        stretchLeewayOnRight += c.maxWidth - c.previousWidth;
                      } else {
                        stretchLeewayOnRight = null;
                      }
                    }
                    shrinkLeewayOnRight += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                  }
                }
              }
              var shrinkLeewayOnLeft = 0, stretchLeewayOnLeft = 0;
              for (j = 0; j <= i; j++) {
                // columns on left only affect minPageX
                c = columns[j];
                if (c.resizable) {
                  if (stretchLeewayOnLeft !== null) {
                    if (c.maxWidth) {
                      stretchLeewayOnLeft += c.maxWidth - c.previousWidth;
                    } else {
                      stretchLeewayOnLeft = null;
                    }
                  }
                  shrinkLeewayOnLeft += c.previousWidth - Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                }
              }
              if (shrinkLeewayOnRight === null) {
                shrinkLeewayOnRight = 100000;
              }
              if (shrinkLeewayOnLeft === null) {
                shrinkLeewayOnLeft = 100000;
              }
              if (stretchLeewayOnRight === null) {
                stretchLeewayOnRight = 100000;
              }
              if (stretchLeewayOnLeft === null) {
                stretchLeewayOnLeft = 100000;
              }
              maxPageX = pageX + Math.min(shrinkLeewayOnRight, stretchLeewayOnLeft);
              minPageX = pageX - Math.min(shrinkLeewayOnLeft, stretchLeewayOnRight);
            })
            .bind("drag", function (e, dd) {
              var actualMinWidth, d = Math.min(maxPageX, Math.max(minPageX, e.pageX)) - pageX, x;
              if (d < 0) { // shrink column
                x = d;
                for (j = i; j >= 0; j--) {
                  c = columns[j];
                  if (c.resizable) {
                    actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                    if (x && c.previousWidth + x < actualMinWidth) {
                      x += c.previousWidth - actualMinWidth;
                      c.width = actualMinWidth;
                    } else {
                      c.width = c.previousWidth + x;
                      x = 0;
                    }
                  }
                }

                if (options.forceFitColumns) {
                  x = -d;
                  for (j = i + 1; j < columnElements.length; j++) {
                    c = columns[j];
                    if (c.resizable) {
                      if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {
                        x -= c.maxWidth - c.previousWidth;
                        c.width = c.maxWidth;
                      } else {
                        c.width = c.previousWidth + x;
                        x = 0;
                      }
                    }
                  }
                }
              } else { // stretch column
                x = d;
                for (j = i; j >= 0; j--) {
                  c = columns[j];
                  if (c.resizable) {
                    if (x && c.maxWidth && (c.maxWidth - c.previousWidth < x)) {
                      x -= c.maxWidth - c.previousWidth;
                      c.width = c.maxWidth;
                    } else {
                      c.width = c.previousWidth + x;
                      x = 0;
                    }
                  }
                }

                if (options.forceFitColumns) {
                  x = -d;
                  for (j = i + 1; j < columnElements.length; j++) {
                    c = columns[j];
                    if (c.resizable) {
                      actualMinWidth = Math.max(c.minWidth || 0, absoluteColumnMinWidth);
                      if (x && c.previousWidth + x < actualMinWidth) {
                        x += c.previousWidth - actualMinWidth;
                        c.width = actualMinWidth;
                      } else {
                        c.width = c.previousWidth + x;
                        x = 0;
                      }
                    }
                  }
                }
              }
              applyColumnHeaderWidths();
              if (options.syncColumnCellResize) {
                applyColumnWidths();
              }
            })
            .bind("dragend", function (e, dd) {
              var newWidth;
              $(this).parent().removeClass("slick-header-column-active");
              for (j = 0; j < columnElements.length; j++) {
                c = columns[j];
                newWidth = $(columnElements[j]).outerWidth();

                if (c.previousWidth !== newWidth && c.rerenderOnResize) {
                  invalidateAllRows();
                }
              }
              updateCanvasWidth(true);
              render();
              trigger(self.onColumnsResized, {});
            });
      });
    }

    function getVBoxDelta($el) {
      var p = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];
      var delta = 0;
      $.each(p, function (n, val) {
        delta += parseFloat($el.css(val)) || 0;
      });
      return delta;
    }

    function measureCellPaddingAndBorder() {
      var el;
      var h = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"];
      var v = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"];

      el = $("<div class='ui-state-default slick-header-column' style='visibility:hidden'>-</div>").appendTo($headers);
      headerColumnWidthDiff = headerColumnHeightDiff = 0;
      $.each(h, function (n, val) {
        headerColumnWidthDiff += parseFloat(el.css(val)) || 0;
      });
      $.each(v, function (n, val) {
        headerColumnHeightDiff += parseFloat(el.css(val)) || 0;
      });
      el.remove();

      var r = $("<div class='slick-row' />").appendTo($canvas);
      el = $("<div class='slick-cell' id='' style='visibility:hidden'>-</div>").appendTo(r);
      cellWidthDiff = cellHeightDiff = 0;
      $.each(h, function (n, val) {
        cellWidthDiff += parseFloat(el.css(val)) || 0;
      });
      $.each(v, function (n, val) {
        cellHeightDiff += parseFloat(el.css(val)) || 0;
      });
      r.remove();

      absoluteColumnMinWidth = Math.max(headerColumnWidthDiff, cellWidthDiff);
    }

    function createCssRules() {
      $style = $("<style type='text/css' rel='stylesheet' />").appendTo($("head"));
      var rowHeight = (options.rowHeight - cellHeightDiff);
      var rules = [
        "." + uid + " .slick-header-column { left: 1000px; }",
        "." + uid + " .slick-top-panel { height:" + options.topPanelHeight + "px; }",
        "." + uid + " .slick-headerrow-columns { height:" + options.headerRowHeight + "px; }",
        "." + uid + " .slick-cell { height:" + rowHeight + "px; }",
        "." + uid + " .slick-row { height:" + options.rowHeight + "px; }"
      ];

      for (var i = 0; i < columns.length; i++) {
        rules.push("." + uid + " .l" + i + " { }");
        rules.push("." + uid + " .r" + i + " { }");
      }

      if ($style[0].styleSheet) { // IE
        $style[0].styleSheet.cssText = rules.join(" ");
      } else {
        $style[0].appendChild(document.createTextNode(rules.join(" ")));
      }
    }

    function getColumnCssRules(idx) {
      if (!stylesheet) {
        var sheets = document.styleSheets;
        for (var i = 0; i < sheets.length; i++) {
          if ((sheets[i].ownerNode || sheets[i].owningElement) == $style[0]) {
            stylesheet = sheets[i];
            break;
          }
        }

        if (!stylesheet) {
          throw new Error("Cannot find stylesheet.");
        }

        // find and cache column CSS rules
        columnCssRulesL = [];
        columnCssRulesR = [];
        var cssRules = (stylesheet.cssRules || stylesheet.rules);
        var matches, columnIdx;
        for (var i = 0; i < cssRules.length; i++) {
          var selector = cssRules[i].selectorText;
          if (matches = /\.l\d+/.exec(selector)) {
            columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
            columnCssRulesL[columnIdx] = cssRules[i];
          } else if (matches = /\.r\d+/.exec(selector)) {
            columnIdx = parseInt(matches[0].substr(2, matches[0].length - 2), 10);
            columnCssRulesR[columnIdx] = cssRules[i];
          }
        }
      }

      return {
        "left": columnCssRulesL[idx],
        "right": columnCssRulesR[idx]
      };
    }

    function removeCssRules() {
      $style.remove();
      stylesheet = null;
    }

    function destroy() {
      getEditorLock().cancelCurrentEdit();

      trigger(self.onBeforeDestroy, {});

      var i = plugins.length;
      while(i--) {
        unregisterPlugin(plugins[i]);
      }

      if (options.enableColumnReorder && $headers.sortable) {
        $headers.sortable("destroy");
      }

      unbindAncestorScrollEvents();
      $container.unbind(".slickgrid");
      removeCssRules();

      $canvas.unbind("draginit dragstart dragend drag");
      $container.empty().removeClass(uid);
    }


    //////////////////////////////////////////////////////////////////////////////////////////////
    // General

    function trigger(evt, args, e) {
      e = e || new Slick.EventData();
      args = args || {};
      args.grid = self;
      return evt.notify(args, e, self);
    }

    function getEditorLock() {
      return options.editorLock;
    }

    function getEditController() {
      return editController;
    }

    function getColumnIndex(id) {
      return columnsById[id];
    }

    function autosizeColumns() {
      var i, c,
          widths = [],
          shrinkLeeway = 0,
          total = 0,
          prevTotal,
          availWidth = viewportHasVScroll ? viewportW - scrollbarDimensions.width : viewportW;

      for (i = 0; i < columns.length; i++) {
        c = columns[i];
        widths.push(c.width);
        total += c.width;
        if (c.resizable) {
          shrinkLeeway += c.width - Math.max(c.minWidth, absoluteColumnMinWidth);
        }
      }

      // shrink
      prevTotal = total;
      while (total > availWidth && shrinkLeeway) {
        var shrinkProportion = (total - availWidth) / shrinkLeeway;
        for (i = 0; i < columns.length && total > availWidth; i++) {
          c = columns[i];
          var width = widths[i];
          if (!c.resizable || width <= c.minWidth || width <= absoluteColumnMinWidth) {
            continue;
          }
          var absMinWidth = Math.max(c.minWidth, absoluteColumnMinWidth);
          var shrinkSize = Math.floor(shrinkProportion * (width - absMinWidth)) || 1;
          shrinkSize = Math.min(shrinkSize, width - absMinWidth);
          total -= shrinkSize;
          shrinkLeeway -= shrinkSize;
          widths[i] -= shrinkSize;
        }
        if (prevTotal == total) {  // avoid infinite loop
          break;
        }
        prevTotal = total;
      }

      // grow
      prevTotal = total;
      while (total < availWidth) {
        var growProportion = availWidth / total;
        for (i = 0; i < columns.length && total < availWidth; i++) {
          c = columns[i];
          if (!c.resizable || c.maxWidth <= c.width) {
            continue;
          }
          var growSize = Math.min(Math.floor(growProportion * c.width) - c.width, (c.maxWidth - c.width) || 1000000) || 1;
          total += growSize;
          widths[i] += growSize;
        }
        if (prevTotal == total) {  // avoid infinite loop
          break;
        }
        prevTotal = total;
      }

      var reRender = false;
      for (i = 0; i < columns.length; i++) {
        if (columns[i].rerenderOnResize && columns[i].width != widths[i]) {
          reRender = true;
        }
        columns[i].width = widths[i];
      }

      applyColumnHeaderWidths();
      updateCanvasWidth(true);
      if (reRender) {
        invalidateAllRows();
        render();
      }
    }

    function applyColumnHeaderWidths() {
      if (!initialized) { return; }
      var h;
      for (var i = 0, headers = $headers.children(), ii = headers.length; i < ii; i++) {
        h = $(headers[i]);
        if (h.width() !== columns[i].width - headerColumnWidthDiff) {
          h.width(columns[i].width - headerColumnWidthDiff);
        }
      }

      updateColumnCaches();
    }

    function applyColumnWidths() {
      var x = 0, w, rule;
      for (var i = 0; i < columns.length; i++) {
        w = columns[i].width;

        rule = getColumnCssRules(i);
        rule.left.style.left = x + "px";
        rule.right.style.right = (canvasWidth - x - w) + "px";

        x += columns[i].width;
      }
    }

    function setSortColumn(columnId, ascending) {
      setSortColumns([{ columnId: columnId, sortAsc: ascending}]);
    }

    function setSortColumns(cols) {
      sortColumns = cols;

      var headerColumnEls = $headers.children();
      headerColumnEls
          .removeClass("slick-header-column-sorted")
          .find(".slick-sort-indicator")
              .removeClass("slick-sort-indicator-asc slick-sort-indicator-desc");

      $.each(sortColumns, function(i, col) {
        if (col.sortAsc == null) {
          col.sortAsc = true;
        }
        var columnIndex = getColumnIndex(col.columnId);
        if (columnIndex != null) {
          headerColumnEls.eq(columnIndex)
              .addClass("slick-header-column-sorted")
              .find(".slick-sort-indicator")
                  .addClass(col.sortAsc ? "slick-sort-indicator-asc" : "slick-sort-indicator-desc");
        }
      });
    }

    function getSortColumns() {
      return sortColumns;
    }

    function handleSelectedRangesChanged(e, ranges) {
      selectedRows = [];
      var hash = {};
      for (var i = 0; i < ranges.length; i++) {
        for (var j = ranges[i].fromRow; j <= ranges[i].toRow; j++) {
          if (!hash[j]) {  // prevent duplicates
            selectedRows.push(j);
          }
          hash[j] = {};
          for (var k = ranges[i].fromCell; k <= ranges[i].toCell; k++) {
            if (canCellBeSelected(j, k)) {
              hash[j][columns[k].id] = options.selectedCellCssClass;
            }
          }
        }
      }

      setCellCssStyles(options.selectedCellCssClass, hash);

      trigger(self.onSelectedRowsChanged, {rows: getSelectedRows()}, e);
    }

    function getColumns() {
      return columns;
    }

    function updateColumnCaches() {
      // Pre-calculate cell boundaries.
      columnPosLeft = [];
      columnPosRight = [];
      var x = 0;
      for (var i = 0, ii = columns.length; i < ii; i++) {
        columnPosLeft[i] = x;
        columnPosRight[i] = x + columns[i].width;
        x += columns[i].width;
      }
    }

    function setColumns(columnDefinitions) {
      columns = columnDefinitions;

      columnsById = {};
      for (var i = 0; i < columns.length; i++) {
        var m = columns[i] = $.extend({}, columnDefaults, columns[i]);
        columnsById[m.id] = i;
      }

      updateColumnCaches();

      if (initialized) {
        invalidateAllRows();
        createColumnHeaders();
        removeCssRules();
        createCssRules();
        resizeCanvas();
        applyColumnWidths();
        handleScroll();
      }
    }

    function getOptions() {
      return options;
    }

    function setOptions(args) {
      if (!getEditorLock().commitCurrentEdit()) {
        return;
      }

      makeActiveCellNormal();

      if (options.enableAddRow !== args.enableAddRow) {
        invalidateRow(getDataLength());
      }

      options = $.extend(options, args);

      $viewport.css("overflow-y", options.autoHeight ? "hidden" : "auto");
      render();
    }

    function setData(newData, scrollToTop) {
      data = newData;
      invalidateAllRows();
      updateRowCount();
      if (scrollToTop) {
        scrollTo(0);
      }
    }

    function getData() {
      return data;
    }

    function getDataLength() {
      if (data.getLength) {
        return data.getLength();
      } else {
        return data.length;
      }
    }

    function getDataItem(i) {
      if (data.getItem) {
        return data.getItem(i);
      } else {
        return data[i];
      }
    }

    function getTopPanel() {
      return $topPanel[0];
    }

    function showTopPanel() {
      options.showTopPanel = true;
      $topPanelScroller.slideDown("fast", resizeCanvas);
    }

    function hideTopPanel() {
      options.showTopPanel = false;
      $topPanelScroller.slideUp("fast", resizeCanvas);
    }

    function showHeaderRowColumns() {
      options.showHeaderRow = true;
      $headerRowScroller.slideDown("fast", resizeCanvas);
    }

    function hideHeaderRowColumns() {
      options.showHeaderRow = false;
      $headerRowScroller.slideUp("fast", resizeCanvas);
    }

    //////////////////////////////////////////////////////////////////////////////////////////////
    // Rendering / Scrolling

    function scrollTo(y) {
      y = Math.max(y, 0);
      y = Math.min(y, th - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0));

      var oldOffset = offset;

      page = Math.min(n - 1, Math.floor(y / ph));
      offset = Math.round(page * cj);
      var newScrollTop = y - offset;

      if (offset != oldOffset) {
        var range = getVisibleRange(newScrollTop);
        cleanupRows(range);
        updateRowPositions();
      }

      if (prevScrollTop != newScrollTop) {
        vScrollDir = (prevScrollTop + oldOffset < newScrollTop + offset) ? 1 : -1;
        $viewport[0].scrollTop = (lastRenderedScrollTop = scrollTop = prevScrollTop = newScrollTop);

        trigger(self.onViewportChanged, {});
      }
    }

    function defaultFormatter(row, cell, value, columnDef, dataContext) {
      if (value == null) {
        return "";
      } else {
        return value.toString().replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;");
      }
    }

    function getFormatter(row, column) {
      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);

      // look up by id, then index
      var columnOverrides = rowMetadata &&
          rowMetadata.columns &&
          (rowMetadata.columns[column.id] || rowMetadata.columns[getColumnIndex(column.id)]);

      return (columnOverrides && columnOverrides.formatter) ||
          (rowMetadata && rowMetadata.formatter) ||
          column.formatter ||
          (options.formatterFactory && options.formatterFactory.getFormatter(column)) ||
          options.defaultFormatter;
    }

    function getEditor(row, cell) {
      var column = columns[cell];
      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
      var columnMetadata = rowMetadata && rowMetadata.columns;

      if (columnMetadata && columnMetadata[column.id] && columnMetadata[column.id].editor !== undefined) {
        return columnMetadata[column.id].editor;
      }
      if (columnMetadata && columnMetadata[cell] && columnMetadata[cell].editor !== undefined) {
        return columnMetadata[cell].editor;
      }

      return column.editor || (options.editorFactory && options.editorFactory.getEditor(column));
    }

    function getDataItemValueForColumn(item, columnDef) {
      if (options.dataItemColumnValueExtractor) {
        return options.dataItemColumnValueExtractor(item, columnDef);
      }
      return item[columnDef.field];
    }

    function appendRowHtml(stringArray, row, range) {
      var cacheEntry = rowsCache[row];
      var d = getDataItem(row);
      var dataLoading = row < getDataLength() && !d;
      var cellCss;
      var rowCss = "slick-row" +
          (dataLoading ? " loading" : "") +
          (row % 2 == 1 ? " odd" : " even");

      var metadata = data.getItemMetadata && data.getItemMetadata(row);

      if (metadata && metadata.cssClasses) {
        rowCss += " " + metadata.cssClasses;
      }

      stringArray.push("<div class='ui-widget-content " + rowCss + "' style='top:" + (options.rowHeight * row - offset) + "px'>");

      var colspan, m;
      for (var i = 0, ii = columns.length; i < ii; i++) {
        m = columns[i];
        colspan = 1;
        if (metadata && metadata.columns) {
          var columnData = metadata.columns[m.id] || metadata.columns[i];
          colspan = (columnData && columnData.colspan) || 1;
          if (colspan === "*") {
            colspan = ii - i;
          }
        }

        // Do not render cells outside of the viewport.
        if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {
          if (columnPosLeft[i] > range.rightPx) {
            // All columns to the right are outside the range.
            break;
          }

          appendCellHtml(stringArray, row, i, colspan);
        }

        if (colspan > 1) {
          i += (colspan - 1);
        }
      }

      stringArray.push("</div>");
    }

    function appendCellHtml(stringArray, row, cell, colspan) {
      var m = columns[cell];
      var d = getDataItem(row);
      var cellCss = "slick-cell l" + cell + " r" + Math.min(columns.length - 1, cell + colspan - 1) +
          (m.cssClass ? " " + m.cssClass : "");
      if (row === activeRow && cell === activeCell) {
        cellCss += (" active");
      }

      // TODO:  merge them together in the setter
      for (var key in cellCssClasses) {
        if (cellCssClasses[key][row] && cellCssClasses[key][row][m.id]) {
          cellCss += (" " + cellCssClasses[key][row][m.id]);
        }
      }

      stringArray.push("<div class='" + cellCss + "'>");

      // if there is a corresponding row (if not, this is the Add New row or this data hasn't been loaded yet)
      if (d) {
        var value = getDataItemValueForColumn(d, m);
        stringArray.push(getFormatter(row, m)(row, cell, value, m, d));
      }

      stringArray.push("</div>");

      rowsCache[row].cellRenderQueue.push(cell);
      rowsCache[row].cellColSpans[cell] = colspan;
    }


    function cleanupRows(rangeToKeep) {
      for (var i in rowsCache) {
        if (((i = parseInt(i, 10)) !== activeRow) && (i < rangeToKeep.top || i > rangeToKeep.bottom)) {
          removeRowFromCache(i);
        }
      }
    }

    function invalidate() {
      updateRowCount();
      invalidateAllRows();
      render();
    }

    function invalidateAllRows() {
      if (currentEditor) {
        makeActiveCellNormal();
      }
      for (var row in rowsCache) {
        removeRowFromCache(row);
      }
    }

    function removeRowFromCache(row) {
      var cacheEntry = rowsCache[row];
      if (!cacheEntry) {
        return;
      }
      $canvas[0].removeChild(cacheEntry.rowNode);
      delete rowsCache[row];
      delete postProcessedRows[row];
      renderedRows--;
      counter_rows_removed++;
    }

    function invalidateRows(rows) {
      var i, rl;
      if (!rows || !rows.length) {
        return;
      }
      vScrollDir = 0;
      for (i = 0, rl = rows.length; i < rl; i++) {
        if (currentEditor && activeRow === rows[i]) {
          makeActiveCellNormal();
        }
        if (rowsCache[rows[i]]) {
          removeRowFromCache(rows[i]);
        }
      }
    }

    function invalidateRow(row) {
      invalidateRows([row]);
    }

    function updateCell(row, cell) {
      var cellNode = getCellNode(row, cell);
      if (!cellNode) {
        return;
      }

      var m = columns[cell], d = getDataItem(row);
      if (currentEditor && activeRow === row && activeCell === cell) {
        currentEditor.loadValue(d);
      } else {
        cellNode.innerHTML = d ? getFormatter(row, m)(row, cell, getDataItemValueForColumn(d, m), m, d) : "";
        invalidatePostProcessingResults(row);
      }
    }

    function updateRow(row) {
      var cacheEntry = rowsCache[row];
      if (!cacheEntry) {
        return;
      }

      ensureCellNodesInRowsCache(row);

      for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
        columnIdx = columnIdx | 0;
        var m = columns[columnIdx],
            d = getDataItem(row),
            node = cacheEntry.cellNodesByColumnIdx[columnIdx];

        if (row === activeRow && columnIdx === activeCell && currentEditor) {
          currentEditor.loadValue(d);
        } else if (d) {
          node.innerHTML = getFormatter(row, m)(row, columnIdx, getDataItemValueForColumn(d, m), m, d);
        } else {
          node.innerHTML = "";
        }
      }

      invalidatePostProcessingResults(row);
    }

    function getViewportHeight() {
      return parseFloat($.css($container[0], "height", true)) -
          parseFloat($.css($headerScroller[0], "height")) - getVBoxDelta($headerScroller) -
          (options.showTopPanel ? options.topPanelHeight + getVBoxDelta($topPanelScroller) : 0) -
          (options.showHeaderRow ? options.headerRowHeight + getVBoxDelta($headerRowScroller) : 0);
    }

    function resizeCanvas() {
      if (!initialized) { return; }
      if (options.autoHeight) {
        viewportH = options.rowHeight * (getDataLength() + (options.enableAddRow ? 1 : 0) + (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0));
      } else {
        viewportH = getViewportHeight();
      }

      numVisibleRows = Math.ceil(viewportH / options.rowHeight);
      viewportW = parseFloat($.css($container[0], "width", true));
      $viewport.height(viewportH);

      if (options.forceFitColumns) {
        autosizeColumns();
      }

      updateRowCount();
      handleScroll();
      render();
    }

    function updateRowCount() {
      if (!initialized) { return; }
      numberOfRows = getDataLength() +
          (options.enableAddRow ? 1 : 0) +
          (options.leaveSpaceForNewRows ? numVisibleRows - 1 : 0);

      var oldViewportHasVScroll = viewportHasVScroll;
      // with autoHeight, we do not need to accommodate the vertical scroll bar
      viewportHasVScroll = !options.autoHeight && (numberOfRows * options.rowHeight > viewportH);

      // remove the rows that are now outside of the data range
      // this helps avoid redundant calls to .removeRow() when the size of the data decreased by thousands of rows
      var l = options.enableAddRow ? getDataLength() : getDataLength() - 1;
      for (var i in rowsCache) {
        if (i >= l) {
          removeRowFromCache(i);
        }
      }

      var oldH = h;
      th = Math.max(options.rowHeight * numberOfRows, viewportH - scrollbarDimensions.height);
      if (th < maxSupportedCssHeight) {
        // just one page
        h = ph = th;
        n = 1;
        cj = 0;
      } else {
        // break into pages
        h = maxSupportedCssHeight;
        ph = h / 100;
        n = Math.floor(th / ph);
        cj = (th - h) / (n - 1);
      }

      if (h !== oldH) {
        $canvas.css("height", h);
        scrollTop = $viewport[0].scrollTop;
      }

      var oldScrollTopInRange = (scrollTop + offset <= th - viewportH);

      if (th == 0 || scrollTop == 0) {
        page = offset = 0;
      } else if (oldScrollTopInRange) {
        // maintain virtual position
        scrollTo(scrollTop + offset);
      } else {
        // scroll to bottom
        scrollTo(th - viewportH);
      }

      if (h != oldH && options.autoHeight) {
        resizeCanvas();
      }

      if (options.forceFitColumns && oldViewportHasVScroll != viewportHasVScroll) {
        autosizeColumns();
      }
      updateCanvasWidth(false);
    }

    function getVisibleRange(viewportTop, viewportLeft) {
      if (viewportTop == null) {
        viewportTop = scrollTop;
      }
      if (viewportLeft == null) {
        viewportLeft = scrollLeft;
      }

      return {
        top: Math.floor((viewportTop + offset) / options.rowHeight),
        bottom: Math.ceil((viewportTop + offset + viewportH) / options.rowHeight),
        leftPx: viewportLeft,
        rightPx: viewportLeft + viewportW
      };
    }

    function getRenderedRange(viewportTop, viewportLeft) {
      var range = getVisibleRange(viewportTop, viewportLeft);
      var buffer = Math.round(viewportH / options.rowHeight);
      var minBuffer = 3;

      if (vScrollDir == -1) {
        range.top -= buffer;
        range.bottom += minBuffer;
      } else if (vScrollDir == 1) {
        range.top -= minBuffer;
        range.bottom += buffer;
      } else {
        range.top -= minBuffer;
        range.bottom += minBuffer;
      }

      range.top = Math.max(0, range.top);
      range.bottom = Math.min(options.enableAddRow ? getDataLength() : getDataLength() - 1, range.bottom);

      range.leftPx -= viewportW;
      range.rightPx += viewportW;

      range.leftPx = Math.max(0, range.leftPx);
      range.rightPx = Math.min(canvasWidth, range.rightPx);

      return range;
    }

    function ensureCellNodesInRowsCache(row) {
      var cacheEntry = rowsCache[row];
      if (cacheEntry) {
        if (cacheEntry.cellRenderQueue.length) {
          var lastChild = cacheEntry.rowNode.lastChild;
          while (cacheEntry.cellRenderQueue.length) {
            var columnIdx = cacheEntry.cellRenderQueue.pop();
            cacheEntry.cellNodesByColumnIdx[columnIdx] = lastChild;
            lastChild = lastChild.previousSibling;
          }
        }
      }
    }

    function cleanUpCells(range, row) {
      var totalCellsRemoved = 0;
      var cacheEntry = rowsCache[row];

      // Remove cells outside the range.
      var cellsToRemove = [];
      for (var i in cacheEntry.cellNodesByColumnIdx) {
        // I really hate it when people mess with Array.prototype.
        if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(i)) {
          continue;
        }

        // This is a string, so it needs to be cast back to a number.
        i = i | 0;

        var colspan = cacheEntry.cellColSpans[i];
        if (columnPosLeft[i] > range.rightPx ||
          columnPosRight[Math.min(columns.length - 1, i + colspan - 1)] < range.leftPx) {
          if (!(row == activeRow && i == activeCell)) {
            cellsToRemove.push(i);
          }
        }
      }

      var cellToRemove;
      while ((cellToRemove = cellsToRemove.pop()) != null) {
        cacheEntry.rowNode.removeChild(cacheEntry.cellNodesByColumnIdx[cellToRemove]);
        delete cacheEntry.cellColSpans[cellToRemove];
        delete cacheEntry.cellNodesByColumnIdx[cellToRemove];
        if (postProcessedRows[row]) {
          delete postProcessedRows[row][cellToRemove];
        }
        totalCellsRemoved++;
      }
    }

    function cleanUpAndRenderCells(range) {
      var cacheEntry;
      var stringArray = [];
      var processedRows = [];
      var cellsAdded;
      var totalCellsAdded = 0;
      var colspan;

      for (var row = range.top; row <= range.bottom; row++) {
        cacheEntry = rowsCache[row];
        if (!cacheEntry) {
          continue;
        }

        // cellRenderQueue populated in renderRows() needs to be cleared first
        ensureCellNodesInRowsCache(row);

        cleanUpCells(range, row);

        // Render missing cells.
        cellsAdded = 0;

        var metadata = data.getItemMetadata && data.getItemMetadata(row);
        metadata = metadata && metadata.columns;

        // TODO:  shorten this loop (index? heuristics? binary search?)
        for (var i = 0, ii = columns.length; i < ii; i++) {
          // Cells to the right are outside the range.
          if (columnPosLeft[i] > range.rightPx) {
            break;
          }

          // Already rendered.
          if ((colspan = cacheEntry.cellColSpans[i]) != null) {
            i += (colspan > 1 ? colspan - 1 : 0);
            continue;
          }

          colspan = 1;
          if (metadata) {
            var columnData = metadata[columns[i].id] || metadata[i];
            colspan = (columnData && columnData.colspan) || 1;
            if (colspan === "*") {
              colspan = ii - i;
            }
          }

          if (columnPosRight[Math.min(ii - 1, i + colspan - 1)] > range.leftPx) {
            appendCellHtml(stringArray, row, i, colspan);
            cellsAdded++;
          }

          i += (colspan > 1 ? colspan - 1 : 0);
        }

        if (cellsAdded) {
          totalCellsAdded += cellsAdded;
          processedRows.push(row);
        }
      }

      if (!stringArray.length) {
        return;
      }

      var x = document.createElement("div");
      x.innerHTML = stringArray.join("");

      var processedRow;
      var node;
      while ((processedRow = processedRows.pop()) != null) {
        cacheEntry = rowsCache[processedRow];
        var columnIdx;
        while ((columnIdx = cacheEntry.cellRenderQueue.pop()) != null) {
          node = x.lastChild;
          cacheEntry.rowNode.appendChild(node);
          cacheEntry.cellNodesByColumnIdx[columnIdx] = node;
        }
      }
    }

    function renderRows(range) {
      var parentNode = $canvas[0],
          stringArray = [],
          rows = [],
          needToReselectCell = false;

      for (var i = range.top; i <= range.bottom; i++) {
        if (rowsCache[i]) {
          continue;
        }
        renderedRows++;
        rows.push(i);

        // Create an entry right away so that appendRowHtml() can
        // start populatating it.
        rowsCache[i] = {
          "rowNode": null,

          // ColSpans of rendered cells (by column idx).
          // Can also be used for checking whether a cell has been rendered.
          "cellColSpans": [],

          // Cell nodes (by column idx).  Lazy-populated by ensureCellNodesInRowsCache().
          "cellNodesByColumnIdx": [],

          // Column indices of cell nodes that have been rendered, but not yet indexed in
          // cellNodesByColumnIdx.  These are in the same order as cell nodes added at the
          // end of the row.
          "cellRenderQueue": []
        };

        appendRowHtml(stringArray, i, range);
        if (activeCellNode && activeRow === i) {
          needToReselectCell = true;
        }
        counter_rows_rendered++;
      }

      if (!rows.length) { return; }

      var x = document.createElement("div");
      x.innerHTML = stringArray.join("");

      for (var i = 0, ii = rows.length; i < ii; i++) {
        rowsCache[rows[i]].rowNode = parentNode.appendChild(x.firstChild);
      }

      if (needToReselectCell) {
        activeCellNode = getCellNode(activeRow, activeCell);
      }
    }

    function startPostProcessing() {
      if (!options.enableAsyncPostRender) {
        return;
      }
      clearTimeout(h_postrender);
      h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
    }

    function invalidatePostProcessingResults(row) {
      delete postProcessedRows[row];
      postProcessFromRow = Math.min(postProcessFromRow, row);
      postProcessToRow = Math.max(postProcessToRow, row);
      startPostProcessing();
    }

    function updateRowPositions() {
      for (var row in rowsCache) {
        rowsCache[row].rowNode.style.top = (row * options.rowHeight - offset) + "px";
      }
    }

    function render() {
      if (!initialized) { return; }
      var visible = getVisibleRange();
      var rendered = getRenderedRange();

      // remove rows no longer in the viewport
      cleanupRows(rendered);

      // add new rows & missing cells in existing rows
      if (lastRenderedScrollLeft != scrollLeft) {
        cleanUpAndRenderCells(rendered);
      }

      // render missing rows
      renderRows(rendered);

      postProcessFromRow = visible.top;
      postProcessToRow = Math.min(options.enableAddRow ? getDataLength() : getDataLength() - 1, visible.bottom);
      startPostProcessing();

      lastRenderedScrollTop = scrollTop;
      lastRenderedScrollLeft = scrollLeft;
      h_render = null;
    }

    function handleScroll() {
      scrollTop = $viewport[0].scrollTop;
      scrollLeft = $viewport[0].scrollLeft;
      var vScrollDist = Math.abs(scrollTop - prevScrollTop);
      var hScrollDist = Math.abs(scrollLeft - prevScrollLeft);

      if (hScrollDist) {
        prevScrollLeft = scrollLeft;
        $headerScroller[0].scrollLeft = scrollLeft;
        $topPanelScroller[0].scrollLeft = scrollLeft;
        $headerRowScroller[0].scrollLeft = scrollLeft;
      }

      if (vScrollDist) {
        vScrollDir = prevScrollTop < scrollTop ? 1 : -1;
        prevScrollTop = scrollTop;

        // switch virtual pages if needed
        if (vScrollDist < viewportH) {
          scrollTo(scrollTop + offset);
        } else {
          var oldOffset = offset;
          page = Math.min(n - 1, Math.floor(scrollTop * ((th - viewportH) / (h - viewportH)) * (1 / ph)));
          offset = Math.round(page * cj);
          if (oldOffset != offset) {
            invalidateAllRows();
          }
        }
      }

      if (hScrollDist || vScrollDist) {
        if (h_render) {
          clearTimeout(h_render);
        }

        if (Math.abs(lastRenderedScrollTop - scrollTop) > 20 ||
            Math.abs(lastRenderedScrollLeft - scrollLeft) > 20) {
          if (Math.abs(lastRenderedScrollTop - scrollTop) < viewportH &&
              Math.abs(lastRenderedScrollLeft - scrollLeft) < viewportW) {
            render();
          } else {
            h_render = setTimeout(render, 50);
          }

          trigger(self.onViewportChanged, {});
        }
      }

      trigger(self.onScroll, {scrollLeft: scrollLeft, scrollTop: scrollTop});
    }

    function asyncPostProcessRows() {
      while (postProcessFromRow <= postProcessToRow) {
        var row = (vScrollDir >= 0) ? postProcessFromRow++ : postProcessToRow--;
        var cacheEntry = rowsCache[row];
        if (!cacheEntry || row >= getDataLength()) {
          continue;
        }

        if (!postProcessedRows[row]) {
          postProcessedRows[row] = {};
        }

        ensureCellNodesInRowsCache(row);
        for (var columnIdx in cacheEntry.cellNodesByColumnIdx) {
          if (!cacheEntry.cellNodesByColumnIdx.hasOwnProperty(columnIdx)) {
            continue;
          }

          columnIdx = columnIdx | 0;

          var m = columns[columnIdx];
          if (m.asyncPostRender && !postProcessedRows[row][columnIdx]) {
            var node = cacheEntry.cellNodesByColumnIdx[columnIdx];
            if (node) {
              m.asyncPostRender(node, postProcessFromRow, getDataItem(row), m);
            }
            postProcessedRows[row][columnIdx] = true;
          }
        }

        h_postrender = setTimeout(asyncPostProcessRows, options.asyncPostRenderDelay);
        return;
      }
    }

    function updateCellCssStylesOnRenderedRows(addedHash, removedHash) {
      var node, columnId, addedRowHash, removedRowHash;
      for (var row in rowsCache) {
        removedRowHash = removedHash && removedHash[row];
        addedRowHash = addedHash && addedHash[row];

        if (removedRowHash) {
          for (columnId in removedRowHash) {
            if (!addedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
              node = getCellNode(row, getColumnIndex(columnId));
              if (node) {
                $(node).removeClass(removedRowHash[columnId]);
              }
            }
          }
        }

        if (addedRowHash) {
          for (columnId in addedRowHash) {
            if (!removedRowHash || removedRowHash[columnId] != addedRowHash[columnId]) {
              node = getCellNode(row, getColumnIndex(columnId));
              if (node) {
                $(node).addClass(addedRowHash[columnId]);
              }
            }
          }
        }
      }
    }

    function addCellCssStyles(key, hash) {
      if (cellCssClasses[key]) {
        throw "addCellCssStyles: cell CSS hash with key '" + key + "' already exists.";
      }

      cellCssClasses[key] = hash;
      updateCellCssStylesOnRenderedRows(hash, null);

      trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash });
    }

    function removeCellCssStyles(key) {
      if (!cellCssClasses[key]) {
        return;
      }

      updateCellCssStylesOnRenderedRows(null, cellCssClasses[key]);
      delete cellCssClasses[key];

      trigger(self.onCellCssStylesChanged, { "key": key, "hash": null });
    }

    function setCellCssStyles(key, hash) {
      var prevHash = cellCssClasses[key];

      cellCssClasses[key] = hash;
      updateCellCssStylesOnRenderedRows(hash, prevHash);

      trigger(self.onCellCssStylesChanged, { "key": key, "hash": hash });
    }

    function getCellCssStyles(key) {
      return cellCssClasses[key];
    }

    function flashCell(row, cell, speed) {
      speed = speed || 100;
      if (rowsCache[row]) {
        var $cell = $(getCellNode(row, cell));

        function toggleCellClass(times) {
          if (!times) {
            return;
          }
          setTimeout(function () {
                $cell.queue(function () {
                  $cell.toggleClass(options.cellFlashingCssClass).dequeue();
                  toggleCellClass(times - 1);
                });
              },
              speed);
        }

        toggleCellClass(4);
      }
    }

    //////////////////////////////////////////////////////////////////////////////////////////////
    // Interactivity

    function handleDragInit(e, dd) {
      var cell = getCellFromEvent(e);
      if (!cell || !cellExists(cell.row, cell.cell)) {
        return false;
      }

      retval = trigger(self.onDragInit, dd, e);
      if (e.isImmediatePropagationStopped()) {
        return retval;
      }

      // if nobody claims to be handling drag'n'drop by stopping immediate propagation,
      // cancel out of it
      return false;
    }

    function handleDragStart(e, dd) {
      var cell = getCellFromEvent(e);
      if (!cell || !cellExists(cell.row, cell.cell)) {
        return false;
      }

      var retval = trigger(self.onDragStart, dd, e);
      if (e.isImmediatePropagationStopped()) {
        return retval;
      }

      return false;
    }

    function handleDrag(e, dd) {
      return trigger(self.onDrag, dd, e);
    }

    function handleDragEnd(e, dd) {
      trigger(self.onDragEnd, dd, e);
    }

    function handleKeyDown(e) {
      trigger(self.onKeyDown, {row: activeRow, cell: activeCell}, e);
      var handled = e.isImmediatePropagationStopped();

      if (!handled) {
        if (!e.shiftKey && !e.altKey && !e.ctrlKey) {
          if (e.which == 27) {
            if (!getEditorLock().isActive()) {
              return; // no editing mode to cancel, allow bubbling and default processing (exit without cancelling the event)
            }
            cancelEditAndSetFocus();
          } else if (e.which == 37) {
            navigateLeft();
          } else if (e.which == 39) {
            navigateRight();
          } else if (e.which == 38) {
            navigateUp();
          } else if (e.which == 40) {
            navigateDown();
          } else if (e.which == 9) {
            navigateNext();
          } else if (e.which == 13) {
            if (options.editable) {
              if (currentEditor) {
                // adding new row
                if (activeRow === getDataLength()) {
                  navigateDown();
                }
                else {
                  commitEditAndSetFocus();
                }
              } else {
                if (getEditorLock().commitCurrentEdit()) {
                  makeActiveCellEditable();
                }
              }
            }
          } else {
            return;
          }
        } else if (e.which == 9 && e.shiftKey && !e.ctrlKey && !e.altKey) {
          navigatePrev();
        } else {
          return;
        }
      }

      // the event has been handled so don't let parent element (bubbling/propagation) or browser (default) handle it
      e.stopPropagation();
      e.preventDefault();
      try {
        e.originalEvent.keyCode = 0; // prevent default behaviour for special keys in IE browsers (F3, F5, etc.)
      }
        // ignore exceptions - setting the original event's keycode throws access denied exception for "Ctrl"
        // (hitting control key only, nothing else), "Shift" (maybe others)
      catch (error) {
      }
    }

    function handleClick(e) {
      if (!currentEditor) {
        // if this click resulted in some cell child node getting focus,
        // don't steal it back - keyboard events will still bubble up
        if (e.target != document.activeElement) {
          setFocus();
        }
      }

      var cell = getCellFromEvent(e);
      if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {
        return;
      }

      trigger(self.onClick, {row: cell.row, cell: cell.cell}, e);
      if (e.isImmediatePropagationStopped()) {
        return;
      }

      if ((activeCell != cell.cell || activeRow != cell.row) && canCellBeActive(cell.row, cell.cell)) {
        if (!getEditorLock().isActive() || getEditorLock().commitCurrentEdit()) {
          scrollRowIntoView(cell.row, false);
          setActiveCellInternal(getCellNode(cell.row, cell.cell), (cell.row === getDataLength()) || options.autoEdit);
        }
      }
    }

    function handleContextMenu(e) {
      var $cell = $(e.target).closest(".slick-cell", $canvas);
      if ($cell.length === 0) {
        return;
      }

      // are we editing this cell?
      if (activeCellNode === $cell[0] && currentEditor !== null) {
        return;
      }

      trigger(self.onContextMenu, {}, e);
    }

    function handleDblClick(e) {
      var cell = getCellFromEvent(e);
      if (!cell || (currentEditor !== null && activeRow == cell.row && activeCell == cell.cell)) {
        return;
      }

      trigger(self.onDblClick, {row: cell.row, cell: cell.cell}, e);
      if (e.isImmediatePropagationStopped()) {
        return;
      }

      if (options.editable) {
        gotoCell(cell.row, cell.cell, true);
      }
    }

    function handleHeaderMouseEnter(e) {
      trigger(self.onHeaderMouseEnter, {
        "column": $(this).data("column")
      }, e);
    }

    function handleHeaderMouseLeave(e) {
      trigger(self.onHeaderMouseLeave, {
        "column": $(this).data("column")
      }, e);
    }

    function handleHeaderContextMenu(e) {
      var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
      var column = $header && $header.data("column");
      trigger(self.onHeaderContextMenu, {column: column}, e);
    }

    function handleHeaderClick(e) {
      var $header = $(e.target).closest(".slick-header-column", ".slick-header-columns");
      var column = $header && $header.data("column");
      if (column) {
        trigger(self.onHeaderClick, {column: column}, e);
      }
    }

    function handleMouseEnter(e) {
      trigger(self.onMouseEnter, {}, e);
    }

    function handleMouseLeave(e) {
      trigger(self.onMouseLeave, {}, e);
    }

    function cellExists(row, cell) {
      return !(row < 0 || row >= getDataLength() || cell < 0 || cell >= columns.length);
    }

    function getCellFromPoint(x, y) {
      var row = Math.floor((y + offset) / options.rowHeight);
      var cell = 0;

      var w = 0;
      for (var i = 0; i < columns.length && w < x; i++) {
        w += columns[i].width;
        cell++;
      }

      if (cell < 0) {
        cell = 0;
      }

      return {row: row, cell: cell - 1};
    }

    function getCellFromNode(cellNode) {
      // read column number from .l<columnNumber> CSS class
      var cls = /l\d+/.exec(cellNode.className);
      if (!cls) {
        throw "getCellFromNode: cannot get cell - " + cellNode.className;
      }
      return parseInt(cls[0].substr(1, cls[0].length - 1), 10);
    }

    function getRowFromNode(rowNode) {
      for (var row in rowsCache) {
        if (rowsCache[row].rowNode === rowNode) {
          return row | 0;
        }
      }

      return null;
    }

    function getCellFromEvent(e) {
      var $cell = $(e.target).closest(".slick-cell", $canvas);
      if (!$cell.length) {
        return null;
      }

      var row = getRowFromNode($cell[0].parentNode);
      var cell = getCellFromNode($cell[0]);

      if (row == null || cell == null) {
        return null;
      } else {
        return {
          "row": row,
          "cell": cell
        };
      }
    }

    function getCellNodeBox(row, cell) {
      if (!cellExists(row, cell)) {
        return null;
      }

      var y1 = row * options.rowHeight - offset;
      var y2 = y1 + options.rowHeight - 1;
      var x1 = 0;
      for (var i = 0; i < cell; i++) {
        x1 += columns[i].width;
      }
      var x2 = x1 + columns[cell].width;

      return {
        top: y1,
        left: x1,
        bottom: y2,
        right: x2
      };
    }

    //////////////////////////////////////////////////////////////////////////////////////////////
    // Cell switching

    function resetActiveCell() {
      setActiveCellInternal(null, false);
    }

    function setFocus() {
      $focusSink[0].focus();
    }

    function scrollCellIntoView(row, cell) {
      var colspan = getColspan(row, cell);
      var left = columnPosLeft[cell],
        right = columnPosRight[cell + (colspan > 1 ? colspan - 1 : 0)],
        scrollRight = scrollLeft + viewportW;

      if (left < scrollLeft) {
        $viewport.scrollLeft(left);
        handleScroll();
        render();
      } else if (right > scrollRight) {
        $viewport.scrollLeft(Math.min(left, right - $viewport[0].clientWidth));
        handleScroll();
        render();
      }
    }

    function scrollActiveCellIntoView() {
      if (activeRow != null && activeCell != null) {
        scrollCellIntoView(activeRow, activeCell);
      }
    }

    function setActiveCellInternal(newCell, editMode) {
      if (activeCellNode !== null) {
        makeActiveCellNormal();
        $(activeCellNode).removeClass("active");
      }

      var activeCellChanged = (activeCellNode !== newCell);
      activeCellNode = newCell;

      if (activeCellNode != null) {
        activeRow = getRowFromNode(activeCellNode.parentNode);
        activeCell = activePosX = getCellFromNode(activeCellNode);

        $(activeCellNode).addClass("active");

        if (options.editable && editMode && isCellPotentiallyEditable(activeRow, activeCell)) {
          clearTimeout(h_editorLoader);

          if (options.asyncEditorLoading) {
            h_editorLoader = setTimeout(function () {
              makeActiveCellEditable();
            }, options.asyncEditorLoadDelay);
          } else {
            makeActiveCellEditable();
          }
        }
      } else {
        activeRow = activeCell = null;
      }

      if (activeCellChanged) {
        trigger(self.onActiveCellChanged, getActiveCell());
      }
    }

    function clearTextSelection() {
      if (document.selection && document.selection.empty) {
        document.selection.empty();
      } else if (window.getSelection) {
        var sel = window.getSelection();
        if (sel && sel.removeAllRanges) {
          sel.removeAllRanges();
        }
      }
    }

    function isCellPotentiallyEditable(row, cell) {
      // is the data for this row loaded?
      if (row < getDataLength() && !getDataItem(row)) {
        return false;
      }

      // are we in the Add New row?  can we create new from this cell?
      if (columns[cell].cannotTriggerInsert && row >= getDataLength()) {
        return false;
      }

      // does this cell have an editor?
      if (!getEditor(row, cell)) {
        return false;
      }

      return true;
    }

    function makeActiveCellNormal() {
      if (!currentEditor) {
        return;
      }
      trigger(self.onBeforeCellEditorDestroy, {editor: currentEditor});
      currentEditor.destroy();
      currentEditor = null;

      if (activeCellNode) {
        var d = getDataItem(activeRow);
        $(activeCellNode).removeClass("editable invalid");
        if (d) {
          var column = columns[activeCell];
          var formatter = getFormatter(activeRow, column);
          activeCellNode.innerHTML = formatter(activeRow, activeCell, getDataItemValueForColumn(d, column), column, getDataItem(activeRow));
          invalidatePostProcessingResults(activeRow);
        }
      }

      // if there previously was text selected on a page (such as selected text in the edit cell just removed),
      // IE can't set focus to anything else correctly
      if ($.browser.msie) {
        clearTextSelection();
      }

      getEditorLock().deactivate(editController);
    }

    function makeActiveCellEditable(editor) {
      if (!activeCellNode) {
        return;
      }
      if (!options.editable) {
        throw "Grid : makeActiveCellEditable : should never get called when options.editable is false";
      }

      // cancel pending async call if there is one
      clearTimeout(h_editorLoader);

      if (!isCellPotentiallyEditable(activeRow, activeCell)) {
        return;
      }

      var columnDef = columns[activeCell];
      var item = getDataItem(activeRow);

      if (trigger(self.onBeforeEditCell, {row: activeRow, cell: activeCell, item: item, column: columnDef}) === false) {
        setFocus();
        return;
      }

      getEditorLock().activate(editController);
      $(activeCellNode).addClass("editable");

      // don't clear the cell if a custom editor is passed through
      if (!editor) {
        activeCellNode.innerHTML = "";
      }

      currentEditor = new (editor || getEditor(activeRow, activeCell))({
        grid: self,
        gridPosition: absBox($container[0]),
        position: absBox(activeCellNode),
        container: activeCellNode,
        column: columnDef,
        item: item || {},
        commitChanges: commitEditAndSetFocus,
        cancelChanges: cancelEditAndSetFocus
      });

      if (item) {
        currentEditor.loadValue(item);
      }

      serializedEditorValue = currentEditor.serializeValue();

      if (currentEditor.position) {
        handleActiveCellPositionChange();
      }
    }

    function commitEditAndSetFocus() {
      // if the commit fails, it would do so due to a validation error
      // if so, do not steal the focus from the editor
      if (getEditorLock().commitCurrentEdit()) {
        setFocus();
        if (options.autoEdit) {
          navigateDown();
        }
      }
    }

    function cancelEditAndSetFocus() {
      if (getEditorLock().cancelCurrentEdit()) {
        setFocus();
      }
    }

    function absBox(elem) {
      var box = {
        top: elem.offsetTop,
        left: elem.offsetLeft,
        bottom: 0,
        right: 0,
        width: $(elem).outerWidth(),
        height: $(elem).outerHeight(),
        visible: true};
      box.bottom = box.top + box.height;
      box.right = box.left + box.width;

      // walk up the tree
      var offsetParent = elem.offsetParent;
      while ((elem = elem.parentNode) != document.body) {
        if (box.visible && elem.scrollHeight != elem.offsetHeight && $(elem).css("overflowY") != "visible") {
          box.visible = box.bottom > elem.scrollTop && box.top < elem.scrollTop + elem.clientHeight;
        }

        if (box.visible && elem.scrollWidth != elem.offsetWidth && $(elem).css("overflowX") != "visible") {
          box.visible = box.right > elem.scrollLeft && box.left < elem.scrollLeft + elem.clientWidth;
        }

        box.left -= elem.scrollLeft;
        box.top -= elem.scrollTop;

        if (elem === offsetParent) {
          box.left += elem.offsetLeft;
          box.top += elem.offsetTop;
          offsetParent = elem.offsetParent;
        }

        box.bottom = box.top + box.height;
        box.right = box.left + box.width;
      }

      return box;
    }

    function getActiveCellPosition() {
      return absBox(activeCellNode);
    }

    function getGridPosition() {
      return absBox($container[0])
    }

    function handleActiveCellPositionChange() {
      if (!activeCellNode) {
        return;
      }

      trigger(self.onActiveCellPositionChanged, {});

      if (currentEditor) {
        var cellBox = getActiveCellPosition();
        if (currentEditor.show && currentEditor.hide) {
          if (!cellBox.visible) {
            currentEditor.hide();
          } else {
            currentEditor.show();
          }
        }

        if (currentEditor.position) {
          currentEditor.position(cellBox);
        }
      }
    }

    function getCellEditor() {
      return currentEditor;
    }

    function getActiveCell() {
      if (!activeCellNode) {
        return null;
      } else {
        return {row: activeRow, cell: activeCell};
      }
    }

    function getActiveCellNode() {
      return activeCellNode;
    }

    function scrollRowIntoView(row, doPaging) {
      var rowAtTop = row * options.rowHeight;
      var rowAtBottom = (row + 1) * options.rowHeight - viewportH + (viewportHasHScroll ? scrollbarDimensions.height : 0);

      // need to page down?
      if ((row + 1) * options.rowHeight > scrollTop + viewportH + offset) {
        scrollTo(doPaging ? rowAtTop : rowAtBottom);
        render();
      }
      // or page up?
      else if (row * options.rowHeight < scrollTop + offset) {
        scrollTo(doPaging ? rowAtBottom : rowAtTop);
        render();
      }
    }

    function scrollRowToTop(row) {
      scrollTo(row * options.rowHeight);
      render();
    }

    function getColspan(row, cell) {
      var metadata = data.getItemMetadata && data.getItemMetadata(row);
      if (!metadata || !metadata.columns) {
        return 1;
      }

      var columnData = metadata.columns[columns[cell].id] || metadata.columns[cell];
      var colspan = (columnData && columnData.colspan);
      if (colspan === "*") {
        colspan = columns.length - cell;
      } else {
        colspan = colspan || 1;
      }

      return colspan;
    }

    function findFirstFocusableCell(row) {
      var cell = 0;
      while (cell < columns.length) {
        if (canCellBeActive(row, cell)) {
          return cell;
        }
        cell += getColspan(row, cell);
      }
      return null;
    }

    function findLastFocusableCell(row) {
      var cell = 0;
      var lastFocusableCell = null;
      while (cell < columns.length) {
        if (canCellBeActive(row, cell)) {
          lastFocusableCell = cell;
        }
        cell += getColspan(row, cell);
      }
      return lastFocusableCell;
    }

    function gotoRight(row, cell, posX) {
      if (cell >= columns.length) {
        return null;
      }

      do {
        cell += getColspan(row, cell);
      }
      while (cell < columns.length && !canCellBeActive(row, cell));

      if (cell < columns.length) {
        return {
          "row": row,
          "cell": cell,
          "posX": cell
        };
      }
      return null;
    }

    function gotoLeft(row, cell, posX) {
      if (cell <= 0) {
        return null;
      }

      var firstFocusableCell = findFirstFocusableCell(row);
      if (firstFocusableCell === null || firstFocusableCell >= cell) {
        return null;
      }

      var prev = {
        "row": row,
        "cell": firstFocusableCell,
        "posX": firstFocusableCell
      };
      var pos;
      while (true) {
        pos = gotoRight(prev.row, prev.cell, prev.posX);
        if (!pos) {
          return null;
        }
        if (pos.cell >= cell) {
          return prev;
        }
        prev = pos;
      }
    }

    function gotoDown(row, cell, posX) {
      var prevCell;
      while (true) {
        if (++row >= getDataLength() + (options.enableAddRow ? 1 : 0)) {
          return null;
        }

        prevCell = cell = 0;
        while (cell <= posX) {
          prevCell = cell;
          cell += getColspan(row, cell);
        }

        if (canCellBeActive(row, prevCell)) {
          return {
            "row": row,
            "cell": prevCell,
            "posX": posX
          };
        }
      }
    }

    function gotoUp(row, cell, posX) {
      var prevCell;
      while (true) {
        if (--row < 0) {
          return null;
        }

        prevCell = cell = 0;
        while (cell <= posX) {
          prevCell = cell;
          cell += getColspan(row, cell);
        }

        if (canCellBeActive(row, prevCell)) {
          return {
            "row": row,
            "cell": prevCell,
            "posX": posX
          };
        }
      }
    }

    function gotoNext(row, cell, posX) {
      var pos = gotoRight(row, cell, posX);
      if (pos) {
        return pos;
      }

      var firstFocusableCell = null;
      while (++row < getDataLength() + (options.enableAddRow ? 1 : 0)) {
        firstFocusableCell = findFirstFocusableCell(row);
        if (firstFocusableCell !== null) {
          return {
            "row": row,
            "cell": firstFocusableCell,
            "posX": firstFocusableCell
          };
        }
      }
      return null;
    }

    function gotoPrev(row, cell, posX) {
      var pos;
      var lastSelectableCell;
      while (!pos) {
        pos = gotoLeft(row, cell, posX);
        if (pos) {
          break;
        }
        if (--row < 0) {
          return null;
        }

        cell = 0;
        lastSelectableCell = findLastFocusableCell(row);
        if (lastSelectableCell !== null) {
          pos = {
            "row": row,
            "cell": lastSelectableCell,
            "posX": lastSelectableCell
          };
        }
      }
      return pos;
    }

    function navigateRight() {
      navigate("right");
    }

    function navigateLeft() {
      navigate("left");
    }

    function navigateDown() {
      navigate("down");
    }

    function navigateUp() {
      navigate("up");
    }

    function navigateNext() {
      navigate("next");
    }

    function navigatePrev() {
      navigate("prev");
    }

    function navigate(dir) {
      if (!activeCellNode || !options.enableCellNavigation) {
        return;
      }
      if (!getEditorLock().commitCurrentEdit()) {
        return;
      }
      setFocus();

      var stepFunctions = {
        "up": gotoUp,
        "down": gotoDown,
        "left": gotoLeft,
        "right": gotoRight,
        "prev": gotoPrev,
        "next": gotoNext
      };
      var stepFn = stepFunctions[dir];
      var pos = stepFn(activeRow, activeCell, activePosX);
      if (pos) {
        var isAddNewRow = (pos.row == getDataLength());
        scrollRowIntoView(pos.row, !isAddNewRow);
        scrollCellIntoView(pos.row, pos.cell);
        setActiveCellInternal(getCellNode(pos.row, pos.cell), isAddNewRow || options.autoEdit);
        activePosX = pos.posX;
      } else {
        setActiveCellInternal(getCellNode(activeRow, activeCell), (activeRow == getDataLength()) || options.autoEdit);
      }
    }

    function getCellNode(row, cell) {
      if (rowsCache[row]) {
        ensureCellNodesInRowsCache(row);
        return rowsCache[row].cellNodesByColumnIdx[cell];
      }
      return null;
    }

    function setActiveCell(row, cell) {
      if (!initialized) { return; }
      if (row > getDataLength() || row < 0 || cell >= columns.length || cell < 0) {
        return;
      }

      if (!options.enableCellNavigation) {
        return;
      }

      scrollRowIntoView(row, false);
      scrollCellIntoView(row, cell);
      setActiveCellInternal(getCellNode(row, cell), false);
    }

    function canCellBeActive(row, cell) {
      if (!options.enableCellNavigation || row >= getDataLength() + (options.enableAddRow ? 1 : 0) ||
          row < 0 || cell >= columns.length || cell < 0) {
        return false;
      }

      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
      if (rowMetadata && typeof rowMetadata.focusable === "boolean") {
        return rowMetadata.focusable;
      }

      var columnMetadata = rowMetadata && rowMetadata.columns;
      if (columnMetadata && columnMetadata[columns[cell].id] && typeof columnMetadata[columns[cell].id].focusable === "boolean") {
        return columnMetadata[columns[cell].id].focusable;
      }
      if (columnMetadata && columnMetadata[cell] && typeof columnMetadata[cell].focusable === "boolean") {
        return columnMetadata[cell].focusable;
      }

      if (typeof columns[cell].focusable === "boolean") {
        return columns[cell].focusable;
      }

      return true;
    }

    function canCellBeSelected(row, cell) {
      if (row >= getDataLength() || row < 0 || cell >= columns.length || cell < 0) {
        return false;
      }

      var rowMetadata = data.getItemMetadata && data.getItemMetadata(row);
      if (rowMetadata && typeof rowMetadata.selectable === "boolean") {
        return rowMetadata.selectable;
      }

      var columnMetadata = rowMetadata && rowMetadata.columns && (rowMetadata.columns[columns[cell].id] || rowMetadata.columns[cell]);
      if (columnMetadata && typeof columnMetadata.selectable === "boolean") {
        return columnMetadata.selectable;
      }

      if (typeof columns[cell].selectable === "boolean") {
        return columns[cell].selectable;
      }

      return true;
    }

    function gotoCell(row, cell, forceEdit) {
      if (!initialized) { return; }
      if (!canCellBeActive(row, cell)) {
        return;
      }

      if (!getEditorLock().commitCurrentEdit()) {
        return;
      }

      scrollRowIntoView(row, false);
      scrollCellIntoView(row, cell);

      var newCell = getCellNode(row, cell);

      // if selecting the 'add new' row, start editing right away
      setActiveCellInternal(newCell, forceEdit || (row === getDataLength()) || options.autoEdit);

      // if no editor was created, set the focus back on the grid
      if (!currentEditor) {
        setFocus();
      }
    }


    //////////////////////////////////////////////////////////////////////////////////////////////
    // IEditor implementation for the editor lock

    function commitCurrentEdit() {
      var item = getDataItem(activeRow);
      var column = columns[activeCell];

      if (currentEditor) {
        if (currentEditor.isValueChanged()) {
          var validationResults = currentEditor.validate();

          if (validationResults.valid) {
            if (activeRow < getDataLength()) {
              var editCommand = {
                row: activeRow,
                cell: activeCell,
                editor: currentEditor,
                serializedValue: currentEditor.serializeValue(),
                prevSerializedValue: serializedEditorValue,
                execute: function () {
                  this.editor.applyValue(item, this.serializedValue);
                  updateRow(this.row);
                },
                undo: function () {
                  this.editor.applyValue(item, this.prevSerializedValue);
                  updateRow(this.row);
                }
              };

              if (options.editCommandHandler) {
                makeActiveCellNormal();
                options.editCommandHandler(item, column, editCommand);
              } else {
                editCommand.execute();
                makeActiveCellNormal();
              }

              trigger(self.onCellChange, {
                row: activeRow,
                cell: activeCell,
                item: item
              });
            } else {
              var newItem = {};
              currentEditor.applyValue(newItem, currentEditor.serializeValue());
              makeActiveCellNormal();
              trigger(self.onAddNewRow, {item: newItem, column: column});
            }

            // check whether the lock has been re-acquired by event handlers
            return !getEditorLock().isActive();
          } else {
            // TODO: remove and put in onValidationError handlers in examples
            $(activeCellNode).addClass("invalid");
            $(activeCellNode).stop(true, true).effect("highlight", {color: "red"}, 300);

            trigger(self.onValidationError, {
              editor: currentEditor,
              cellNode: activeCellNode,
              validationResults: validationResults,
              row: activeRow,
              cell: activeCell,
              column: column
            });

            currentEditor.focus();
            return false;
          }
        }

        makeActiveCellNormal();
      }
      return true;
    }

    function cancelCurrentEdit() {
      makeActiveCellNormal();
      return true;
    }

    function rowsToRanges(rows) {
      var ranges = [];
      var lastCell = columns.length - 1;
      for (var i = 0; i < rows.length; i++) {
        ranges.push(new Slick.Range(rows[i], 0, rows[i], lastCell));
      }
      return ranges;
    }

    function getSelectedRows() {
      if (!selectionModel) {
        throw "Selection model is not set";
      }
      return selectedRows;
    }

    function setSelectedRows(rows) {
      if (!selectionModel) {
        throw "Selection model is not set";
      }
      selectionModel.setSelectedRanges(rowsToRanges(rows));
    }


    //////////////////////////////////////////////////////////////////////////////////////////////
    // Debug

    this.debug = function () {
      var s = "";

      s += ("\n" + "counter_rows_rendered:  " + counter_rows_rendered);
      s += ("\n" + "counter_rows_removed:  " + counter_rows_removed);
      s += ("\n" + "renderedRows:  " + renderedRows);
      s += ("\n" + "numVisibleRows:  " + numVisibleRows);
      s += ("\n" + "maxSupportedCssHeight:  " + maxSupportedCssHeight);
      s += ("\n" + "n(umber of pages):  " + n);
      s += ("\n" + "(current) page:  " + page);
      s += ("\n" + "page height (ph):  " + ph);
      s += ("\n" + "vScrollDir:  " + vScrollDir);

      alert(s);
    };

    // a debug helper to be able to access private members
    this.eval = function (expr) {
      return eval(expr);
    };

    //////////////////////////////////////////////////////////////////////////////////////////////
    // Public API

    $.extend(this, {
      "slickGridVersion": "2.0",

      // Events
      "onScroll": new Slick.Event(),
      "onSort": new Slick.Event(),
      "onHeaderMouseEnter": new Slick.Event(),
      "onHeaderMouseLeave": new Slick.Event(),
      "onHeaderContextMenu": new Slick.Event(),
      "onHeaderClick": new Slick.Event(),
      "onHeaderRendered": new Slick.Event(),
      "onBeforeHeaderDestroy": new Slick.Event(),
      "onMouseEnter": new Slick.Event(),
      "onMouseLeave": new Slick.Event(),
      "onClick": new Slick.Event(),
      "onDblClick": new Slick.Event(),
      "onContextMenu": new Slick.Event(),
      "onKeyDown": new Slick.Event(),
      "onAddNewRow": new Slick.Event(),
      "onValidationError": new Slick.Event(),
      "onViewportChanged": new Slick.Event(),
      "onColumnsReordered": new Slick.Event(),
      "onColumnsResized": new Slick.Event(),
      "onCellChange": new Slick.Event(),
      "onBeforeEditCell": new Slick.Event(),
      "onBeforeCellEditorDestroy": new Slick.Event(),
      "onBeforeDestroy": new Slick.Event(),
      "onActiveCellChanged": new Slick.Event(),
      "onActiveCellPositionChanged": new Slick.Event(),
      "onDragInit": new Slick.Event(),
      "onDragStart": new Slick.Event(),
      "onDrag": new Slick.Event(),
      "onDragEnd": new Slick.Event(),
      "onSelectedRowsChanged": new Slick.Event(),
      "onCellCssStylesChanged": new Slick.Event(),

      // Methods
      "registerPlugin": registerPlugin,
      "unregisterPlugin": unregisterPlugin,
      "getColumns": getColumns,
      "setColumns": setColumns,
      "getColumnIndex": getColumnIndex,
      "updateColumnHeader": updateColumnHeader,
      "setSortColumn": setSortColumn,
      "setSortColumns": setSortColumns,
      "getSortColumns": getSortColumns,
      "autosizeColumns": autosizeColumns,
      "getOptions": getOptions,
      "setOptions": setOptions,
      "getData": getData,
      "getDataLength": getDataLength,
      "getDataItem": getDataItem,
      "setData": setData,
      "getSelectionModel": getSelectionModel,
      "setSelectionModel": setSelectionModel,
      "getSelectedRows": getSelectedRows,
      "setSelectedRows": setSelectedRows,

      "render": render,
      "invalidate": invalidate,
      "invalidateRow": invalidateRow,
      "invalidateRows": invalidateRows,
      "invalidateAllRows": invalidateAllRows,
      "updateCell": updateCell,
      "updateRow": updateRow,
      "getViewport": getVisibleRange,
      "getRenderedRange": getRenderedRange,
      "resizeCanvas": resizeCanvas,
      "updateRowCount": updateRowCount,
      "scrollRowIntoView": scrollRowIntoView,
      "scrollRowToTop": scrollRowToTop,
      "scrollCellIntoView": scrollCellIntoView,
      "getCanvasNode": getCanvasNode,
      "focus": setFocus,

      "getCellFromPoint": getCellFromPoint,
      "getCellFromEvent": getCellFromEvent,
      "getActiveCell": getActiveCell,
      "setActiveCell": setActiveCell,
      "getActiveCellNode": getActiveCellNode,
      "getActiveCellPosition": getActiveCellPosition,
      "resetActiveCell": resetActiveCell,
      "editActiveCell": makeActiveCellEditable,
      "getCellEditor": getCellEditor,
      "getCellNode": getCellNode,
      "getCellNodeBox": getCellNodeBox,
      "canCellBeSelected": canCellBeSelected,
      "canCellBeActive": canCellBeActive,
      "navigatePrev": navigatePrev,
      "navigateNext": navigateNext,
      "navigateUp": navigateUp,
      "navigateDown": navigateDown,
      "navigateLeft": navigateLeft,
      "navigateRight": navigateRight,
      "gotoCell": gotoCell,
      "getTopPanel": getTopPanel,
      "showTopPanel": showTopPanel,
      "hideTopPanel": hideTopPanel,
      "showHeaderRowColumns": showHeaderRowColumns,
      "hideHeaderRowColumns": hideHeaderRowColumns,
      "getHeaderRow": getHeaderRow,
      "getHeaderRowColumn": getHeaderRowColumn,
      "getGridPosition": getGridPosition,
      "flashCell": flashCell,
      "addCellCssStyles": addCellCssStyles,
      "setCellCssStyles": setCellCssStyles,
      "removeCellCssStyles": removeCellCssStyles,
      "getCellCssStyles": getCellCssStyles,

      "init": finishInitialization,
      "destroy": destroy,

      // IEditor implementation
      "getEditorLock": getEditorLock,
      "getEditController": getEditController
    });

    init();
  }
}(jQuery));

define("ext/jquery-slickgrid/slick.grid", function(){});

define('lib/util/grid',[
    "jquery"
  , "ext/jquery-slickgrid/jquery.event.drag-2.0.min"
  , "ext/jquery-slickgrid/slick.core"
  , "ext/jquery-slickgrid/slick.grid"
],

function($) {
  return function(selector, data, columns, options) {
    return new Slick.Grid(selector, data, columns, options);
  }
});
define('modules/view/datasourcepreview',[
    "jquery"
  , "lib/util/grid"
  , "lib/model/dataloader"
],

function($, createGrid, createLoader) {
  return function(ctx) {
    var $el,
        grid;

    function createColumns(fields) {
      var columns = [];

      return fields.map(function(field) {
        return { id : name, name : field.name || field.field, field : field.field };
      });
    }

    function createOptions() {
      return {
          enableCellNavigation: false
        , enableColumnReorder: true
//        , autoHeight : true
        , forceFitColumns: true
      };
    }

    function createLoadedHandler(datasource) {
      return function(data) {
        var columns = createColumns(datasource.fields),
            options = createOptions();
//console.log(data, JSON.stringify(datasource.fields), columns, options);
        grid = createGrid($el, data, columns, options);
      };
    }

    function dataError(error) {

    }

    ctx.on("data.datasource.preview.render", function(datasource) {
      var loader = createLoader(datasource);
      loader.on("success", createLoadedHandler(datasource));
      loader.on("error", dataError);
      loader.load();
    });

    ctx.on("data.datasource.preview.clear", function() {
      if(grid) {
        grid.destroy();
        grid = null;
      }
    });

    ctx.on("data.datasource.selected", function(datasource) {
      ctx.trigger("data.datasource.preview.render", datasource);
    });

    ctx.on("data.datasource.deselected", function(datasource) {
      ctx.trigger("data.datasource.preview.clear");
    });

    ctx.on("view.data.dataviewer", function(container) {
      $el = $('<div class="datasource-preview"></div>').appendTo(container);
    });
  }
});
define('lib/model/value',[
  "jquery",
  "lib/util/dispatcher"
],

function($, createDispatcher) {
  return function(defaultValue, defaultValidator, defaultFilter) {
    var model,
        value = defaultValue,
        validator = defaultValidator || function() { return null;},
        filter = defaultFilter || function(v) { return v;},
        dispatcher = createDispatcher(),
        lastError
    ;

    return model = {
      _set : function(newvalue) {
        var oldvalue = value;
        value = filter(newvalue);
        dispatcher.trigger("value.change", value, oldvalue);
      },
      set : function(newvalue) {
        var test = validator(newvalue);
        if(test && ("object" === typeof test) && test.then) {
          // is a "promise", deal asynchronously
          test.then(function(validationresult) {
            if((lastError = validationresult) != null) {
              dispatcher.trigger("value.validationError", lastError, newvalue);
              return false;
            }
            model._set(newvalue);
          });
          return;
        }
        if((lastError = test) != null) {
          dispatcher.trigger("value.validationError", lastError, newvalue);
          return false;
        }
        model._set(newvalue);
        return true;
      },
      setDefault : function(newvalue) {
        var oldvalue = defaultValue;
        defaultValue = filter(newvalue);
        dispatcher.trigger("default.change", defaultValue, oldvalue);
        this.set(newvalue);
        return true;
      },
      reset : function() {
        if(defaultValue === value) return false;
        if(this.set(defaultValue)) {
          dispatcher.trigger("value.reset", defaultValue);
          return true;
        }
        return false;
      },
      get : function() {
        return value !== null && typeof value !== "undefined" && value;
      },
      getDefault : function() {
        return defaultValue;
      },
      validate : function(value) {
        return validator(value) == null;
      },
      lastError : function() {
        return lastError;
      },
      on : function(type, handler) {
        dispatcher.on(type, handler);
      },
      one : function(type, handler) {
        dispatcher.one(type, handler);
      },
      off : function(type, handler) {
        dispatcher.off(type, handler);
      },
      setValidator : function(newvalidator) {
        validator = newvalidator || function() { return null; };
        dispatcher.trigger("validator.change", validator);
      },
      setFilter : function(newfilter) {
        filter = newfilter || function() { return null; };
        dispatcher.trigger("filter.change", newfilter);
      },
      isDefault : function() {
        return value === defaultValue;
      },
      destroy : function() {
        $(["value.validationError", "value.change", "default.change", "value.reset", "validator.change", "filter.change"]).each(function(){
          dispatcher.off(this);
        });
        lastError = value = defaultValue = filter = validator = dispatcher = null;
      }
    }
  }
});
define('lib/util/view/editors/editor',[
  "jquery",
  "lib/model/value"
],

function($, createValue) {
  return function(el, options, params) {
    var editor;

    if(!params.set) {
      params.set = function(v) { params.input.val(v); };
    }

    if(!params.get) {
      params.get = function() { return params.input.val(); };
    }

    if(!params.validate) {
      params.validate = function() { return null; };
    }

    if(!params.filter) {
      params.filter = function(v) { return v; };
    }

    if(!params.destroy) {
      params.destroy = function() {
        params.input.off("change", params.onchange);
        params.onchange = null;
      };
    }

    if(!params.wireChange) {
      params.wireChange = function() {
        params.input.on("change", params.onchange);
      };
    }

    if(options.placeholder) {
      params.input.attr("placeholder", options.placeholder);
    }

    $('<div class="control-container"><span class="control"></span><span class="unit"></span></div><div class="error" style="display:none;">error goes here</div>').appendTo(el);
    params.input.appendTo(el.find(".control"));
    if(options.title)
      params.input.attr("title", options.title);
    var error = el.find(".error");
    if(options.unit) {
      el.find(".unit").html(options.unit);
      if(options.title)
        el.find(".unit").attr("title", options.title);
    }

    var value = createValue(options.default, params.validate, params.filter);
    function input_change() {
      value.set(params.get());
    }

    function value_change(value) {
      params.set(value);
      error.hide();
    }

    function value_validationError(err) {
      error.html(err);
      error.show();
    }

    params.onchange = input_change;
    value.on("value.change", value_change);
    value.on("value.validationError", value_validationError);

    params.wireChange();

    params.set(options.default);

    return editor = {
      value   : value,
      el      : el,
      params  : params,
      destroy : function() {
        params.destroy();
        value.destroy();
//        value.off("value.change", value_change);
//        value.off("value.validationError", value_validationError);
        el.children("*").remove();
      }
    };
  };
});
define('lib/util/view/editors/floateditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : 0.0 }, options);

    var $input = $('<input type="number" class="float" step="'+(options.step || '0.05')+'">');
    var params = {
      input : $input,
      validate : function(v) {
        if(isNaN(parseFloat(v)))
          return "must be a float value";
        v = parseFloat(v);
        if(("undefined" !== typeof options.min) && options.min > v)
          return "must be at least " + options.min;
        if(("undefined" !== typeof options.max) && options.max < v)
          return "must be no more than " + options.max;
        return null;
      },
      filter : function(v) {
        return parseFloat(v);
      }
    };

    if("undefined" !== typeof options.min) {
      $input.attr("min", options.min);
    }
    if("undefined" !== typeof options.max) {
      $input.attr("max", options.max);
    }

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/inteditor',[
    "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : 0 }, options);

    var $input = $('<input type="number" step="'+(options.step || '1')+'" class="int">');

    var params = {
      input : $input,
      validate : function(v) {
        if(""+parseInt(v) !== ""+v)
          return "must be an integer value";
        v = parseInt(v);
        if(("undefined" !== typeof options.min) && options.min > v)
          return "must be at least " + options.min;
        if(("undefined" !== typeof options.max) && options.max < v)
          return "must be no more than " + options.max;
        return null;
      },
      filter : function(v) {
        return parseInt(v);
      }
    };

    if("undefined" !== typeof options.min) {
      $input.attr("min", options.min);
    }
    if("undefined" !== typeof options.max) {
      $input.attr("max", options.max);
    }

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/booleditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({ default : false }, options);

    var $input = $('<input type="checkbox" value="true">');
    var params = {
      input : $input,
      get : function() {
        return $input.prop("checked");
      },
      set : function(v) {
        $input.prop("checked", v);
      },
      validate : function(v) {
        if("string" === typeof v) {
          v = v.toLowerCase();
          switch(v) {
            case "on", "off", "true", "false":
              return null;
            default:
              return v+" is not an acceptable boolean value";
          }
        }
        return null;
      },
      filter : function(v) {
        return v === "true" || v === "on" || v === 1 || !!v;
      }
    };

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/expressioneditor',[
    "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : "" }, options);

    var $input = $('<input type="text" class="expression">');

    var params = {
      input : $input,
      validate : options.validate || function(v) {
        return (""+v).substr(0, 1) === "=" ? null : "an expression must begin with =";
      },
      filter : options.filter || function(v) {
        if("string" === typeof v)
          return v.trim();
        return "="+v;
      }
    };

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/stringeditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : "" }, options);
    var $input = $('<input type="text" class="string">');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v.trim(); }
    };

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/texteditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : null }, options);
    var $input = $('<textarea class="text"></textarea>');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v.trim(); }
    };

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/selectioneditor',[
    "jquery"
  , "lib/util/view/editors/editor"
],

function($, createEditor) {
  function createOptionElement(value, label, index) {
    if(!label) label = value;
    var $el = $('<option>'+label+'</option>');
    if(value) {
      $el.attr("value", value);
    } else {
      $el.addClass("selection-text");
    }
    if("undefined" !== typeof index)
      $el.attr("data-index", index);
    return $el;
  }
/*
  function createSubEditor(el, info) {
    editors.create(el, info.type, info.options);
  }
*/
  return function(el, options) {
    options = $.extend({ default : null, selectiontext : false, values : [] }, options);

    var subeditor,
        $subeditor = $('<div class="subeditor"></div>'),
        $input = $('<select></select>'),
        params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v.trim(); }
    };

    function removeSelectText() {
      if(!$input.val()) return;
      $input.find('option.selection-text').remove();
      $input.off("change", removeSelectText);
    }

    if(options.selectiontext) {
      var $el = createOptionElement(null, options.selectiontext);
      $input.append($el);
      $input.on("change", removeSelectText);
    }

    $(options.values).each(function(i) {
      var $el = createOptionElement(this.value, this.label, i);
      $input.append($el);
    });

    var lastIndex, subDefault;
    $input.on("change", function() {
      var index = $(this).find('[value="'+$(this).val()+'"]').attr("data-index"),
          einfo;
      if(index === lastIndex) return;
      lastIndex = index;
      require(["lib/util/view/editors/editors"], function (editors) {
        if(subeditor) {
          subeditor.destroy();
          $subeditor.children("*").remove();
          subeditor = null;
        }
        if("undefined" === typeof index || !(einfo = options.values[index].editor)) {
          $input.removeClass("with-editor");
          return;
        }
        $input.addClass("with-editor");
        var eoptions = $.extend({}, einfo.options, { default : subDefault || einfo.options.default });
        subeditor = editors.create($subeditor, einfo.type, eoptions);
        function setSubValue() {
          var $o = $input.find('option[data-index="'+index+'"]'),
            value = $o.attr("value");
          value = value.substr(0, value.lastIndexOf(":")+1);
          $o.attr("value", value + subeditor.value.get());
          $input.trigger("change");
        }

        subeditor.value.on("value.change", setSubValue);
        setSubValue();
      });
    });

    params.set = function(v) {
      if(v === params.input.val()) return;
      var pos;
      if(v.indexOf && (pos = v.indexOf(":")) >= 0) {
        var prefix = v.substr(0, pos+1);
        $input.find("option").each(function() {
          var $option = $(this),
              value = $option.attr("value");
          if(value.substr(0, prefix.length) !== prefix) {
            return;
          }
          subDefault = v.substr(pos+1);
          $option.attr("value", v);
          params.input.val(v);
          $input.change();
          return false;
        });
      } else {
        params.input.val(v);
      }

    };
    params.get = function() {
      return params.input.val();
    };
    params.validate = function() {
      return null;
    };
    params.filter = function(v) {
      return v;
    };


    if(!params.destroy) {
      params.destroy = function() {
        params.input.off("change", params.onchange);
        params.onchange = null;
      };
    }

    var ed = createEditor(el, options, params);
    el.append($subeditor);
    $input.trigger("change");
    return ed;
  };
});
define('lib/util/view/editors/templateeditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : "" }, options);

    var $input = $('<input type="text" class="template">');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v.trim(); }
    };

    return createEditor(el, options, params);
  };
});
define('config/rgcolors',[],
function() {
  return [
    { "name" : "rg-colors-accent-3-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086"] },
    { "name" : "rg-colors-accent-3-qualr.css", "colors" : ["#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-accent-4-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086", "#FFFF99"] },
    { "name" : "rg-colors-accent-4-qualr.css", "colors" : ["#FFFF99", "#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-accent-5-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086", "#FFFF99", "#386CB0"] },
    { "name" : "rg-colors-accent-5-qualr.css", "colors" : ["#386CB0", "#FFFF99", "#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-accent-6-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086", "#FFFF99", "#386CB0", "#F0027F"] },
    { "name" : "rg-colors-accent-6-qualr.css", "colors" : ["#F0027F", "#386CB0", "#FFFF99", "#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-accent-7-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086", "#FFFF99", "#386CB0", "#F0027F", "#BF5B17"] },
    { "name" : "rg-colors-accent-7-qualr.css", "colors" : ["#BF5B17", "#F0027F", "#386CB0", "#FFFF99", "#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-accent-8-qual.css", "colors" : ["#7FC97F", "#BEAED4", "#FDC086", "#FFFF99", "#386CB0", "#F0027F", "#BF5B17", "#666666"] },
    { "name" : "rg-colors-accent-8-qualr.css", "colors" : ["#666666", "#BF5B17", "#F0027F", "#386CB0", "#FFFF99", "#FDC086", "#BEAED4", "#7FC97F"] },
    { "name" : "rg-colors-blues-3-seq.css", "colors" : ["#DEEBF7", "#9ECAE1", "#3182BD"] },
    { "name" : "rg-colors-blues-3-seqr.css", "colors" : ["#3182BD", "#9ECAE1", "#DEEBF7"] },
    { "name" : "rg-colors-blues-4-seq.css", "colors" : ["#EFF3FF", "#BDD7E7", "#6BAED6", "#2171B5"] },
    { "name" : "rg-colors-blues-4-seqr.css", "colors" : ["#2171B5", "#6BAED6", "#BDD7E7", "#EFF3FF"] },
    { "name" : "rg-colors-blues-5-seq.css", "colors" : ["#EFF3FF", "#BDD7E7", "#6BAED6", "#3182BD", "#08519C"] },
    { "name" : "rg-colors-blues-5-seqr.css", "colors" : ["#08519C", "#3182BD", "#6BAED6", "#BDD7E7", "#EFF3FF"] },
    { "name" : "rg-colors-blues-6-seq.css", "colors" : ["#EFF3FF", "#C6DBEF", "#9ECAE1", "#6BAED6", "#3182BD", "#08519C"] },
    { "name" : "rg-colors-blues-6-seqr.css", "colors" : ["#08519C", "#3182BD", "#6BAED6", "#9ECAE1", "#C6DBEF", "#EFF3FF"] },
    { "name" : "rg-colors-blues-7-seq.css", "colors" : ["#EFF3FF", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5", "#084594"] },
    { "name" : "rg-colors-blues-7-seqr.css", "colors" : ["#084594", "#2171B5", "#4292C6", "#6BAED6", "#9ECAE1", "#C6DBEF", "#EFF3FF"] },
    { "name" : "rg-colors-blues-8-seq.css", "colors" : ["#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5", "#084594"] },
    { "name" : "rg-colors-blues-8-seqr.css", "colors" : ["#084594", "#2171B5", "#4292C6", "#6BAED6", "#9ECAE1", "#C6DBEF", "#DEEBF7", "#F7FBFF"] },
    { "name" : "rg-colors-blues-9-seq.css", "colors" : ["#F7FBFF", "#DEEBF7", "#C6DBEF", "#9ECAE1", "#6BAED6", "#4292C6", "#2171B5", "#08519C", "#08306B"] },
    { "name" : "rg-colors-blues-9-seqr.css", "colors" : ["#08306B", "#08519C", "#2171B5", "#4292C6", "#6BAED6", "#9ECAE1", "#C6DBEF", "#DEEBF7", "#F7FBFF"] },
    { "name" : "rg-colors-brbg-10-div.css", "colors" : ["#543005", "#8C510A", "#BF812D", "#DFC27D", "#F6E8C3", "#C7EAE5", "#80CDC1", "#35978F", "#01665E", "#003C30"] },
    { "name" : "rg-colors-brbg-10-divr.css", "colors" : ["#003C30", "#01665E", "#35978F", "#80CDC1", "#C7EAE5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A", "#543005"] },
    { "name" : "rg-colors-brbg-11-div.css", "colors" : ["#543005", "#8C510A", "#BF812D", "#DFC27D", "#F6E8C3", "#F5F5F5", "#C7EAE5", "#80CDC1", "#35978F", "#01665E", "#003C30"] },
    { "name" : "rg-colors-brbg-11-divr.css", "colors" : ["#003C30", "#01665E", "#35978F", "#80CDC1", "#C7EAE5", "#F5F5F5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A", "#543005"] },
    { "name" : "rg-colors-brbg-3-div.css", "colors" : ["#D8B365", "#F5F5F5", "#5AB4AC"] },
    { "name" : "rg-colors-brbg-3-divr.css", "colors" : ["#5AB4AC", "#F5F5F5", "#D8B365"] },
    { "name" : "rg-colors-brbg-4-div.css", "colors" : ["#A6611A", "#DFC27D", "#80CDC1", "#018571"] },
    { "name" : "rg-colors-brbg-4-divr.css", "colors" : ["#018571", "#80CDC1", "#DFC27D", "#A6611A"] },
    { "name" : "rg-colors-brbg-5-div.css", "colors" : ["#A6611A", "#DFC27D", "#F5F5F5", "#80CDC1", "#018571"] },
    { "name" : "rg-colors-brbg-5-divr.css", "colors" : ["#018571", "#80CDC1", "#F5F5F5", "#DFC27D", "#A6611A"] },
    { "name" : "rg-colors-brbg-6-div.css", "colors" : ["#8C510A", "#D8B365", "#F6E8C3", "#C7EAE5", "#5AB4AC", "#01665E"] },
    { "name" : "rg-colors-brbg-6-divr.css", "colors" : ["#01665E", "#5AB4AC", "#C7EAE5", "#F6E8C3", "#D8B365", "#8C510A"] },
    { "name" : "rg-colors-brbg-7-div.css", "colors" : ["#8C510A", "#D8B365", "#F6E8C3", "#F5F5F5", "#C7EAE5", "#5AB4AC", "#01665E"] },
    { "name" : "rg-colors-brbg-7-divr.css", "colors" : ["#01665E", "#5AB4AC", "#C7EAE5", "#F5F5F5", "#F6E8C3", "#D8B365", "#8C510A"] },
    { "name" : "rg-colors-brbg-8-div.css", "colors" : ["#8C510A", "#BF812D", "#DFC27D", "#F6E8C3", "#C7EAE5", "#80CDC1", "#35978F", "#01665E"] },
    { "name" : "rg-colors-brbg-8-divr.css", "colors" : ["#01665E", "#35978F", "#80CDC1", "#C7EAE5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A"] },
    { "name" : "rg-colors-brbg-9-div.css", "colors" : ["#8C510A", "#BF812D", "#DFC27D", "#F6E8C3", "#F5F5F5", "#C7EAE5", "#80CDC1", "#35978F", "#01665E"] },
    { "name" : "rg-colors-brbg-9-divr.css", "colors" : ["#01665E", "#35978F", "#80CDC1", "#C7EAE5", "#F5F5F5", "#F6E8C3", "#DFC27D", "#BF812D", "#8C510A"] },
    { "name" : "rg-colors-bugn-3-seq.css", "colors" : ["#E5F5F9", "#99D8C9", "#2CA25F"] },
    { "name" : "rg-colors-bugn-3-seqr.css", "colors" : ["#2CA25F", "#99D8C9", "#E5F5F9"] },
    { "name" : "rg-colors-bugn-4-seq.css", "colors" : ["#EDF8FB", "#B2E2E2", "#66C2A4", "#238B45"] },
    { "name" : "rg-colors-bugn-4-seqr.css", "colors" : ["#238B45", "#66C2A4", "#B2E2E2", "#EDF8FB"] },
    { "name" : "rg-colors-bugn-5-seq.css", "colors" : ["#EDF8FB", "#B2E2E2", "#66C2A4", "#2CA25F", "#006D2C"] },
    { "name" : "rg-colors-bugn-5-seqr.css", "colors" : ["#006D2C", "#2CA25F", "#66C2A4", "#B2E2E2", "#EDF8FB"] },
    { "name" : "rg-colors-bugn-6-seq.css", "colors" : ["#EDF8FB", "#CCECE6", "#99D8C9", "#66C2A4", "#2CA25F", "#006D2C"] },
    { "name" : "rg-colors-bugn-6-seqr.css", "colors" : ["#006D2C", "#2CA25F", "#66C2A4", "#99D8C9", "#CCECE6", "#EDF8FB"] },
    { "name" : "rg-colors-bugn-7-seq.css", "colors" : ["#EDF8FB", "#CCECE6", "#99D8C9", "#66C2A4", "#41AE76", "#238B45", "#005824"] },
    { "name" : "rg-colors-bugn-7-seqr.css", "colors" : ["#005824", "#238B45", "#41AE76", "#66C2A4", "#99D8C9", "#CCECE6", "#EDF8FB"] },
    { "name" : "rg-colors-bugn-8-seq.css", "colors" : ["#F7FCFD", "#E5F5F9", "#CCECE6", "#99D8C9", "#66C2A4", "#41AE76", "#238B45", "#005824"] },
    { "name" : "rg-colors-bugn-8-seqr.css", "colors" : ["#005824", "#238B45", "#41AE76", "#66C2A4", "#99D8C9", "#CCECE6", "#E5F5F9", "#F7FCFD"] },
    { "name" : "rg-colors-bugn-9-seq.css", "colors" : ["#F7FCFD", "#E5F5F9", "#CCECE6", "#99D8C9", "#66C2A4", "#41AE76", "#238B45", "#006D2C", "#00441B"] },
    { "name" : "rg-colors-bugn-9-seqr.css", "colors" : ["#00441B", "#006D2C", "#238B45", "#41AE76", "#66C2A4", "#99D8C9", "#CCECE6", "#E5F5F9", "#F7FCFD"] },
    { "name" : "rg-colors-bupu-3-seq.css", "colors" : ["#E0ECF4", "#9EBCDA", "#8856A7"] },
    { "name" : "rg-colors-bupu-3-seqr.css", "colors" : ["#8856A7", "#9EBCDA", "#E0ECF4"] },
    { "name" : "rg-colors-bupu-4-seq.css", "colors" : ["#EDF8FB", "#B3CDE3", "#8C96C6", "#88419D"] },
    { "name" : "rg-colors-bupu-4-seqr.css", "colors" : ["#88419D", "#8C96C6", "#B3CDE3", "#EDF8FB"] },
    { "name" : "rg-colors-bupu-5-seq.css", "colors" : ["#EDF8FB", "#B3CDE3", "#8C96C6", "#8856A7", "#810F7C"] },
    { "name" : "rg-colors-bupu-5-seqr.css", "colors" : ["#810F7C", "#8856A7", "#8C96C6", "#B3CDE3", "#EDF8FB"] },
    { "name" : "rg-colors-bupu-6-seq.css", "colors" : ["#EDF8FB", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8856A7", "#810F7C"] },
    { "name" : "rg-colors-bupu-6-seqr.css", "colors" : ["#810F7C", "#8856A7", "#8C96C6", "#9EBCDA", "#BFD3E6", "#EDF8FB"] },
    { "name" : "rg-colors-bupu-7-seq.css", "colors" : ["#EDF8FB", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8C6BB1", "#88419D", "#6E016B"] },
    { "name" : "rg-colors-bupu-7-seqr.css", "colors" : ["#6E016B", "#88419D", "#8C6BB1", "#8C96C6", "#9EBCDA", "#BFD3E6", "#EDF8FB"] },
    { "name" : "rg-colors-bupu-8-seq.css", "colors" : ["#F7FCFD", "#E0ECF4", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8C6BB1", "#88419D", "#6E016B"] },
    { "name" : "rg-colors-bupu-8-seqr.css", "colors" : ["#6E016B", "#88419D", "#8C6BB1", "#8C96C6", "#9EBCDA", "#BFD3E6", "#E0ECF4", "#F7FCFD"] },
    { "name" : "rg-colors-bupu-9-seq.css", "colors" : ["#F7FCFD", "#E0ECF4", "#BFD3E6", "#9EBCDA", "#8C96C6", "#8C6BB1", "#88419D", "#810F7C", "#4D004B"] },
    { "name" : "rg-colors-bupu-9-seqr.css", "colors" : ["#4D004B", "#810F7C", "#88419D", "#8C6BB1", "#8C96C6", "#9EBCDA", "#BFD3E6", "#E0ECF4", "#F7FCFD"] },
    { "name" : "rg-colors-charts.css", "colors" : ["#1776B6", "#78ACD6", "#FF7F00", "#FFCBAA", "#2CA02C", "#ACD9A5", "#D62728", "#EEAAA8"] },
    { "name" : "rg-colors-chartsr.css", "colors" : ["#EEAAA8", "#D62728", "#ACD9A5", "#2CA02C", "#FFCBAA", "#FF7F00", "#78ACD6", "#1776B6"] },
    { "name" : "rg-colors-dark2-3-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3"] },
    { "name" : "rg-colors-dark2-3-qualr.css", "colors" : ["#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-dark2-4-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3", "#E7298A"] },
    { "name" : "rg-colors-dark2-4-qualr.css", "colors" : ["#E7298A", "#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-dark2-5-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E"] },
    { "name" : "rg-colors-dark2-5-qualr.css", "colors" : ["#66A61E", "#E7298A", "#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-dark2-6-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02"] },
    { "name" : "rg-colors-dark2-6-qualr.css", "colors" : ["#E6AB02", "#66A61E", "#E7298A", "#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-dark2-7-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D"] },
    { "name" : "rg-colors-dark2-7-qualr.css", "colors" : ["#A6761D", "#E6AB02", "#66A61E", "#E7298A", "#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-dark2-8-qual.css", "colors" : ["#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666"] },
    { "name" : "rg-colors-dark2-8-qualr.css", "colors" : ["#666666", "#A6761D", "#E6AB02", "#66A61E", "#E7298A", "#7570B3", "#D95F02", "#1B9E77"] },
    { "name" : "rg-colors-default.css", "colors" : ["#1F77B4", "#FF7F0E", "#2CA02C", "#D62728", "#9467BD", "#8C564B", "#E377C2", "#7F7F7F", "#BCBD22", "#17BECF"] },
    { "name" : "rg-colors-defaultr.css", "colors" : ["#17BECF", "#BCBD22", "#7F7F7F", "#E377C2", "#8C564B", "#9467BD", "#D62728", "#2CA02C", "#FF7F0E", "#1F77B4"] },
    { "name" : "rg-colors-gnbu-3-seq.css", "colors" : ["#E0F3DB", "#A8DDB5", "#43A2CA"] },
    { "name" : "rg-colors-gnbu-3-seqr.css", "colors" : ["#43A2CA", "#A8DDB5", "#E0F3DB"] },
    { "name" : "rg-colors-gnbu-4-seq.css", "colors" : ["#F0F9E8", "#BAE4BC", "#7BCCC4", "#2B8CBE"] },
    { "name" : "rg-colors-gnbu-4-seqr.css", "colors" : ["#2B8CBE", "#7BCCC4", "#BAE4BC", "#F0F9E8"] },
    { "name" : "rg-colors-gnbu-5-seq.css", "colors" : ["#F0F9E8", "#BAE4BC", "#7BCCC4", "#43A2CA", "#0868AC"] },
    { "name" : "rg-colors-gnbu-5-seqr.css", "colors" : ["#0868AC", "#43A2CA", "#7BCCC4", "#BAE4BC", "#F0F9E8"] },
    { "name" : "rg-colors-gnbu-6-seq.css", "colors" : ["#F0F9E8", "#CCEBC5", "#A8DDB5", "#7BCCC4", "#43A2CA", "#0868AC"] },
    { "name" : "rg-colors-gnbu-6-seqr.css", "colors" : ["#0868AC", "#43A2CA", "#7BCCC4", "#A8DDB5", "#CCEBC5", "#F0F9E8"] },
    { "name" : "rg-colors-gnbu-7-seq.css", "colors" : ["#F0F9E8", "#CCEBC5", "#A8DDB5", "#7BCCC4", "#4EB3D3", "#2B8CBE", "#08589E"] },
    { "name" : "rg-colors-gnbu-7-seqr.css", "colors" : ["#08589E", "#2B8CBE", "#4EB3D3", "#7BCCC4", "#A8DDB5", "#CCEBC5", "#F0F9E8"] },
    { "name" : "rg-colors-gnbu-8-seq.css", "colors" : ["#F7FCF0", "#E0F3DB", "#CCEBC5", "#A8DDB5", "#7BCCC4", "#4EB3D3", "#2B8CBE", "#08589E"] },
    { "name" : "rg-colors-gnbu-8-seqr.css", "colors" : ["#08589E", "#2B8CBE", "#4EB3D3", "#7BCCC4", "#A8DDB5", "#CCEBC5", "#E0F3DB", "#F7FCF0"] },
    { "name" : "rg-colors-gnbu-9-seq.css", "colors" : ["#F7FCF0", "#E0F3DB", "#CCEBC5", "#A8DDB5", "#7BCCC4", "#4EB3D3", "#2B8CBE", "#0868AC", "#084081"] },
    { "name" : "rg-colors-gnbu-9-seqr.css", "colors" : ["#084081", "#0868AC", "#2B8CBE", "#4EB3D3", "#7BCCC4", "#A8DDB5", "#CCEBC5", "#E0F3DB", "#F7FCF0"] },
    { "name" : "rg-colors-greens-3-seq.css", "colors" : ["#E5F5E0", "#A1D99B", "#31A354"] },
    { "name" : "rg-colors-greens-3-seqr.css", "colors" : ["#31A354", "#A1D99B", "#E5F5E0"] },
    { "name" : "rg-colors-greens-4-seq.css", "colors" : ["#EDF8E9", "#BAE4B3", "#74C476", "#238B45"] },
    { "name" : "rg-colors-greens-4-seqr.css", "colors" : ["#238B45", "#74C476", "#BAE4B3", "#EDF8E9"] },
    { "name" : "rg-colors-greens-5-seq.css", "colors" : ["#EDF8E9", "#BAE4B3", "#74C476", "#31A354", "#006D2C"] },
    { "name" : "rg-colors-greens-5-seqr.css", "colors" : ["#006D2C", "#31A354", "#74C476", "#BAE4B3", "#EDF8E9"] },
    { "name" : "rg-colors-greens-6-seq.css", "colors" : ["#EDF8E9", "#C7E9C0", "#A1D99B", "#74C476", "#31A354", "#006D2C"] },
    { "name" : "rg-colors-greens-6-seqr.css", "colors" : ["#006D2C", "#31A354", "#74C476", "#A1D99B", "#C7E9C0", "#EDF8E9"] },
    { "name" : "rg-colors-greens-7-seq.css", "colors" : ["#EDF8E9", "#C7E9C0", "#A1D99B", "#74C476", "#41AB5D", "#238B45", "#005A32"] },
    { "name" : "rg-colors-greens-7-seqr.css", "colors" : ["#005A32", "#238B45", "#41AB5D", "#74C476", "#A1D99B", "#C7E9C0", "#EDF8E9"] },
    { "name" : "rg-colors-greens-8-seq.css", "colors" : ["#F7FCF5", "#E5F5E0", "#C7E9C0", "#A1D99B", "#74C476", "#41AB5D", "#238B45", "#005A32"] },
    { "name" : "rg-colors-greens-8-seqr.css", "colors" : ["#005A32", "#238B45", "#41AB5D", "#74C476", "#A1D99B", "#C7E9C0", "#E5F5E0", "#F7FCF5"] },
    { "name" : "rg-colors-greens-9-seq.css", "colors" : ["#F7FCF5", "#E5F5E0", "#C7E9C0", "#A1D99B", "#74C476", "#41AB5D", "#238B45", "#006D2C", "#00441B"] },
    { "name" : "rg-colors-greens-9-seqr.css", "colors" : ["#00441B", "#006D2C", "#238B45", "#41AB5D", "#74C476", "#A1D99B", "#C7E9C0", "#E5F5E0", "#F7FCF5"] },
    { "name" : "rg-colors-greys-3-seq.css", "colors" : ["#F0F0F0", "#BDBDBD", "#636363"] },
    { "name" : "rg-colors-greys-3-seqr.css", "colors" : ["#636363", "#BDBDBD", "#F0F0F0"] },
    { "name" : "rg-colors-greys-4-seq.css", "colors" : ["#F7F7F7", "#CCCCCC", "#969696", "#525252"] },
    { "name" : "rg-colors-greys-4-seqr.css", "colors" : ["#525252", "#969696", "#CCCCCC", "#F7F7F7"] },
    { "name" : "rg-colors-greys-5-seq.css", "colors" : ["#F7F7F7", "#CCCCCC", "#969696", "#636363", "#252525"] },
    { "name" : "rg-colors-greys-5-seqr.css", "colors" : ["#252525", "#636363", "#969696", "#CCCCCC", "#F7F7F7"] },
    { "name" : "rg-colors-greys-6-seq.css", "colors" : ["#F7F7F7", "#D9D9D9", "#BDBDBD", "#969696", "#636363", "#252525"] },
    { "name" : "rg-colors-greys-6-seqr.css", "colors" : ["#252525", "#636363", "#969696", "#BDBDBD", "#D9D9D9", "#F7F7F7"] },
    { "name" : "rg-colors-greys-7-seq.css", "colors" : ["#F7F7F7", "#D9D9D9", "#BDBDBD", "#969696", "#737373", "#525252", "#252525"] },
    { "name" : "rg-colors-greys-7-seqr.css", "colors" : ["#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F7F7F7"] },
    { "name" : "rg-colors-greys-8-seq.css", "colors" : ["#FFFFFF", "#F0F0F0", "#D9D9D9", "#BDBDBD", "#969696", "#737373", "#525252", "#252525"] },
    { "name" : "rg-colors-greys-8-seqr.css", "colors" : ["#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0", "#FFFFFF"] },
    { "name" : "rg-colors-greys-9-seq.css", "colors" : ["#FFFFFF", "#F0F0F0", "#D9D9D9", "#BDBDBD", "#969696", "#737373", "#525252", "#252525", "#000000"] },
    { "name" : "rg-colors-greys-9-seqr.css", "colors" : ["#000000", "#252525", "#525252", "#737373", "#969696", "#BDBDBD", "#D9D9D9", "#F0F0F0", "#FFFFFF"] },
    { "name" : "rg-colors-oranges-3-seq.css", "colors" : ["#FEE6CE", "#FDAE6B", "#E6550D"] },
    { "name" : "rg-colors-oranges-3-seqr.css", "colors" : ["#E6550D", "#FDAE6B", "#FEE6CE"] },
    { "name" : "rg-colors-oranges-4-seq.css", "colors" : ["#FEEDDE", "#FDBE85", "#FD8D3C", "#D94701"] },
    { "name" : "rg-colors-oranges-4-seqr.css", "colors" : ["#D94701", "#FD8D3C", "#FDBE85", "#FEEDDE"] },
    { "name" : "rg-colors-oranges-5-seq.css", "colors" : ["#FEEDDE", "#FDBE85", "#FD8D3C", "#E6550D", "#A63603"] },
    { "name" : "rg-colors-oranges-5-seqr.css", "colors" : ["#A63603", "#E6550D", "#FD8D3C", "#FDBE85", "#FEEDDE"] },
    { "name" : "rg-colors-oranges-6-seq.css", "colors" : ["#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#E6550D", "#A63603"] },
    { "name" : "rg-colors-oranges-6-seqr.css", "colors" : ["#A63603", "#E6550D", "#FD8D3C", "#FDAE6B", "#FDD0A2", "#FEEDDE"] },
    { "name" : "rg-colors-oranges-7-seq.css", "colors" : ["#FEEDDE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"] },
    { "name" : "rg-colors-oranges-7-seqr.css", "colors" : ["#8C2D04", "#D94801", "#F16913", "#FD8D3C", "#FDAE6B", "#FDD0A2", "#FEEDDE"] },
    { "name" : "rg-colors-oranges-8-seq.css", "colors" : ["#FFF5EB", "#FEE6CE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#8C2D04"] },
    { "name" : "rg-colors-oranges-8-seqr.css", "colors" : ["#8C2D04", "#D94801", "#F16913", "#FD8D3C", "#FDAE6B", "#FDD0A2", "#FEE6CE", "#FFF5EB"] },
    { "name" : "rg-colors-oranges-9-seq.css", "colors" : ["#FFF5EB", "#FEE6CE", "#FDD0A2", "#FDAE6B", "#FD8D3C", "#F16913", "#D94801", "#A63603", "#7F2704"] },
    { "name" : "rg-colors-oranges-9-seqr.css", "colors" : ["#7F2704", "#A63603", "#D94801", "#F16913", "#FD8D3C", "#FDAE6B", "#FDD0A2", "#FEE6CE", "#FFF5EB"] },
    { "name" : "rg-colors-orrd-3-seq.css", "colors" : ["#FEE8C8", "#FDBB84", "#E34A33"] },
    { "name" : "rg-colors-orrd-3-seqr.css", "colors" : ["#E34A33", "#FDBB84", "#FEE8C8"] },
    { "name" : "rg-colors-orrd-4-seq.css", "colors" : ["#FEF0D9", "#FDCC8A", "#FC8D59", "#D7301F"] },
    { "name" : "rg-colors-orrd-4-seqr.css", "colors" : ["#D7301F", "#FC8D59", "#FDCC8A", "#FEF0D9"] },
    { "name" : "rg-colors-orrd-5-seq.css", "colors" : ["#FEF0D9", "#FDCC8A", "#FC8D59", "#E34A33", "#B30000"] },
    { "name" : "rg-colors-orrd-5-seqr.css", "colors" : ["#B30000", "#E34A33", "#FC8D59", "#FDCC8A", "#FEF0D9"] },
    { "name" : "rg-colors-orrd-6-seq.css", "colors" : ["#FEF0D9", "#FDD49E", "#FDBB84", "#FC8D59", "#E34A33", "#B30000"] },
    { "name" : "rg-colors-orrd-6-seqr.css", "colors" : ["#B30000", "#E34A33", "#FC8D59", "#FDBB84", "#FDD49E", "#FEF0D9"] },
    { "name" : "rg-colors-orrd-7-seq.css", "colors" : ["#FEF0D9", "#FDD49E", "#FDBB84", "#FC8D59", "#EF6548", "#D7301F", "#990000"] },
    { "name" : "rg-colors-orrd-7-seqr.css", "colors" : ["#990000", "#D7301F", "#EF6548", "#FC8D59", "#FDBB84", "#FDD49E", "#FEF0D9"] },
    { "name" : "rg-colors-orrd-8-seq.css", "colors" : ["#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84", "#FC8D59", "#EF6548", "#D7301F", "#990000"] },
    { "name" : "rg-colors-orrd-8-seqr.css", "colors" : ["#990000", "#D7301F", "#EF6548", "#FC8D59", "#FDBB84", "#FDD49E", "#FEE8C8", "#FFF7EC"] },
    { "name" : "rg-colors-orrd-9-seq.css", "colors" : ["#FFF7EC", "#FEE8C8", "#FDD49E", "#FDBB84", "#FC8D59", "#EF6548", "#D7301F", "#B30000", "#7F0000"] },
    { "name" : "rg-colors-orrd-9-seqr.css", "colors" : ["#7F0000", "#B30000", "#D7301F", "#EF6548", "#FC8D59", "#FDBB84", "#FDD49E", "#FEE8C8", "#FFF7EC"] },
    { "name" : "rg-colors-paired-10-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A"] },
    { "name" : "rg-colors-paired-10-qualr.css", "colors" : ["#6A3D9A", "#CAB2D6", "#FF7F00", "#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-11-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A", "#FFFF99"] },
    { "name" : "rg-colors-paired-11-qualr.css", "colors" : ["#FFFF99", "#6A3D9A", "#CAB2D6", "#FF7F00", "#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-12-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6", "#6A3D9A", "#FFFF99", "#B15928"] },
    { "name" : "rg-colors-paired-12-qualr.css", "colors" : ["#B15928", "#FFFF99", "#6A3D9A", "#CAB2D6", "#FF7F00", "#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-3-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A"] },
    { "name" : "rg-colors-paired-3-qualr.css", "colors" : ["#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-4-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C"] },
    { "name" : "rg-colors-paired-4-qualr.css", "colors" : ["#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-5-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99"] },
    { "name" : "rg-colors-paired-5-qualr.css", "colors" : ["#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-6-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C"] },
    { "name" : "rg-colors-paired-6-qualr.css", "colors" : ["#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-7-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F"] },
    { "name" : "rg-colors-paired-7-qualr.css", "colors" : ["#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-8-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00"] },
    { "name" : "rg-colors-paired-8-qualr.css", "colors" : ["#FF7F00", "#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-paired-9-qual.css", "colors" : ["#A6CEE3", "#1F78B4", "#B2DF8A", "#33A02C", "#FB9A99", "#E31A1C", "#FDBF6F", "#FF7F00", "#CAB2D6"] },
    { "name" : "rg-colors-paired-9-qualr.css", "colors" : ["#CAB2D6", "#FF7F00", "#FDBF6F", "#E31A1C", "#FB9A99", "#33A02C", "#B2DF8A", "#1F78B4", "#A6CEE3"] },
    { "name" : "rg-colors-pastel1-3-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5"] },
    { "name" : "rg-colors-pastel1-3-qualr.css", "colors" : ["#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-4-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4"] },
    { "name" : "rg-colors-pastel1-4-qualr.css", "colors" : ["#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-5-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4", "#FED9A6"] },
    { "name" : "rg-colors-pastel1-5-qualr.css", "colors" : ["#FED9A6", "#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-6-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4", "#FED9A6", "#FFFFCC"] },
    { "name" : "rg-colors-pastel1-6-qualr.css", "colors" : ["#FFFFCC", "#FED9A6", "#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-7-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4", "#FED9A6", "#FFFFCC", "#E5D8BD"] },
    { "name" : "rg-colors-pastel1-7-qualr.css", "colors" : ["#E5D8BD", "#FFFFCC", "#FED9A6", "#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-8-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4", "#FED9A6", "#FFFFCC", "#E5D8BD", "#FDDAEC"] },
    { "name" : "rg-colors-pastel1-8-qualr.css", "colors" : ["#FDDAEC", "#E5D8BD", "#FFFFCC", "#FED9A6", "#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel1-9-qual.css", "colors" : ["#FBB4AE", "#B3CDE3", "#CCEBC5", "#DECBE4", "#FED9A6", "#FFFFCC", "#E5D8BD", "#FDDAEC", "#F2F2F2"] },
    { "name" : "rg-colors-pastel1-9-qualr.css", "colors" : ["#F2F2F2", "#FDDAEC", "#E5D8BD", "#FFFFCC", "#FED9A6", "#DECBE4", "#CCEBC5", "#B3CDE3", "#FBB4AE"] },
    { "name" : "rg-colors-pastel2-3-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8"] },
    { "name" : "rg-colors-pastel2-3-qualr.css", "colors" : ["#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-pastel2-4-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8", "#F4CAE4"] },
    { "name" : "rg-colors-pastel2-4-qualr.css", "colors" : ["#F4CAE4", "#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-pastel2-5-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8", "#F4CAE4", "#E6F5C9"] },
    { "name" : "rg-colors-pastel2-5-qualr.css", "colors" : ["#E6F5C9", "#F4CAE4", "#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-pastel2-6-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8", "#F4CAE4", "#E6F5C9", "#FFF2AE"] },
    { "name" : "rg-colors-pastel2-6-qualr.css", "colors" : ["#FFF2AE", "#E6F5C9", "#F4CAE4", "#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-pastel2-7-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8", "#F4CAE4", "#E6F5C9", "#FFF2AE", "#F1E2CC"] },
    { "name" : "rg-colors-pastel2-7-qualr.css", "colors" : ["#F1E2CC", "#FFF2AE", "#E6F5C9", "#F4CAE4", "#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-pastel2-8-qual.css", "colors" : ["#B3E2CD", "#FDCDAC", "#CBD5E8", "#F4CAE4", "#E6F5C9", "#FFF2AE", "#F1E2CC", "#CCCCCC"] },
    { "name" : "rg-colors-pastel2-8-qualr.css", "colors" : ["#CCCCCC", "#F1E2CC", "#FFF2AE", "#E6F5C9", "#F4CAE4", "#CBD5E8", "#FDCDAC", "#B3E2CD"] },
    { "name" : "rg-colors-piyg-10-div.css", "colors" : ["#8E0152", "#C51B7D", "#DE77AE", "#F1B6DA", "#FDE0EF", "#E6F5D0", "#B8E186", "#7FBC41", "#4D9221", "#276419"] },
    { "name" : "rg-colors-piyg-10-divr.css", "colors" : ["#276419", "#4D9221", "#7FBC41", "#B8E186", "#E6F5D0", "#FDE0EF", "#F1B6DA", "#DE77AE", "#C51B7D", "#8E0152"] },
    { "name" : "rg-colors-piyg-11-div.css", "colors" : ["#8E0152", "#C51B7D", "#DE77AE", "#F1B6DA", "#FDE0EF", "#F7F7F7", "#E6F5D0", "#B8E186", "#7FBC41", "#4D9221", "#276419"] },
    { "name" : "rg-colors-piyg-11-divr.css", "colors" : ["#276419", "#4D9221", "#7FBC41", "#B8E186", "#E6F5D0", "#F7F7F7", "#FDE0EF", "#F1B6DA", "#DE77AE", "#C51B7D", "#8E0152"] },
    { "name" : "rg-colors-piyg-3-div.css", "colors" : ["#E9A3C9", "#F7F7F7", "#A1D76A"] },
    { "name" : "rg-colors-piyg-3-divr.css", "colors" : ["#A1D76A", "#F7F7F7", "#E9A3C9"] },
    { "name" : "rg-colors-piyg-4-div.css", "colors" : ["#D01C8B", "#F1B6DA", "#B8E186", "#4DAC26"] },
    { "name" : "rg-colors-piyg-4-divr.css", "colors" : ["#4DAC26", "#B8E186", "#F1B6DA", "#D01C8B"] },
    { "name" : "rg-colors-piyg-5-div.css", "colors" : ["#D01C8B", "#F1B6DA", "#F7F7F7", "#B8E186", "#4DAC26"] },
    { "name" : "rg-colors-piyg-5-divr.css", "colors" : ["#4DAC26", "#B8E186", "#F7F7F7", "#F1B6DA", "#D01C8B"] },
    { "name" : "rg-colors-piyg-6-div.css", "colors" : ["#C51B7D", "#E9A3C9", "#FDE0EF", "#E6F5D0", "#A1D76A", "#4D9221"] },
    { "name" : "rg-colors-piyg-6-divr.css", "colors" : ["#4D9221", "#A1D76A", "#E6F5D0", "#FDE0EF", "#E9A3C9", "#C51B7D"] },
    { "name" : "rg-colors-piyg-7-div.css", "colors" : ["#C51B7D", "#E9A3C9", "#FDE0EF", "#F7F7F7", "#E6F5D0", "#A1D76A", "#4D9221"] },
    { "name" : "rg-colors-piyg-7-divr.css", "colors" : ["#4D9221", "#A1D76A", "#E6F5D0", "#F7F7F7", "#FDE0EF", "#E9A3C9", "#C51B7D"] },
    { "name" : "rg-colors-piyg-8-div.css", "colors" : ["#C51B7D", "#DE77AE", "#F1B6DA", "#FDE0EF", "#E6F5D0", "#B8E186", "#7FBC41", "#4D9221"] },
    { "name" : "rg-colors-piyg-8-divr.css", "colors" : ["#4D9221", "#7FBC41", "#B8E186", "#E6F5D0", "#FDE0EF", "#F1B6DA", "#DE77AE", "#C51B7D"] },
    { "name" : "rg-colors-piyg-9-div.css", "colors" : ["#C51B7D", "#DE77AE", "#F1B6DA", "#FDE0EF", "#F7F7F7", "#E6F5D0", "#B8E186", "#7FBC41", "#4D9221"] },
    { "name" : "rg-colors-piyg-9-divr.css", "colors" : ["#4D9221", "#7FBC41", "#B8E186", "#E6F5D0", "#F7F7F7", "#FDE0EF", "#F1B6DA", "#DE77AE", "#C51B7D"] },
    { "name" : "rg-colors-prgn-10-div.css", "colors" : ["#40004B", "#762A83", "#9970AB", "#C2A5CF", "#E7D4E8", "#D9F0D3", "#A6DBA0", "#5AAE61", "#1B7837", "#00441B"] },
    { "name" : "rg-colors-prgn-10-divr.css", "colors" : ["#00441B", "#1B7837", "#5AAE61", "#A6DBA0", "#D9F0D3", "#E7D4E8", "#C2A5CF", "#9970AB", "#762A83", "#40004B"] },
    { "name" : "rg-colors-prgn-11-div.css", "colors" : ["#40004B", "#762A83", "#9970AB", "#C2A5CF", "#E7D4E8", "#F7F7F7", "#D9F0D3", "#A6DBA0", "#5AAE61", "#1B7837", "#00441B"] },
    { "name" : "rg-colors-prgn-11-divr.css", "colors" : ["#00441B", "#1B7837", "#5AAE61", "#A6DBA0", "#D9F0D3", "#F7F7F7", "#E7D4E8", "#C2A5CF", "#9970AB", "#762A83", "#40004B"] },
    { "name" : "rg-colors-prgn-3-div.css", "colors" : ["#AF8DC3", "#F7F7F7", "#7FBF7B"] },
    { "name" : "rg-colors-prgn-3-divr.css", "colors" : ["#7FBF7B", "#F7F7F7", "#AF8DC3"] },
    { "name" : "rg-colors-prgn-4-div.css", "colors" : ["#7B3294", "#C2A5CF", "#A6DBA0", "#008837"] },
    { "name" : "rg-colors-prgn-4-divr.css", "colors" : ["#008837", "#A6DBA0", "#C2A5CF", "#7B3294"] },
    { "name" : "rg-colors-prgn-5-div.css", "colors" : ["#7B3294", "#C2A5CF", "#F7F7F7", "#A6DBA0", "#008837"] },
    { "name" : "rg-colors-prgn-5-divr.css", "colors" : ["#008837", "#A6DBA0", "#F7F7F7", "#C2A5CF", "#7B3294"] },
    { "name" : "rg-colors-prgn-6-div.css", "colors" : ["#762A83", "#AF8DC3", "#E7D4E8", "#D9F0D3", "#7FBF7B", "#1B7837"] },
    { "name" : "rg-colors-prgn-6-divr.css", "colors" : ["#1B7837", "#7FBF7B", "#D9F0D3", "#E7D4E8", "#AF8DC3", "#762A83"] },
    { "name" : "rg-colors-prgn-7-div.css", "colors" : ["#762A83", "#AF8DC3", "#E7D4E8", "#F7F7F7", "#D9F0D3", "#7FBF7B", "#1B7837"] },
    { "name" : "rg-colors-prgn-7-divr.css", "colors" : ["#1B7837", "#7FBF7B", "#D9F0D3", "#F7F7F7", "#E7D4E8", "#AF8DC3", "#762A83"] },
    { "name" : "rg-colors-prgn-8-div.css", "colors" : ["#762A83", "#9970AB", "#C2A5CF", "#E7D4E8", "#D9F0D3", "#A6DBA0", "#5AAE61", "#1B7837"] },
    { "name" : "rg-colors-prgn-8-divr.css", "colors" : ["#1B7837", "#5AAE61", "#A6DBA0", "#D9F0D3", "#E7D4E8", "#C2A5CF", "#9970AB", "#762A83"] },
    { "name" : "rg-colors-prgn-9-div.css", "colors" : ["#762A83", "#9970AB", "#C2A5CF", "#E7D4E8", "#F7F7F7", "#D9F0D3", "#A6DBA0", "#5AAE61", "#1B7837"] },
    { "name" : "rg-colors-prgn-9-divr.css", "colors" : ["#1B7837", "#5AAE61", "#A6DBA0", "#D9F0D3", "#F7F7F7", "#E7D4E8", "#C2A5CF", "#9970AB", "#762A83"] },
    { "name" : "rg-colors-pubu-3-seq.css", "colors" : ["#ECE7F2", "#A6BDDB", "#2B8CBE"] },
    { "name" : "rg-colors-pubu-3-seqr.css", "colors" : ["#2B8CBE", "#A6BDDB", "#ECE7F2"] },
    { "name" : "rg-colors-pubu-4-seq.css", "colors" : ["#F1EEF6", "#BDC9E1", "#74A9CF", "#0570B0"] },
    { "name" : "rg-colors-pubu-4-seqr.css", "colors" : ["#0570B0", "#74A9CF", "#BDC9E1", "#F1EEF6"] },
    { "name" : "rg-colors-pubu-5-seq.css", "colors" : ["#F1EEF6", "#BDC9E1", "#74A9CF", "#2B8CBE", "#045A8D"] },
    { "name" : "rg-colors-pubu-5-seqr.css", "colors" : ["#045A8D", "#2B8CBE", "#74A9CF", "#BDC9E1", "#F1EEF6"] },
    { "name" : "rg-colors-pubu-6-seq.css", "colors" : ["#F1EEF6", "#D0D1E6", "#A6BDDB", "#74A9CF", "#2B8CBE", "#045A8D"] },
    { "name" : "rg-colors-pubu-6-seqr.css", "colors" : ["#045A8D", "#2B8CBE", "#74A9CF", "#A6BDDB", "#D0D1E6", "#F1EEF6"] },
    { "name" : "rg-colors-pubu-7-seq.css", "colors" : ["#F1EEF6", "#D0D1E6", "#A6BDDB", "#74A9CF", "#3690C0", "#0570B0", "#034E7B"] },
    { "name" : "rg-colors-pubu-7-seqr.css", "colors" : ["#034E7B", "#0570B0", "#3690C0", "#74A9CF", "#A6BDDB", "#D0D1E6", "#F1EEF6"] },
    { "name" : "rg-colors-pubu-8-seq.css", "colors" : ["#FFF7FB", "#ECE7F2", "#D0D1E6", "#A6BDDB", "#74A9CF", "#3690C0", "#0570B0", "#034E7B"] },
    { "name" : "rg-colors-pubu-8-seqr.css", "colors" : ["#034E7B", "#0570B0", "#3690C0", "#74A9CF", "#A6BDDB", "#D0D1E6", "#ECE7F2", "#FFF7FB"] },
    { "name" : "rg-colors-pubu-9-seq.css", "colors" : ["#FFF7FB", "#ECE7F2", "#D0D1E6", "#A6BDDB", "#74A9CF", "#3690C0", "#0570B0", "#045A8D", "#023858"] },
    { "name" : "rg-colors-pubu-9-seqr.css", "colors" : ["#023858", "#045A8D", "#0570B0", "#3690C0", "#74A9CF", "#A6BDDB", "#D0D1E6", "#ECE7F2", "#FFF7FB"] },
    { "name" : "rg-colors-pubugn-3-seq.css", "colors" : ["#ECE2F0", "#A6BDDB", "#1C9099"] },
    { "name" : "rg-colors-pubugn-3-seqr.css", "colors" : ["#1C9099", "#A6BDDB", "#ECE2F0"] },
    { "name" : "rg-colors-pubugn-4-seq.css", "colors" : ["#F6EFF7", "#BDC9E1", "#67A9CF", "#02818A"] },
    { "name" : "rg-colors-pubugn-4-seqr.css", "colors" : ["#02818A", "#67A9CF", "#BDC9E1", "#F6EFF7"] },
    { "name" : "rg-colors-pubugn-5-seq.css", "colors" : ["#F6EFF7", "#BDC9E1", "#67A9CF", "#1C9099", "#016C59"] },
    { "name" : "rg-colors-pubugn-5-seqr.css", "colors" : ["#016C59", "#1C9099", "#67A9CF", "#BDC9E1", "#F6EFF7"] },
    { "name" : "rg-colors-pubugn-6-seq.css", "colors" : ["#F6EFF7", "#D0D1E6", "#A6BDDB", "#67A9CF", "#1C9099", "#016C59"] },
    { "name" : "rg-colors-pubugn-6-seqr.css", "colors" : ["#016C59", "#1C9099", "#67A9CF", "#A6BDDB", "#D0D1E6", "#F6EFF7"] },
    { "name" : "rg-colors-pubugn-7-seq.css", "colors" : ["#F6EFF7", "#D0D1E6", "#A6BDDB", "#67A9CF", "#3690C0", "#02818A", "#016450"] },
    { "name" : "rg-colors-pubugn-7-seqr.css", "colors" : ["#016450", "#02818A", "#3690C0", "#67A9CF", "#A6BDDB", "#D0D1E6", "#F6EFF7"] },
    { "name" : "rg-colors-pubugn-8-seq.css", "colors" : ["#FFF7FB", "#ECE2F0", "#D0D1E6", "#A6BDDB", "#67A9CF", "#3690C0", "#02818A", "#016450"] },
    { "name" : "rg-colors-pubugn-8-seqr.css", "colors" : ["#016450", "#02818A", "#3690C0", "#67A9CF", "#A6BDDB", "#D0D1E6", "#ECE2F0", "#FFF7FB"] },
    { "name" : "rg-colors-pubugn-9-seq.css", "colors" : ["#FFF7FB", "#ECE2F0", "#D0D1E6", "#A6BDDB", "#67A9CF", "#3690C0", "#02818A", "#016C59", "#014636"] },
    { "name" : "rg-colors-pubugn-9-seqr.css", "colors" : ["#014636", "#016C59", "#02818A", "#3690C0", "#67A9CF", "#A6BDDB", "#D0D1E6", "#ECE2F0", "#FFF7FB"] },
    { "name" : "rg-colors-puor-10-div.css", "colors" : ["#7F3B08", "#B35806", "#E08214", "#FDB863", "#FEE0B6", "#D8DAEB", "#B2ABD2", "#8073AC", "#542788", "#2D004B"] },
    { "name" : "rg-colors-puor-10-divr.css", "colors" : ["#2D004B", "#542788", "#8073AC", "#B2ABD2", "#D8DAEB", "#FEE0B6", "#FDB863", "#E08214", "#B35806", "#7F3B08"] },
    { "name" : "rg-colors-puor-11-div.css", "colors" : ["#7F3B08", "#B35806", "#E08214", "#FDB863", "#FEE0B6", "#F7F7F7", "#D8DAEB", "#B2ABD2", "#8073AC", "#542788", "#2D004B"] },
    { "name" : "rg-colors-puor-11-divr.css", "colors" : ["#2D004B", "#542788", "#8073AC", "#B2ABD2", "#D8DAEB", "#F7F7F7", "#FEE0B6", "#FDB863", "#E08214", "#B35806", "#7F3B08"] },
    { "name" : "rg-colors-puor-3-div.css", "colors" : ["#F1A340", "#F7F7F7", "#998EC3"] },
    { "name" : "rg-colors-puor-3-divr.css", "colors" : ["#998EC3", "#F7F7F7", "#F1A340"] },
    { "name" : "rg-colors-puor-4-div.css", "colors" : ["#E66101", "#FDB863", "#B2ABD2", "#5E3C99"] },
    { "name" : "rg-colors-puor-4-divr.css", "colors" : ["#5E3C99", "#B2ABD2", "#FDB863", "#E66101"] },
    { "name" : "rg-colors-puor-5-div.css", "colors" : ["#E66101", "#FDB863", "#F7F7F7", "#B2ABD2", "#5E3C99"] },
    { "name" : "rg-colors-puor-5-divr.css", "colors" : ["#5E3C99", "#B2ABD2", "#F7F7F7", "#FDB863", "#E66101"] },
    { "name" : "rg-colors-puor-6-div.css", "colors" : ["#B35806", "#F1A340", "#FEE0B6", "#D8DAEB", "#998EC3", "#542788"] },
    { "name" : "rg-colors-puor-6-divr.css", "colors" : ["#542788", "#998EC3", "#D8DAEB", "#FEE0B6", "#F1A340", "#B35806"] },
    { "name" : "rg-colors-puor-7-div.css", "colors" : ["#B35806", "#F1A340", "#FEE0B6", "#F7F7F7", "#D8DAEB", "#998EC3", "#542788"] },
    { "name" : "rg-colors-puor-7-divr.css", "colors" : ["#542788", "#998EC3", "#D8DAEB", "#F7F7F7", "#FEE0B6", "#F1A340", "#B35806"] },
    { "name" : "rg-colors-puor-8-div.css", "colors" : ["#B35806", "#E08214", "#FDB863", "#FEE0B6", "#D8DAEB", "#B2ABD2", "#8073AC", "#542788"] },
    { "name" : "rg-colors-puor-8-divr.css", "colors" : ["#542788", "#8073AC", "#B2ABD2", "#D8DAEB", "#FEE0B6", "#FDB863", "#E08214", "#B35806"] },
    { "name" : "rg-colors-puor-9-div.css", "colors" : ["#B35806", "#E08214", "#FDB863", "#FEE0B6", "#F7F7F7", "#D8DAEB", "#B2ABD2", "#8073AC", "#542788"] },
    { "name" : "rg-colors-puor-9-divr.css", "colors" : ["#542788", "#8073AC", "#B2ABD2", "#D8DAEB", "#F7F7F7", "#FEE0B6", "#FDB863", "#E08214", "#B35806"] },
    { "name" : "rg-colors-purd-3-seq.css", "colors" : ["#E7E1EF", "#C994C7", "#DD1C77"] },
    { "name" : "rg-colors-purd-3-seqr.css", "colors" : ["#DD1C77", "#C994C7", "#E7E1EF"] },
    { "name" : "rg-colors-purd-4-seq.css", "colors" : ["#F1EEF6", "#D7B5D8", "#DF65B0", "#CE1256"] },
    { "name" : "rg-colors-purd-4-seqr.css", "colors" : ["#CE1256", "#DF65B0", "#D7B5D8", "#F1EEF6"] },
    { "name" : "rg-colors-purd-5-seq.css", "colors" : ["#F1EEF6", "#D7B5D8", "#DF65B0", "#DD1C77", "#980043"] },
    { "name" : "rg-colors-purd-5-seqr.css", "colors" : ["#980043", "#DD1C77", "#DF65B0", "#D7B5D8", "#F1EEF6"] },
    { "name" : "rg-colors-purd-6-seq.css", "colors" : ["#F1EEF6", "#D4B9DA", "#C994C7", "#DF65B0", "#DD1C77", "#980043"] },
    { "name" : "rg-colors-purd-6-seqr.css", "colors" : ["#980043", "#DD1C77", "#DF65B0", "#C994C7", "#D4B9DA", "#F1EEF6"] },
    { "name" : "rg-colors-purd-7-seq.css", "colors" : ["#F1EEF6", "#D4B9DA", "#C994C7", "#DF65B0", "#E7298A", "#CE1256", "#91003F"] },
    { "name" : "rg-colors-purd-7-seqr.css", "colors" : ["#91003F", "#CE1256", "#E7298A", "#DF65B0", "#C994C7", "#D4B9DA", "#F1EEF6"] },
    { "name" : "rg-colors-purd-8-seq.css", "colors" : ["#F7F4F9", "#E7E1EF", "#D4B9DA", "#C994C7", "#DF65B0", "#E7298A", "#CE1256", "#91003F"] },
    { "name" : "rg-colors-purd-8-seqr.css", "colors" : ["#91003F", "#CE1256", "#E7298A", "#DF65B0", "#C994C7", "#D4B9DA", "#E7E1EF", "#F7F4F9"] },
    { "name" : "rg-colors-purd-9-seq.css", "colors" : ["#F7F4F9", "#E7E1EF", "#D4B9DA", "#C994C7", "#DF65B0", "#E7298A", "#CE1256", "#980043", "#67001F"] },
    { "name" : "rg-colors-purd-9-seqr.css", "colors" : ["#67001F", "#980043", "#CE1256", "#E7298A", "#DF65B0", "#C994C7", "#D4B9DA", "#E7E1EF", "#F7F4F9"] },
    { "name" : "rg-colors-purples-3-seq.css", "colors" : ["#EFEDF5", "#BCBDDC", "#756BB1"] },
    { "name" : "rg-colors-purples-3-seqr.css", "colors" : ["#756BB1", "#BCBDDC", "#EFEDF5"] },
    { "name" : "rg-colors-purples-4-seq.css", "colors" : ["#F2F0F7", "#CBC9E2", "#9E9AC8", "#6A51A3"] },
    { "name" : "rg-colors-purples-4-seqr.css", "colors" : ["#6A51A3", "#9E9AC8", "#CBC9E2", "#F2F0F7"] },
    { "name" : "rg-colors-purples-5-seq.css", "colors" : ["#F2F0F7", "#CBC9E2", "#9E9AC8", "#756BB1", "#54278F"] },
    { "name" : "rg-colors-purples-5-seqr.css", "colors" : ["#54278F", "#756BB1", "#9E9AC8", "#CBC9E2", "#F2F0F7"] },
    { "name" : "rg-colors-purples-6-seq.css", "colors" : ["#F2F0F7", "#DADAEB", "#BCBDDC", "#9E9AC8", "#756BB1", "#54278F"] },
    { "name" : "rg-colors-purples-6-seqr.css", "colors" : ["#54278F", "#756BB1", "#9E9AC8", "#BCBDDC", "#DADAEB", "#F2F0F7"] },
    { "name" : "rg-colors-purples-7-seq.css", "colors" : ["#F2F0F7", "#DADAEB", "#BCBDDC", "#9E9AC8", "#807DBA", "#6A51A3", "#4A1486"] },
    { "name" : "rg-colors-purples-7-seqr.css", "colors" : ["#4A1486", "#6A51A3", "#807DBA", "#9E9AC8", "#BCBDDC", "#DADAEB", "#F2F0F7"] },
    { "name" : "rg-colors-purples-8-seq.css", "colors" : ["#FCFBFD", "#EFEDF5", "#DADAEB", "#BCBDDC", "#9E9AC8", "#807DBA", "#6A51A3", "#4A1486"] },
    { "name" : "rg-colors-purples-8-seqr.css", "colors" : ["#4A1486", "#6A51A3", "#807DBA", "#9E9AC8", "#BCBDDC", "#DADAEB", "#EFEDF5", "#FCFBFD"] },
    { "name" : "rg-colors-purples-9-seq.css", "colors" : ["#FCFBFD", "#EFEDF5", "#DADAEB", "#BCBDDC", "#9E9AC8", "#807DBA", "#6A51A3", "#54278F", "#3F007D"] },
    { "name" : "rg-colors-purples-9-seqr.css", "colors" : ["#3F007D", "#54278F", "#6A51A3", "#807DBA", "#9E9AC8", "#BCBDDC", "#DADAEB", "#EFEDF5", "#FCFBFD"] },
    { "name" : "rg-colors-rdbu-10-div.css", "colors" : ["#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"] },
    { "name" : "rg-colors-rdbu-10-divr.css", "colors" : ["#053061", "#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B", "#67001F"] },
    { "name" : "rg-colors-rdbu-11-div.css", "colors" : ["#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#F7F7F7", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC", "#053061"] },
    { "name" : "rg-colors-rdbu-11-divr.css", "colors" : ["#053061", "#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", "#F7F7F7", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B", "#67001F"] },
    { "name" : "rg-colors-rdbu-3-div.css", "colors" : ["#EF8A62", "#F7F7F7", "#67A9CF"] },
    { "name" : "rg-colors-rdbu-3-divr.css", "colors" : ["#67A9CF", "#F7F7F7", "#EF8A62"] },
    { "name" : "rg-colors-rdbu-4-div.css", "colors" : ["#CA0020", "#F4A582", "#92C5DE", "#0571B0"] },
    { "name" : "rg-colors-rdbu-4-divr.css", "colors" : ["#0571B0", "#92C5DE", "#F4A582", "#CA0020"] },
    { "name" : "rg-colors-rdbu-5-div.css", "colors" : ["#CA0020", "#F4A582", "#F7F7F7", "#92C5DE", "#0571B0"] },
    { "name" : "rg-colors-rdbu-5-divr.css", "colors" : ["#0571B0", "#92C5DE", "#F7F7F7", "#F4A582", "#CA0020"] },
    { "name" : "rg-colors-rdbu-6-div.css", "colors" : ["#B2182B", "#EF8A62", "#FDDBC7", "#D1E5F0", "#67A9CF", "#2166AC"] },
    { "name" : "rg-colors-rdbu-6-divr.css", "colors" : ["#2166AC", "#67A9CF", "#D1E5F0", "#FDDBC7", "#EF8A62", "#B2182B"] },
    { "name" : "rg-colors-rdbu-7-div.css", "colors" : ["#B2182B", "#EF8A62", "#FDDBC7", "#F7F7F7", "#D1E5F0", "#67A9CF", "#2166AC"] },
    { "name" : "rg-colors-rdbu-7-divr.css", "colors" : ["#2166AC", "#67A9CF", "#D1E5F0", "#F7F7F7", "#FDDBC7", "#EF8A62", "#B2182B"] },
    { "name" : "rg-colors-rdbu-8-div.css", "colors" : ["#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC"] },
    { "name" : "rg-colors-rdbu-8-divr.css", "colors" : ["#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B"] },
    { "name" : "rg-colors-rdbu-9-div.css", "colors" : ["#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#F7F7F7", "#D1E5F0", "#92C5DE", "#4393C3", "#2166AC"] },
    { "name" : "rg-colors-rdbu-9-divr.css", "colors" : ["#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", "#F7F7F7", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B"] },
    { "name" : "rg-colors-rdgy-10-div.css", "colors" : ["#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#E0E0E0", "#BABABA", "#878787", "#4D4D4D", "#1A1A1A"] },
    { "name" : "rg-colors-rdgy-10-divr.css", "colors" : ["#1A1A1A", "#4D4D4D", "#878787", "#BABABA", "#E0E0E0", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B", "#67001F"] },
    { "name" : "rg-colors-rdgy-11-div.css", "colors" : ["#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#FFFFFF", "#E0E0E0", "#BABABA", "#878787", "#4D4D4D", "#1A1A1A"] },
    { "name" : "rg-colors-rdgy-11-divr.css", "colors" : ["#1A1A1A", "#4D4D4D", "#878787", "#BABABA", "#E0E0E0", "#FFFFFF", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B", "#67001F"] },
    { "name" : "rg-colors-rdgy-3-div.css", "colors" : ["#EF8A62", "#FFFFFF", "#999999"] },
    { "name" : "rg-colors-rdgy-3-divr.css", "colors" : ["#999999", "#FFFFFF", "#EF8A62"] },
    { "name" : "rg-colors-rdgy-4-div.css", "colors" : ["#CA0020", "#F4A582", "#BABABA", "#404040"] },
    { "name" : "rg-colors-rdgy-4-divr.css", "colors" : ["#404040", "#BABABA", "#F4A582", "#CA0020"] },
    { "name" : "rg-colors-rdgy-5-div.css", "colors" : ["#CA0020", "#F4A582", "#FFFFFF", "#BABABA", "#404040"] },
    { "name" : "rg-colors-rdgy-5-divr.css", "colors" : ["#404040", "#BABABA", "#FFFFFF", "#F4A582", "#CA0020"] },
    { "name" : "rg-colors-rdgy-6-div.css", "colors" : ["#B2182B", "#EF8A62", "#FDDBC7", "#E0E0E0", "#999999", "#4D4D4D"] },
    { "name" : "rg-colors-rdgy-6-divr.css", "colors" : ["#4D4D4D", "#999999", "#E0E0E0", "#FDDBC7", "#EF8A62", "#B2182B"] },
    { "name" : "rg-colors-rdgy-7-div.css", "colors" : ["#B2182B", "#EF8A62", "#FDDBC7", "#FFFFFF", "#E0E0E0", "#999999", "#4D4D4D"] },
    { "name" : "rg-colors-rdgy-7-divr.css", "colors" : ["#4D4D4D", "#999999", "#E0E0E0", "#FFFFFF", "#FDDBC7", "#EF8A62", "#B2182B"] },
    { "name" : "rg-colors-rdgy-8-div.css", "colors" : ["#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#E0E0E0", "#BABABA", "#878787", "#4D4D4D"] },
    { "name" : "rg-colors-rdgy-8-divr.css", "colors" : ["#4D4D4D", "#878787", "#BABABA", "#E0E0E0", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B"] },
    { "name" : "rg-colors-rdgy-9-div.css", "colors" : ["#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#FFFFFF", "#E0E0E0", "#BABABA", "#878787", "#4D4D4D"] },
    { "name" : "rg-colors-rdgy-9-divr.css", "colors" : ["#4D4D4D", "#878787", "#BABABA", "#E0E0E0", "#FFFFFF", "#FDDBC7", "#F4A582", "#D6604D", "#B2182B"] },
    { "name" : "rg-colors-rdpu-3-seq.css", "colors" : ["#FDE0DD", "#FA9FB5", "#C51B8A"] },
    { "name" : "rg-colors-rdpu-3-seqr.css", "colors" : ["#C51B8A", "#FA9FB5", "#FDE0DD"] },
    { "name" : "rg-colors-rdpu-4-seq.css", "colors" : ["#FEEBE2", "#FBB4B9", "#F768A1", "#AE017E"] },
    { "name" : "rg-colors-rdpu-4-seqr.css", "colors" : ["#AE017E", "#F768A1", "#FBB4B9", "#FEEBE2"] },
    { "name" : "rg-colors-rdpu-5-seq.css", "colors" : ["#FEEBE2", "#FBB4B9", "#F768A1", "#C51B8A", "#7A0177"] },
    { "name" : "rg-colors-rdpu-5-seqr.css", "colors" : ["#7A0177", "#C51B8A", "#F768A1", "#FBB4B9", "#FEEBE2"] },
    { "name" : "rg-colors-rdpu-6-seq.css", "colors" : ["#FEEBE2", "#FCC5C0", "#FA9FB5", "#F768A1", "#C51B8A", "#7A0177"] },
    { "name" : "rg-colors-rdpu-6-seqr.css", "colors" : ["#7A0177", "#C51B8A", "#F768A1", "#FA9FB5", "#FCC5C0", "#FEEBE2"] },
    { "name" : "rg-colors-rdpu-7-seq.css", "colors" : ["#FEEBE2", "#FCC5C0", "#FA9FB5", "#F768A1", "#DD3497", "#AE017E", "#7A0177"] },
    { "name" : "rg-colors-rdpu-7-seqr.css", "colors" : ["#7A0177", "#AE017E", "#DD3497", "#F768A1", "#FA9FB5", "#FCC5C0", "#FEEBE2"] },
    { "name" : "rg-colors-rdpu-8-seq.css", "colors" : ["#FFF7F3", "#FDE0DD", "#FCC5C0", "#FA9FB5", "#F768A1", "#DD3497", "#AE017E", "#7A0177"] },
    { "name" : "rg-colors-rdpu-8-seqr.css", "colors" : ["#7A0177", "#AE017E", "#DD3497", "#F768A1", "#FA9FB5", "#FCC5C0", "#FDE0DD", "#FFF7F3"] },
    { "name" : "rg-colors-rdpu-9-seq.css", "colors" : ["#FFF7F3", "#FDE0DD", "#FCC5C0", "#FA9FB5", "#F768A1", "#DD3497", "#AE017E", "#7A0177", "#49006A"] },
    { "name" : "rg-colors-rdpu-9-seqr.css", "colors" : ["#49006A", "#7A0177", "#AE017E", "#DD3497", "#F768A1", "#FA9FB5", "#FCC5C0", "#FDE0DD", "#FFF7F3"] },
    { "name" : "rg-colors-rdylbu-10-div.css", "colors" : ["#A50026", "#D73027", "#F46D43", "#FDAE61", "#FEE090", "#E0F3F8", "#ABD9E9", "#74ADD1", "#4575B4", "#313695"] },
    { "name" : "rg-colors-rdylbu-10-divr.css", "colors" : ["#313695", "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FEE090", "#FDAE61", "#F46D43", "#D73027", "#A50026"] },
    { "name" : "rg-colors-rdylbu-11-div.css", "colors" : ["#A50026", "#D73027", "#F46D43", "#FDAE61", "#FEE090", "#FFFFBF", "#E0F3F8", "#ABD9E9", "#74ADD1", "#4575B4", "#313695"] },
    { "name" : "rg-colors-rdylbu-11-divr.css", "colors" : ["#313695", "#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FFFFBF", "#FEE090", "#FDAE61", "#F46D43", "#D73027", "#A50026"] },
    { "name" : "rg-colors-rdylbu-3-div.css", "colors" : ["#FC8D59", "#FFFFBF", "#91BFDB"] },
    { "name" : "rg-colors-rdylbu-3-divr.css", "colors" : ["#91BFDB", "#FFFFBF", "#FC8D59"] },
    { "name" : "rg-colors-rdylbu-4-div.css", "colors" : ["#D7191C", "#FDAE61", "#ABD9E9", "#2C7BB6"] },
    { "name" : "rg-colors-rdylbu-4-divr.css", "colors" : ["#2C7BB6", "#ABD9E9", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-rdylbu-5-div.css", "colors" : ["#D7191C", "#FDAE61", "#FFFFBF", "#ABD9E9", "#2C7BB6"] },
    { "name" : "rg-colors-rdylbu-5-divr.css", "colors" : ["#2C7BB6", "#ABD9E9", "#FFFFBF", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-rdylbu-6-div.css", "colors" : ["#D73027", "#FC8D59", "#FEE090", "#E0F3F8", "#91BFDB", "#4575B4"] },
    { "name" : "rg-colors-rdylbu-6-divr.css", "colors" : ["#4575B4", "#91BFDB", "#E0F3F8", "#FEE090", "#FC8D59", "#D73027"] },
    { "name" : "rg-colors-rdylbu-7-div.css", "colors" : ["#D73027", "#FC8D59", "#FEE090", "#FFFFBF", "#E0F3F8", "#91BFDB", "#4575B4"] },
    { "name" : "rg-colors-rdylbu-7-divr.css", "colors" : ["#4575B4", "#91BFDB", "#E0F3F8", "#FFFFBF", "#FEE090", "#FC8D59", "#D73027"] },
    { "name" : "rg-colors-rdylbu-8-div.css", "colors" : ["#D73027", "#F46D43", "#FDAE61", "#FEE090", "#E0F3F8", "#ABD9E9", "#74ADD1", "#4575B4"] },
    { "name" : "rg-colors-rdylbu-8-divr.css", "colors" : ["#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FEE090", "#FDAE61", "#F46D43", "#D73027"] },
    { "name" : "rg-colors-rdylbu-9-div.css", "colors" : ["#D73027", "#F46D43", "#FDAE61", "#FEE090", "#FFFFBF", "#E0F3F8", "#ABD9E9", "#74ADD1", "#4575B4"] },
    { "name" : "rg-colors-rdylbu-9-divr.css", "colors" : ["#4575B4", "#74ADD1", "#ABD9E9", "#E0F3F8", "#FFFFBF", "#FEE090", "#FDAE61", "#F46D43", "#D73027"] },
    { "name" : "rg-colors-rdylgn-10-div.css", "colors" : ["#A50026", "#D73027", "#F46D43", "#FDAE61", "#FEE08B", "#D9EF8B", "#A6D96A", "#66BD63", "#1A9850", "#006837"] },
    { "name" : "rg-colors-rdylgn-10-divr.css", "colors" : ["#006837", "#1A9850", "#66BD63", "#A6D96A", "#D9EF8B", "#FEE08B", "#FDAE61", "#F46D43", "#D73027", "#A50026"] },
    { "name" : "rg-colors-rdylgn-11-div.css", "colors" : ["#A50026", "#D73027", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#D9EF8B", "#A6D96A", "#66BD63", "#1A9850", "#006837"] },
    { "name" : "rg-colors-rdylgn-11-divr.css", "colors" : ["#006837", "#1A9850", "#66BD63", "#A6D96A", "#D9EF8B", "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D73027", "#A50026"] },
    { "name" : "rg-colors-rdylgn-3-div.css", "colors" : ["#FC8D59", "#FFFFBF", "#91CF60"] },
    { "name" : "rg-colors-rdylgn-3-divr.css", "colors" : ["#91CF60", "#FFFFBF", "#FC8D59"] },
    { "name" : "rg-colors-rdylgn-4-div.css", "colors" : ["#D7191C", "#FDAE61", "#A6D96A", "#1A9641"] },
    { "name" : "rg-colors-rdylgn-4-divr.css", "colors" : ["#1A9641", "#A6D96A", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-rdylgn-5-div.css", "colors" : ["#D7191C", "#FDAE61", "#FFFFBF", "#A6D96A", "#1A9641"] },
    { "name" : "rg-colors-rdylgn-5-divr.css", "colors" : ["#1A9641", "#A6D96A", "#FFFFBF", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-rdylgn-6-div.css", "colors" : ["#D73027", "#FC8D59", "#FEE08B", "#D9EF8B", "#91CF60", "#1A9850"] },
    { "name" : "rg-colors-rdylgn-6-divr.css", "colors" : ["#1A9850", "#91CF60", "#D9EF8B", "#FEE08B", "#FC8D59", "#D73027"] },
    { "name" : "rg-colors-rdylgn-7-div.css", "colors" : ["#D73027", "#FC8D59", "#FEE08B", "#FFFFBF", "#D9EF8B", "#91CF60", "#1A9850"] },
    { "name" : "rg-colors-rdylgn-7-divr.css", "colors" : ["#1A9850", "#91CF60", "#D9EF8B", "#FFFFBF", "#FEE08B", "#FC8D59", "#D73027"] },
    { "name" : "rg-colors-rdylgn-8-div.css", "colors" : ["#D73027", "#F46D43", "#FDAE61", "#FEE08B", "#D9EF8B", "#A6D96A", "#66BD63", "#1A9850"] },
    { "name" : "rg-colors-rdylgn-8-divr.css", "colors" : ["#1A9850", "#66BD63", "#A6D96A", "#D9EF8B", "#FEE08B", "#FDAE61", "#F46D43", "#D73027"] },
    { "name" : "rg-colors-rdylgn-9-div.css", "colors" : ["#D73027", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#D9EF8B", "#A6D96A", "#66BD63", "#1A9850"] },
    { "name" : "rg-colors-rdylgn-9-divr.css", "colors" : ["#1A9850", "#66BD63", "#A6D96A", "#D9EF8B", "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D73027"] },
    { "name" : "rg-colors-reds-3-seq.css", "colors" : ["#FEE0D2", "#FC9272", "#DE2D26"] },
    { "name" : "rg-colors-reds-3-seqr.css", "colors" : ["#DE2D26", "#FC9272", "#FEE0D2"] },
    { "name" : "rg-colors-reds-4-seq.css", "colors" : ["#FEE5D9", "#FCAE91", "#FB6A4A", "#CB181D"] },
    { "name" : "rg-colors-reds-4-seqr.css", "colors" : ["#CB181D", "#FB6A4A", "#FCAE91", "#FEE5D9"] },
    { "name" : "rg-colors-reds-5-seq.css", "colors" : ["#FEE5D9", "#FCAE91", "#FB6A4A", "#DE2D26", "#A50F15"] },
    { "name" : "rg-colors-reds-5-seqr.css", "colors" : ["#A50F15", "#DE2D26", "#FB6A4A", "#FCAE91", "#FEE5D9"] },
    { "name" : "rg-colors-reds-6-seq.css", "colors" : ["#FEE5D9", "#FCBBA1", "#FC9272", "#FB6A4A", "#DE2D26", "#A50F15"] },
    { "name" : "rg-colors-reds-6-seqr.css", "colors" : ["#A50F15", "#DE2D26", "#FB6A4A", "#FC9272", "#FCBBA1", "#FEE5D9"] },
    { "name" : "rg-colors-reds-7-seq.css", "colors" : ["#FEE5D9", "#FCBBA1", "#FC9272", "#FB6A4A", "#EF3B2C", "#CB181D", "#99000D"] },
    { "name" : "rg-colors-reds-7-seqr.css", "colors" : ["#99000D", "#CB181D", "#EF3B2C", "#FB6A4A", "#FC9272", "#FCBBA1", "#FEE5D9"] },
    { "name" : "rg-colors-reds-8-seq.css", "colors" : ["#FFF5F0", "#FEE0D2", "#FCBBA1", "#FC9272", "#FB6A4A", "#EF3B2C", "#CB181D", "#99000D"] },
    { "name" : "rg-colors-reds-8-seqr.css", "colors" : ["#99000D", "#CB181D", "#EF3B2C", "#FB6A4A", "#FC9272", "#FCBBA1", "#FEE0D2", "#FFF5F0"] },
    { "name" : "rg-colors-reds-9-seq.css", "colors" : ["#FFF5F0", "#FEE0D2", "#FCBBA1", "#FC9272", "#FB6A4A", "#EF3B2C", "#CB181D", "#A50F15", "#67000D"] },
    { "name" : "rg-colors-reds-9-seqr.css", "colors" : ["#67000D", "#A50F15", "#CB181D", "#EF3B2C", "#FB6A4A", "#FC9272", "#FCBBA1", "#FEE0D2", "#FFF5F0"] },
    { "name" : "rg-colors-set1-3-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A"] },
    { "name" : "rg-colors-set1-3-qualr.css", "colors" : ["#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-4-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3"] },
    { "name" : "rg-colors-set1-4-qualr.css", "colors" : ["#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-5-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00"] },
    { "name" : "rg-colors-set1-5-qualr.css", "colors" : ["#FF7F00", "#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-6-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33"] },
    { "name" : "rg-colors-set1-6-qualr.css", "colors" : ["#FFFF33", "#FF7F00", "#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-7-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628"] },
    { "name" : "rg-colors-set1-7-qualr.css", "colors" : ["#A65628", "#FFFF33", "#FF7F00", "#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-8-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF"] },
    { "name" : "rg-colors-set1-8-qualr.css", "colors" : ["#F781BF", "#A65628", "#FFFF33", "#FF7F00", "#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set1-9-qual.css", "colors" : ["#E41A1C", "#377EB8", "#4DAF4A", "#984EA3", "#FF7F00", "#FFFF33", "#A65628", "#F781BF", "#999999"] },
    { "name" : "rg-colors-set1-9-qualr.css", "colors" : ["#999999", "#F781BF", "#A65628", "#FFFF33", "#FF7F00", "#984EA3", "#4DAF4A", "#377EB8", "#E41A1C"] },
    { "name" : "rg-colors-set2-3-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB"] },
    { "name" : "rg-colors-set2-3-qualr.css", "colors" : ["#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set2-4-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3"] },
    { "name" : "rg-colors-set2-4-qualr.css", "colors" : ["#E78AC3", "#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set2-5-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854"] },
    { "name" : "rg-colors-set2-5-qualr.css", "colors" : ["#A6D854", "#E78AC3", "#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set2-6-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F"] },
    { "name" : "rg-colors-set2-6-qualr.css", "colors" : ["#FFD92F", "#A6D854", "#E78AC3", "#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set2-7-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F", "#E5C494"] },
    { "name" : "rg-colors-set2-7-qualr.css", "colors" : ["#E5C494", "#FFD92F", "#A6D854", "#E78AC3", "#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set2-8-qual.css", "colors" : ["#66C2A5", "#FC8D62", "#8DA0CB", "#E78AC3", "#A6D854", "#FFD92F", "#E5C494", "#B3B3B3"] },
    { "name" : "rg-colors-set2-8-qualr.css", "colors" : ["#B3B3B3", "#E5C494", "#FFD92F", "#A6D854", "#E78AC3", "#8DA0CB", "#FC8D62", "#66C2A5"] },
    { "name" : "rg-colors-set3-10-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD"] },
    { "name" : "rg-colors-set3-10-qualr.css", "colors" : ["#BC80BD", "#D9D9D9", "#FCCDE5", "#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-11-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5"] },
    { "name" : "rg-colors-set3-11-qualr.css", "colors" : ["#CCEBC5", "#BC80BD", "#D9D9D9", "#FCCDE5", "#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-12-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9", "#BC80BD", "#CCEBC5", "#FFED6F"] },
    { "name" : "rg-colors-set3-12-qualr.css", "colors" : ["#FFED6F", "#CCEBC5", "#BC80BD", "#D9D9D9", "#FCCDE5", "#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-3-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA"] },
    { "name" : "rg-colors-set3-3-qualr.css", "colors" : ["#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-4-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072"] },
    { "name" : "rg-colors-set3-4-qualr.css", "colors" : ["#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-5-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3"] },
    { "name" : "rg-colors-set3-5-qualr.css", "colors" : ["#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-6-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462"] },
    { "name" : "rg-colors-set3-6-qualr.css", "colors" : ["#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-7-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69"] },
    { "name" : "rg-colors-set3-7-qualr.css", "colors" : ["#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-8-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5"] },
    { "name" : "rg-colors-set3-8-qualr.css", "colors" : ["#FCCDE5", "#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-set3-9-qual.css", "colors" : ["#8DD3C7", "#FFFFB3", "#BEBADA", "#FB8072", "#80B1D3", "#FDB462", "#B3DE69", "#FCCDE5", "#D9D9D9"] },
    { "name" : "rg-colors-set3-9-qualr.css", "colors" : ["#D9D9D9", "#FCCDE5", "#B3DE69", "#FDB462", "#80B1D3", "#FB8072", "#BEBADA", "#FFFFB3", "#8DD3C7"] },
    { "name" : "rg-colors-spectral-10-div.css", "colors" : ["#9E0142", "#D53E4F", "#F46D43", "#FDAE61", "#FEE08B", "#E6F598", "#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"] },
    { "name" : "rg-colors-spectral-10-divr.css", "colors" : ["#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"] },
    { "name" : "rg-colors-spectral-11-div.css", "colors" : ["#9E0142", "#D53E4F", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#E6F598", "#ABDDA4", "#66C2A5", "#3288BD", "#5E4FA2"] },
    { "name" : "rg-colors-spectral-11-divr.css", "colors" : ["#5E4FA2", "#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F", "#9E0142"] },
    { "name" : "rg-colors-spectral-3-div.css", "colors" : ["#FC8D59", "#FFFFBF", "#99D594"] },
    { "name" : "rg-colors-spectral-3-divr.css", "colors" : ["#99D594", "#FFFFBF", "#FC8D59"] },
    { "name" : "rg-colors-spectral-4-div.css", "colors" : ["#D7191C", "#FDAE61", "#ABDDA4", "#2B83BA"] },
    { "name" : "rg-colors-spectral-4-divr.css", "colors" : ["#2B83BA", "#ABDDA4", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-spectral-5-div.css", "colors" : ["#D7191C", "#FDAE61", "#FFFFBF", "#ABDDA4", "#2B83BA"] },
    { "name" : "rg-colors-spectral-5-divr.css", "colors" : ["#2B83BA", "#ABDDA4", "#FFFFBF", "#FDAE61", "#D7191C"] },
    { "name" : "rg-colors-spectral-6-div.css", "colors" : ["#D53E4F", "#FC8D59", "#FEE08B", "#E6F598", "#99D594", "#3288BD"] },
    { "name" : "rg-colors-spectral-6-divr.css", "colors" : ["#3288BD", "#99D594", "#E6F598", "#FEE08B", "#FC8D59", "#D53E4F"] },
    { "name" : "rg-colors-spectral-7-div.css", "colors" : ["#D53E4F", "#FC8D59", "#FEE08B", "#FFFFBF", "#E6F598", "#99D594", "#3288BD"] },
    { "name" : "rg-colors-spectral-7-divr.css", "colors" : ["#3288BD", "#99D594", "#E6F598", "#FFFFBF", "#FEE08B", "#FC8D59", "#D53E4F"] },
    { "name" : "rg-colors-spectral-8-div.css", "colors" : ["#D53E4F", "#F46D43", "#FDAE61", "#FEE08B", "#E6F598", "#ABDDA4", "#66C2A5", "#3288BD"] },
    { "name" : "rg-colors-spectral-8-divr.css", "colors" : ["#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F"] },
    { "name" : "rg-colors-spectral-9-div.css", "colors" : ["#D53E4F", "#F46D43", "#FDAE61", "#FEE08B", "#FFFFBF", "#E6F598", "#ABDDA4", "#66C2A5", "#3288BD"] },
    { "name" : "rg-colors-spectral-9-divr.css", "colors" : ["#3288BD", "#66C2A5", "#ABDDA4", "#E6F598", "#FFFFBF", "#FEE08B", "#FDAE61", "#F46D43", "#D53E4F"] },
    { "name" : "rg-colors-ylgn-3-seq.css", "colors" : ["#F7FCB9", "#ADDD8E", "#31A354"] },
    { "name" : "rg-colors-ylgn-3-seqr.css", "colors" : ["#31A354", "#ADDD8E", "#F7FCB9"] },
    { "name" : "rg-colors-ylgn-4-seq.css", "colors" : ["#FFFFCC", "#C2E699", "#78C679", "#238443"] },
    { "name" : "rg-colors-ylgn-4-seqr.css", "colors" : ["#238443", "#78C679", "#C2E699", "#FFFFCC"] },
    { "name" : "rg-colors-ylgn-5-seq.css", "colors" : ["#FFFFCC", "#C2E699", "#78C679", "#31A354", "#006837"] },
    { "name" : "rg-colors-ylgn-5-seqr.css", "colors" : ["#006837", "#31A354", "#78C679", "#C2E699", "#FFFFCC"] },
    { "name" : "rg-colors-ylgn-6-seq.css", "colors" : ["#FFFFCC", "#D9F0A3", "#ADDD8E", "#78C679", "#31A354", "#006837"] },
    { "name" : "rg-colors-ylgn-6-seqr.css", "colors" : ["#006837", "#31A354", "#78C679", "#ADDD8E", "#D9F0A3", "#FFFFCC"] },
    { "name" : "rg-colors-ylgn-7-seq.css", "colors" : ["#FFFFCC", "#D9F0A3", "#ADDD8E", "#78C679", "#41AB5D", "#238443", "#005A32"] },
    { "name" : "rg-colors-ylgn-7-seqr.css", "colors" : ["#005A32", "#238443", "#41AB5D", "#78C679", "#ADDD8E", "#D9F0A3", "#FFFFCC"] },
    { "name" : "rg-colors-ylgn-8-seq.css", "colors" : ["#FFFFE5", "#F7FCB9", "#D9F0A3", "#ADDD8E", "#78C679", "#41AB5D", "#238443", "#005A32"] },
    { "name" : "rg-colors-ylgn-8-seqr.css", "colors" : ["#005A32", "#238443", "#41AB5D", "#78C679", "#ADDD8E", "#D9F0A3", "#F7FCB9", "#FFFFE5"] },
    { "name" : "rg-colors-ylgn-9-seq.css", "colors" : ["#FFFFE5", "#F7FCB9", "#D9F0A3", "#ADDD8E", "#78C679", "#41AB5D", "#238443", "#006837", "#004529"] },
    { "name" : "rg-colors-ylgn-9-seqr.css", "colors" : ["#004529", "#006837", "#238443", "#41AB5D", "#78C679", "#ADDD8E", "#D9F0A3", "#F7FCB9", "#FFFFE5"] },
    { "name" : "rg-colors-ylgnbu-3-seq.css", "colors" : ["#EDF8B1", "#7FCDBB", "#2C7FB8"] },
    { "name" : "rg-colors-ylgnbu-3-seqr.css", "colors" : ["#2C7FB8", "#7FCDBB", "#EDF8B1"] },
    { "name" : "rg-colors-ylgnbu-4-seq.css", "colors" : ["#FFFFCC", "#A1DAB4", "#41B6C4", "#225EA8"] },
    { "name" : "rg-colors-ylgnbu-4-seqr.css", "colors" : ["#225EA8", "#41B6C4", "#A1DAB4", "#FFFFCC"] },
    { "name" : "rg-colors-ylgnbu-5-seq.css", "colors" : ["#FFFFCC", "#A1DAB4", "#41B6C4", "#2C7FB8", "#253494"] },
    { "name" : "rg-colors-ylgnbu-5-seqr.css", "colors" : ["#253494", "#2C7FB8", "#41B6C4", "#A1DAB4", "#FFFFCC"] },
    { "name" : "rg-colors-ylgnbu-6-seq.css", "colors" : ["#FFFFCC", "#C7E9B4", "#7FCDBB", "#41B6C4", "#2C7FB8", "#253494"] },
    { "name" : "rg-colors-ylgnbu-6-seqr.css", "colors" : ["#253494", "#2C7FB8", "#41B6C4", "#7FCDBB", "#C7E9B4", "#FFFFCC"] },
    { "name" : "rg-colors-ylgnbu-7-seq.css", "colors" : ["#FFFFCC", "#C7E9B4", "#7FCDBB", "#41B6C4", "#1D91C0", "#225EA8", "#0C2C84"] },
    { "name" : "rg-colors-ylgnbu-7-seqr.css", "colors" : ["#0C2C84", "#225EA8", "#1D91C0", "#41B6C4", "#7FCDBB", "#C7E9B4", "#FFFFCC"] },
    { "name" : "rg-colors-ylgnbu-8-seq.css", "colors" : ["#FFFFD9", "#EDF8B1", "#C7E9B4", "#7FCDBB", "#41B6C4", "#1D91C0", "#225EA8", "#0C2C84"] },
    { "name" : "rg-colors-ylgnbu-8-seqr.css", "colors" : ["#0C2C84", "#225EA8", "#1D91C0", "#41B6C4", "#7FCDBB", "#C7E9B4", "#EDF8B1", "#FFFFD9"] },
    { "name" : "rg-colors-ylgnbu-9-seq.css", "colors" : ["#FFFFD9", "#EDF8B1", "#C7E9B4", "#7FCDBB", "#41B6C4", "#1D91C0", "#225EA8", "#253494", "#081D58"] },
    { "name" : "rg-colors-ylgnbu-9-seqr.css", "colors" : ["#081D58", "#253494", "#225EA8", "#1D91C0", "#41B6C4", "#7FCDBB", "#C7E9B4", "#EDF8B1", "#FFFFD9"] },
    { "name" : "rg-colors-ylorbr-3-seq.css", "colors" : ["#FFF7BC", "#FEC44F", "#D95F0E"] },
    { "name" : "rg-colors-ylorbr-3-seqr.css", "colors" : ["#D95F0E", "#FEC44F", "#FFF7BC"] },
    { "name" : "rg-colors-ylorbr-4-seq.css", "colors" : ["#FFFFD4", "#FED98E", "#FE9929", "#CC4C02"] },
    { "name" : "rg-colors-ylorbr-4-seqr.css", "colors" : ["#CC4C02", "#FE9929", "#FED98E", "#FFFFD4"] },
    { "name" : "rg-colors-ylorbr-5-seq.css", "colors" : ["#FFFFD4", "#FED98E", "#FE9929", "#D95F0E", "#993404"] },
    { "name" : "rg-colors-ylorbr-5-seqr.css", "colors" : ["#993404", "#D95F0E", "#FE9929", "#FED98E", "#FFFFD4"] },
    { "name" : "rg-colors-ylorbr-6-seq.css", "colors" : ["#FFFFD4", "#FEE391", "#FEC44F", "#FE9929", "#D95F0E", "#993404"] },
    { "name" : "rg-colors-ylorbr-6-seqr.css", "colors" : ["#993404", "#D95F0E", "#FE9929", "#FEC44F", "#FEE391", "#FFFFD4"] },
    { "name" : "rg-colors-ylorbr-7-seq.css", "colors" : ["#FFFFD4", "#FEE391", "#FEC44F", "#FE9929", "#EC7014", "#CC4C02", "#8C2D04"] },
    { "name" : "rg-colors-ylorbr-7-seqr.css", "colors" : ["#8C2D04", "#CC4C02", "#EC7014", "#FE9929", "#FEC44F", "#FEE391", "#FFFFD4"] },
    { "name" : "rg-colors-ylorbr-8-seq.css", "colors" : ["#FFFFE5", "#FFF7BC", "#FEE391", "#FEC44F", "#FE9929", "#EC7014", "#CC4C02", "#8C2D04"] },
    { "name" : "rg-colors-ylorbr-8-seqr.css", "colors" : ["#8C2D04", "#CC4C02", "#EC7014", "#FE9929", "#FEC44F", "#FEE391", "#FFF7BC", "#FFFFE5"] },
    { "name" : "rg-colors-ylorbr-9-seq.css", "colors" : ["#FFFFE5", "#FFF7BC", "#FEE391", "#FEC44F", "#FE9929", "#EC7014", "#CC4C02", "#993404", "#662506"] },
    { "name" : "rg-colors-ylorbr-9-seqr.css", "colors" : ["#662506", "#993404", "#CC4C02", "#EC7014", "#FE9929", "#FEC44F", "#FEE391", "#FFF7BC", "#FFFFE5"] },
    { "name" : "rg-colors-ylorrd-3-seq.css", "colors" : ["#FFEDA0", "#FEB24C", "#F03B20"] },
    { "name" : "rg-colors-ylorrd-3-seqr.css", "colors" : ["#F03B20", "#FEB24C", "#FFEDA0"] },
    { "name" : "rg-colors-ylorrd-4-seq.css", "colors" : ["#FFFFB2", "#FECC5C", "#FD8D3C", "#E31A1C"] },
    { "name" : "rg-colors-ylorrd-4-seqr.css", "colors" : ["#E31A1C", "#FD8D3C", "#FECC5C", "#FFFFB2"] },
    { "name" : "rg-colors-ylorrd-5-seq.css", "colors" : ["#FFFFB2", "#FECC5C", "#FD8D3C", "#F03B20", "#BD0026"] },
    { "name" : "rg-colors-ylorrd-5-seqr.css", "colors" : ["#BD0026", "#F03B20", "#FD8D3C", "#FECC5C", "#FFFFB2"] },
    { "name" : "rg-colors-ylorrd-6-seq.css", "colors" : ["#FFFFB2", "#FED976", "#FEB24C", "#FD8D3C", "#F03B20", "#BD0026"] },
    { "name" : "rg-colors-ylorrd-6-seqr.css", "colors" : ["#BD0026", "#F03B20", "#FD8D3C", "#FEB24C", "#FED976", "#FFFFB2"] },
    { "name" : "rg-colors-ylorrd-7-seq.css", "colors" : ["#FFFFB2", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"] },
    { "name" : "rg-colors-ylorrd-7-seqr.css", "colors" : ["#B10026", "#E31A1C", "#FC4E2A", "#FD8D3C", "#FEB24C", "#FED976", "#FFFFB2"] },
    { "name" : "rg-colors-ylorrd-8-seq.css", "colors" : ["#FFFFCC", "#FFEDA0", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#B10026"] },
    { "name" : "rg-colors-ylorrd-8-seqr.css", "colors" : ["#B10026", "#E31A1C", "#FC4E2A", "#FD8D3C", "#FEB24C", "#FED976", "#FFEDA0", "#FFFFCC"] },
    { "name" : "rg-colors-ylorrd-9-seq.css", "colors" : ["#FFFFCC", "#FFEDA0", "#FED976", "#FEB24C", "#FD8D3C", "#FC4E2A", "#E31A1C", "#BD0026", "#800026"] },
    { "name" : "rg-colors-ylorrd-9-seqr.css", "colors" : ["#800026", "#BD0026", "#E31A1C", "#FC4E2A", "#FD8D3C", "#FEB24C", "#FED976", "#FFEDA0", "#FFFFCC"] }
  ];
});
define('lib/util/view/editors/rgcsseditor',[
    "jquery"
  , "lib/util/ui"
  , "lib/util/view/editors/editor"
  , "config/rgcolors"
],

function($, ui, createEditor, rgcolors) {
  return function(el, options) {
    options = $.extend({default : "" }, options);

    var menu = ui.selectmenu(el, {
      data : rgcolors,
      format : function(item) {
        var label = '<span class="tiny">' + item.name.substr(10).split(".").shift() + "</span>&nbsp;";
        $.each(item.colors, function() {
          label += '<span class="minipalette" style="background-color: '+this+'"></span>';
        });
        return '<span class="text" data-css="'+item.name+'">'+label+'</span>';
      },
      width : 320
    });
    var $input = $('<input type="hidden" class="string">');

    $(menu).on("select", function(e, data, c) {
      $input.val(data.name);
      $input.change();
    });

    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v.trim(); }
    };

    var ed = createEditor(el, options, params);
    el.find(".control-container").hide();
    return ed;
  };
});
/*
 * jQuery miniColors: A small color selector
 *
 * Copyright 2012 Cory LaViska for A Beautiful Site, LLC. (http://www.abeautifulsite.net/)
 *
 * Dual licensed under the MIT or GPL Version 2 licenses
 *
*/
if(jQuery) (function($) {
	
	$.extend($.fn, {
		
		miniColors: function(o, data) {
			
			var create = function(input, o, data) {
				//
				// Creates a new instance of the miniColors selector
				//
				
				// Determine initial color (defaults to white)
				var color = expandHex(input.val()) || 'ffffff',
					hsb = hex2hsb(color),
					rgb = hsb2rgb(hsb),
					alpha = parseFloat(input.attr('data-opacity')).toFixed(2);
				
				if( alpha > 1 ) alpha = 1;
				if( alpha < 0 ) alpha = 0;
				
				// Create trigger
				var trigger = $('<a class="miniColors-trigger" style="background-color: #' + color + '" href="#"></a>');
				trigger.insertAfter(input);
				trigger.wrap('<span class="miniColors-triggerWrap"></span>');
				if( o.opacity ) {
					trigger.css('backgroundColor', 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + alpha + ')');
				}
				
				// Set input data and update attributes
				input
					.addClass('miniColors')
					.data('original-maxlength', input.attr('maxlength') || null)
					.data('original-autocomplete', input.attr('autocomplete') || null)
					.data('letterCase', o.letterCase === 'uppercase' ? 'uppercase' : 'lowercase')
					.data('opacity', o.opacity ? true : false)
					.data('alpha', alpha)
					.data('trigger', trigger)
					.data('hsb', hsb)
					.data('change', o.change ? o.change : null)
					.data('close', o.close ? o.close : null)
					.data('open', o.open ? o.open : null)
					.attr('maxlength', 7)
					.attr('autocomplete', 'off')
					.val('#' + convertCase(color, o.letterCase));
				
				// Handle options
				if( o.readonly || input.prop('readonly') ) input.prop('readonly', true);
				if( o.disabled || input.prop('disabled') ) disable(input);
				
				// Show selector when trigger is clicked
				trigger.on('click.miniColors', function(event) {
					event.preventDefault();
					if( input.val() === '' ) input.val('#');
					show(input);

				});
				
				// Show selector when input receives focus
				input.on('focus.miniColors', function(event) {
					if( input.val() === '' ) input.val('#');
					show(input);
				});
				
				// Hide on blur
				input.on('blur.miniColors', function(event) {
					var hex = expandHex( hsb2hex(input.data('hsb')) );
					input.val( hex ? '#' + convertCase(hex, input.data('letterCase')) : '' );
				});
				
				// Hide when tabbing out of the input
				input.on('keydown.miniColors', function(event) {
					if( event.keyCode === 9 ) hide(input);
				});
				
				// Update when color is typed in
				input.on('keyup.miniColors', function(event) {
					setColorFromInput(input);
				});
				
				// Handle pasting
				input.on('paste.miniColors', function(event) {
					// Short pause to wait for paste to complete
					setTimeout( function() {
						setColorFromInput(input);
					}, 5);
				});
				
			};
			
			var destroy = function(input) {
				//
				// Destroys an active instance of the miniColors selector
				//
				hide();
				input = $(input);
				
				// Restore to original state
				input.data('trigger').parent().remove();
				input
					.attr('autocomplete', input.data('original-autocomplete'))
					.attr('maxlength', input.data('original-maxlength'))
					.removeData()
					.removeClass('miniColors')
					.off('.miniColors');
				$(document).off('.miniColors');
			};
			
			var enable = function(input) {
				//
				// Enables the input control and the selector
				//
				input
					.prop('disabled', false)
					.data('trigger').parent().removeClass('disabled');
			};
			
			var disable = function(input) {
				//
				// Disables the input control and the selector
				//
				hide(input);
				input
					.prop('disabled', true)
					.data('trigger').parent().addClass('disabled');
			};
			
			var show = function(input) {
				//
				// Shows the miniColors selector
				//
				if( input.prop('disabled') ) return false;
				
				// Hide all other instances 
				hide();				
                
				// Generate the selector
				var selector = $('<div class="miniColors-selector"></div>');
				selector
					.append('<div class="miniColors-hues"><div class="miniColors-huePicker"></div></div>')
					.append('<div class="miniColors-colors" style="background-color: #FFF;"><div class="miniColors-colorPicker"><div class="miniColors-colorPicker-inner"></div></div>')
					.css('display', 'none')
					.addClass( input.attr('class') );
				
				// Opacity
				if( input.data('opacity') ) {
					selector
						.addClass('opacity')
						.prepend('<div class="miniColors-opacity"><div class="miniColors-opacityPicker"></div></div>');
				}
				
				// Set background for colors
				var hsb = input.data('hsb');
				selector
					.find('.miniColors-colors').css('backgroundColor', '#' + hsb2hex({ h: hsb.h, s: 100, b: 100 })).end()
					.find('.miniColors-opacity').css('backgroundColor', '#' + hsb2hex({ h: hsb.h, s: hsb.s, b: hsb.b })).end();
				
				// Set colorPicker position
				var colorPosition = input.data('colorPosition');
				if( !colorPosition ) colorPosition = getColorPositionFromHSB(hsb);
				selector.find('.miniColors-colorPicker')
					.css('top', colorPosition.y + 'px')
					.css('left', colorPosition.x + 'px');
				
				// Set huePicker position
				var huePosition = input.data('huePosition');
				if( !huePosition ) huePosition = getHuePositionFromHSB(hsb);
				selector.find('.miniColors-huePicker').css('top', huePosition + 'px');
				
				// Set opacity position
				var opacityPosition = input.data('opacityPosition');
				if( !opacityPosition ) opacityPosition = getOpacityPositionFromAlpha(input.attr('data-opacity'));
				selector.find('.miniColors-opacityPicker').css('top', opacityPosition + 'px');
				
				// Set input data
				input
					.data('selector', selector)
					.data('huePicker', selector.find('.miniColors-huePicker'))
					.data('opacityPicker', selector.find('.miniColors-opacityPicker'))
					.data('colorPicker', selector.find('.miniColors-colorPicker'))
					.data('mousebutton', 0);
				
				$('BODY').append(selector);
				
				// Position the selector
				var trigger = input.data('trigger'),
					hidden = !input.is(':visible'),
					top = hidden ? trigger.offset().top + trigger.outerHeight() : input.offset().top + input.outerHeight(),
					left = hidden ? trigger.offset().left : input.offset().left,
					selectorWidth = selector.outerWidth(),
					selectorHeight = selector.outerHeight(),
					triggerWidth = trigger.outerWidth(),
					triggerHeight = trigger.outerHeight(),
					windowHeight = $(window).height(),
					windowWidth = $(window).width(),
					scrollTop = $(window).scrollTop(),
					scrollLeft = $(window).scrollLeft();
				
				// Adjust based on viewport
				if( (top + selectorHeight) > windowHeight + scrollTop ) top = top - selectorHeight - triggerHeight;
				if( (left + selectorWidth) > windowWidth + scrollLeft ) left = left - selectorWidth + triggerWidth;
				
				// Set position and show
				selector.css({
					top: top,
					left: left
				}).fadeIn(100);
				
				// Prevent text selection in IE
				selector.on('selectstart', function() { return false; });
				
				// Hide on resize (IE7/8 trigger this when any element is resized...)
				if( !$.browser.msie || ($.browser.msie && $.browser.version >= 9) ) {
					$(window).on('resize.miniColors', function(event) {
						hide(input);
					});
				}
				
				$(document)
					.on('mousedown.miniColors touchstart.miniColors', function(event) {
						
						input.data('mousebutton', 1);
						var testSubject = $(event.target).parents().andSelf();
						
						if( testSubject.hasClass('miniColors-colors') ) {
							event.preventDefault();
							input.data('moving', 'colors');
							moveColor(input, event);
						}
						
						if( testSubject.hasClass('miniColors-hues') ) {
							event.preventDefault();
							input.data('moving', 'hues');
							moveHue(input, event);
						}
						
						if( testSubject.hasClass('miniColors-opacity') ) {
							event.preventDefault();
							input.data('moving', 'opacity');
							moveOpacity(input, event);
						}
						
						if( testSubject.hasClass('miniColors-selector') ) {
							event.preventDefault();
							return;
						}
						
						if( testSubject.hasClass('miniColors') ) return;
						
						hide(input);
					})
					.on('mouseup.miniColors touchend.miniColors', function(event) {
					    event.preventDefault();
						input.data('mousebutton', 0).removeData('moving');
					})
					.on('mousemove.miniColors touchmove.miniColors', function(event) {
						event.preventDefault();
						if( input.data('mousebutton') === 1 ) {
							if( input.data('moving') === 'colors' ) moveColor(input, event);
							if( input.data('moving') === 'hues' ) moveHue(input, event);
							if( input.data('moving') === 'opacity' ) moveOpacity(input, event);
						}
					});
				
				// Fire open callback
				if( input.data('open') ) {
					input.data('open').call(input.get(0), '#' + hsb2hex(hsb), $.extend(hsb2rgb(hsb), { a: parseFloat(input.attr('data-opacity')) }));
				}
				
			};
			
			var hide = function(input) {
				
				//
				// Hides one or more miniColors selectors
				//
				
				// Hide all other instances if input isn't specified
				if( !input ) input = $('.miniColors');
				
				input.each( function() {
					var selector = $(this).data('selector');
					$(this).removeData('selector');
					$(selector).fadeOut(100, function() {
						// Fire close callback
						if( input.data('close') ) {
							var hsb = input.data('hsb'), hex = hsb2hex(hsb);	
							input.data('close').call(input.get(0), '#' + hex, $.extend(hsb2rgb(hsb), { a: parseFloat(input.attr('data-opacity')) }));
						}
						$(this).remove();
					});
				});
				
				$(document).off('.miniColors');
				
			};
			
			var moveColor = function(input, event) {

				var colorPicker = input.data('colorPicker');
				
				colorPicker.hide();
				
				var position = {
					x: event.pageX,
					y: event.pageY
				};
				
				// Touch support
				if( event.originalEvent.changedTouches ) {
					position.x = event.originalEvent.changedTouches[0].pageX;
					position.y = event.originalEvent.changedTouches[0].pageY;
				}
				position.x = position.x - input.data('selector').find('.miniColors-colors').offset().left - 6;
				position.y = position.y - input.data('selector').find('.miniColors-colors').offset().top - 6;
				if( position.x <= -5 ) position.x = -5;
				if( position.x >= 144 ) position.x = 144;
				if( position.y <= -5 ) position.y = -5;
				if( position.y >= 144 ) position.y = 144;
				
				input.data('colorPosition', position);
				colorPicker.css('left', position.x).css('top', position.y).show();
				
				// Calculate saturation
				var s = Math.round((position.x + 5) * 0.67);
				if( s < 0 ) s = 0;
				if( s > 100 ) s = 100;
				
				// Calculate brightness
				var b = 100 - Math.round((position.y + 5) * 0.67);
				if( b < 0 ) b = 0;
				if( b > 100 ) b = 100;
				
				// Update HSB values
				var hsb = input.data('hsb');
				hsb.s = s;
				hsb.b = b;
				
				// Set color
				setColor(input, hsb, true);
			};
			
			var moveHue = function(input, event) {
				
				var huePicker = input.data('huePicker');
				
				huePicker.hide();
				
				var position = event.pageY;
				
				// Touch support
				if( event.originalEvent.changedTouches ) {
					position = event.originalEvent.changedTouches[0].pageY;
				}
				
				position = position - input.data('selector').find('.miniColors-colors').offset().top - 1;
				if( position <= -1 ) position = -1;
				if( position >= 149 ) position = 149;
				input.data('huePosition', position);
				huePicker.css('top', position).show();
				
				// Calculate hue
				var h = Math.round((150 - position - 1) * 2.4);
				if( h < 0 ) h = 0;
				if( h > 360 ) h = 360;
				
				// Update HSB values
				var hsb = input.data('hsb');
				hsb.h = h;
				
				// Set color
				setColor(input, hsb, true);
				
			};
			
			var moveOpacity = function(input, event) {
				
				var opacityPicker = input.data('opacityPicker');
				
				opacityPicker.hide();
				
				var position = event.pageY;
				
				// Touch support
				if( event.originalEvent.changedTouches ) {
					position = event.originalEvent.changedTouches[0].pageY;
				}
				
				position = position - input.data('selector').find('.miniColors-colors').offset().top - 1;
				if( position <= -1 ) position = -1;
				if( position >= 149 ) position = 149;
				input.data('opacityPosition', position);
				opacityPicker.css('top', position).show();
				
				// Calculate opacity
				var alpha = parseFloat((150 - position - 1) / 150).toFixed(2);
				if( alpha < 0 ) alpha = 0;
				if( alpha > 1 ) alpha = 1;
				
				// Update opacity
				input
					.data('alpha', alpha)
					.attr('data-opacity', alpha);
				
				// Set color
				setColor(input, input.data('hsb'), true);
				
			};
			
			var setColor = function(input, hsb, updateInput) {
				input.data('hsb', hsb);
				var hex = hsb2hex(hsb), 
					selector = $(input.data('selector'));
				if( updateInput ) input.val( '#' + convertCase(hex, input.data('letterCase')) );
				
				selector
					.find('.miniColors-colors').css('backgroundColor', '#' + hsb2hex({ h: hsb.h, s: 100, b: 100 })).end()
					.find('.miniColors-opacity').css('backgroundColor', '#' + hex).end();
				
				var rgb = hsb2rgb(hsb);
				
				// Set background color (also fallback for non RGBA browsers)
				input.data('trigger').css('backgroundColor', '#' + hex);
				
				// Set background color + opacity
				if( input.data('opacity') ) {
					input.data('trigger').css('backgroundColor', 'rgba(' + rgb.r + ', ' + rgb.g + ', ' + rgb.b + ', ' + input.attr('data-opacity') + ')');
				}
				
				// Fire change callback
				if( input.data('change') ) {
					if( (hex + ',' + input.attr('data-opacity')) === input.data('lastChange') ) return;
					input.data('change').call(input.get(0), '#' + hex, $.extend(hsb2rgb(hsb), { a: parseFloat(input.attr('data-opacity')) }));
					input.data('lastChange', hex + ',' + input.attr('data-opacity'));
				}
				
			};
			
			var setColorFromInput = function(input) {
				
				input.val('#' + cleanHex(input.val()));
				var hex = expandHex(input.val());
				if( !hex ) return false;
				
				// Get HSB equivalent
				var hsb = hex2hsb(hex);
				
				// Set colorPicker position
				var colorPosition = getColorPositionFromHSB(hsb);
				var colorPicker = $(input.data('colorPicker'));
				colorPicker.css('top', colorPosition.y + 'px').css('left', colorPosition.x + 'px');
				input.data('colorPosition', colorPosition);
				
				// Set huePosition position
				var huePosition = getHuePositionFromHSB(hsb);
				var huePicker = $(input.data('huePicker'));
				huePicker.css('top', huePosition + 'px');
				input.data('huePosition', huePosition);
				
				// Set opacity position
				var opacityPosition = getOpacityPositionFromAlpha(input.attr('data-opacity'));
				var opacityPicker = $(input.data('opacityPicker'));
				opacityPicker.css('top', opacityPosition + 'px');
				input.data('opacityPosition', opacityPosition);
				setColor(input, hsb);
				
				return true;
				
			};
			
			var convertCase = function(string, letterCase) {
				if( letterCase === 'uppercase' ) {
					return string.toUpperCase();
				} else {
					return string.toLowerCase();
				}
			};
			
			var getColorPositionFromHSB = function(hsb) {				
				var x = Math.ceil(hsb.s / 0.67);
				if( x < 0 ) x = 0;
				if( x > 150 ) x = 150;
				var y = 150 - Math.ceil(hsb.b / 0.67);
				if( y < 0 ) y = 0;
				if( y > 150 ) y = 150;
				return { x: x - 5, y: y - 5 };
			};
			
			var getHuePositionFromHSB = function(hsb) {
				var y = 150 - (hsb.h / 2.4);
				if( y < 0 ) h = 0;
				if( y > 150 ) h = 150;				
				return y;
			};
			
			var getOpacityPositionFromAlpha = function(alpha) {
				var y = 150 * alpha;
				if( y < 0 ) y = 0;
				if( y > 150 ) y = 150;
				return 150 - y;
			};
			
			var cleanHex = function(hex) {
				return hex.replace(/[^A-F0-9]/ig, '');
			};
			
			var expandHex = function(hex) {
				hex = cleanHex(hex);
				if( !hex ) return null;
				if( hex.length === 3 ) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
				return hex.length === 6 ? hex : null;
			};			
			
			var hsb2rgb = function(hsb) {
				var rgb = {};
				var h = Math.round(hsb.h);
				var s = Math.round(hsb.s*255/100);
				var v = Math.round(hsb.b*255/100);
				if(s === 0) {
					rgb.r = rgb.g = rgb.b = v;
				} else {
					var t1 = v;
					var t2 = (255 - s) * v / 255;
					var t3 = (t1 - t2) * (h % 60) / 60;
					if( h === 360 ) h = 0;
					if( h < 60 ) { rgb.r = t1; rgb.b = t2; rgb.g = t2 + t3; }
					else if( h < 120 ) {rgb.g = t1; rgb.b = t2; rgb.r = t1 - t3; }
					else if( h < 180 ) {rgb.g = t1; rgb.r = t2; rgb.b = t2 + t3; }
					else if( h < 240 ) {rgb.b = t1; rgb.r = t2; rgb.g = t1 - t3; }
					else if( h < 300 ) {rgb.b = t1; rgb.g = t2; rgb.r = t2 + t3; }
					else if( h < 360 ) {rgb.r = t1; rgb.g = t2; rgb.b = t1 - t3; }
					else { rgb.r = 0; rgb.g = 0; rgb.b = 0; }
				}
				return {
					r: Math.round(rgb.r),
					g: Math.round(rgb.g),
					b: Math.round(rgb.b)
				};
			};
			
			var rgb2hex = function(rgb) {
				var hex = [
					rgb.r.toString(16),
					rgb.g.toString(16),
					rgb.b.toString(16)
				];
				$.each(hex, function(nr, val) {
					if (val.length === 1) hex[nr] = '0' + val;
				});
				return hex.join('');
			};
			
			var hex2rgb = function(hex) {
				hex = parseInt(((hex.indexOf('#') > -1) ? hex.substring(1) : hex), 16);
				
				return {
					r: hex >> 16,
					g: (hex & 0x00FF00) >> 8,
					b: (hex & 0x0000FF)
				};
			};
			
			var rgb2hsb = function(rgb) {
				var hsb = { h: 0, s: 0, b: 0 };
				var min = Math.min(rgb.r, rgb.g, rgb.b);
				var max = Math.max(rgb.r, rgb.g, rgb.b);
				var delta = max - min;
				hsb.b = max;
				hsb.s = max !== 0 ? 255 * delta / max : 0;
				if( hsb.s !== 0 ) {
					if( rgb.r === max ) {
						hsb.h = (rgb.g - rgb.b) / delta;
					} else if( rgb.g === max ) {
						hsb.h = 2 + (rgb.b - rgb.r) / delta;
					} else {
						hsb.h = 4 + (rgb.r - rgb.g) / delta;
					}
				} else {
					hsb.h = -1;
				}
				hsb.h *= 60;
				if( hsb.h < 0 ) {
					hsb.h += 360;
				}
				hsb.s *= 100/255;
				hsb.b *= 100/255;
				return hsb;
			};			
			
			var hex2hsb = function(hex) {
				var hsb = rgb2hsb(hex2rgb(hex));
				// Zero out hue marker for black, white, and grays (saturation === 0)
				if( hsb.s === 0 ) hsb.h = 360;
				return hsb;
			};
			
			var hsb2hex = function(hsb) {
				return rgb2hex(hsb2rgb(hsb));
			};

			
			// Handle calls to $([selector]).miniColors()
			switch(o) {
			
				case 'readonly':
					
					$(this).each( function() {
						if( !$(this).hasClass('miniColors') ) return;
						$(this).prop('readonly', data);
					});
					
					return $(this);
				
				case 'disabled':
					
					$(this).each( function() {
						if( !$(this).hasClass('miniColors') ) return;
						if( data ) {
							disable($(this));
						} else {
							enable($(this));
						}
					});
										
					return $(this);
			
				case 'value':
					
					// Getter
					if( data === undefined ) {
						if( !$(this).hasClass('miniColors') ) return;
						var input = $(this),
							hex = expandHex(input.val());
						return hex ? '#' + convertCase(hex, input.data('letterCase')) : null;
					}
					
					// Setter
					$(this).each( function() {
						if( !$(this).hasClass('miniColors') ) return;
						$(this).val(data);
						setColorFromInput($(this));
					});
					
					return $(this);
				
				case 'opacity':
					
					// Getter
					if( data === undefined ) {
						if( !$(this).hasClass('miniColors') ) return;
						if( $(this).data('opacity') ) {
							return parseFloat($(this).attr('data-opacity'));
						} else {
							return null;
						}
					}
					
					// Setter
					$(this).each( function() {
						if( !$(this).hasClass('miniColors') ) return;
						if( data < 0 ) data = 0;
						if( data > 1 ) data = 1;
						$(this).attr('data-opacity', data).data('alpha', data);
						setColorFromInput($(this));
					});
					
					return $(this);
					
				case 'destroy':
					
					$(this).each( function() {
						if( !$(this).hasClass('miniColors') ) return;
						destroy($(this));
					});
										
					return $(this);
				
				default:
					
					if( !o ) o = {};
					
					$(this).each( function() {
						
						// Must be called on an input element
						if( $(this)[0].tagName.toLowerCase() !== 'input' ) return;
						
						// If a trigger is present, the control was already created
						if( $(this).data('trigger') ) return;
						
						// Create the control
						create($(this), o, data);
						
					});
					
					return $(this);
					
			}
			
		}
			
	});
	
})(jQuery);
define("ext/jquery-minicolors/jquery.miniColors", function(){});

define('lib/util/view/editors/coloreditor',[
    "jquery"
  , "lib/util/view/editors/editor"
  , "ext/jquery-minicolors/jquery.miniColors"
],

function($, createEditor) {
  return function(el, options) {
    options = $.extend({default : "" }, options);

    function validateColor(color) {
      return (/^(rgb\s*\(\s*[012]?[0-9]{1,2}\s*,\s*[012]?[0-9]{1,2}\s*,\s*[012]?[0-9]{1,2}\s*\)|#[0-9a-f]{3}([0-9a-f]{3})?)$/i).test(color);
    }

    var $input = $('<input type="text" class="color">'),
        $colors = $('<div class="color-list"></ul>');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) {
        var values = v.split(",").map(function(v) { return v.trim(); }).filter(function(v) { return v != ""; });
        for(var i = 0; i < values.length; i++) {
          if(!validateColor(values[i]))
            return "color at position " + i + " is invalid";
        }
        return null;
      },
      filter : options.filter || function(v) {
        return v.split(",").map(function(v) { return v.trim(); }).join(",");
      }
    };


    var ed = createEditor(el, options, params);
    /*
    $('<div class="colors-container"></div>').insertAfter(el.find('.control-container')).append($colors);
    ed.value.on("value.change", function(colors) {
      $colors.children("*").remove();
      $.each(colors.split(","), function() {
        var color = this,
            $cin = $('<input type="hidden">');
        $colors.append($cin);
        $cin.miniColors({
          close : function(hex, rgb) {
            var s = [];
            $colors.find("input").each(function() {
              var val = $(this).val();
              if(val.substr(1,3) === val.substr(4))
                val = val.substr(0, 4);
              s.push(val);
            });
            ed.value.set(s.join(","));
          }
        }).miniColors("value", color);
      });
    });
    */

    $input.miniColors();

    if(options.default)
      ed.value.set(options.default);

    return ed;
  };
});
define('lib/util/view/editors/colorlisteditor',[
    "jquery"
  , "lib/util/view/editors/editor"
  , "ext/jquery-minicolors/jquery.miniColors"
],

function($, createEditor) {
  return function(el, options) {
    options = $.extend({default : "" }, options);

    function validateColor(color) {
      return (/^(rgb\s*\(\s*[012]?[0-9]{1,2}\s*,\s*[012]?[0-9]{1,2}\s*,\s*[012]?[0-9]{1,2}\s*\)|#[0-9a-f]{3}([0-9a-f]{3})?)$/i).test(color);
    }

    var $input = $('<input type="text" class="colors">'),
        $colors = $('<div class="color-list"></ul>');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) {
        var values = v.split(",").map(function(v) { return v.trim(); }).filter(function(v) { return v != ""; });
        for(var i = 0; i < values.length; i++) {
          if(!validateColor(values[i]))
            return "color at position " + i + " is invalid";
        }
        return null;
      },
      filter : options.filter || function(v) {
        return v.split(",").map(function(v) { return v.trim(); }).join(",");
      }
    };

    var ed = createEditor(el, options, params);
    $('<div class="colors-container"></div>').insertAfter(el.find('.control-container')).append($colors);
    ed.value.on("value.change", function(colors) {
      $colors.children("*").remove();
      $.each(colors.split(","), function() {
        var color = this,
            $cin = $('<input type="hidden">');
        $colors.append($cin);
        $cin.miniColors({
          close : function(hex, rgb) {
            var s = [];
            $colors.find("input").each(function() {
              var val = $(this).val();
              if(val.substr(1,3) === val.substr(4))
                val = val.substr(0, 4);
              s.push(val);
            });
            ed.value.set(s.join(","));
          }
        }).miniColors("value", color);
      });
    });
    if(options.default)
      ed.value.set(options.default);

    return ed;
  };
});
define('lib/util/view/editors/fileeditor',[
  "lib/util/view/editors/editor"
],

function(createEditor) {
  return function(el, options) {
    options = $.extend({default : null }, options);
    var $input = $('<input type="file" class="file">');
    if(options.className)
      $input.addClass(options.className);
    var params = {
      input : $input,
      validate : options.validate || function(v) { return null; },
      filter : options.filter || function(v) { return v; },
      get : function() {
        var list = params.input[0].files;
        if(list.length === 0)
          return null;
        else
          return list[0];
      },
      set : function(v) {
        // do nothing
      }
    };

    return createEditor(el, options, params);
  };
});
define('lib/util/view/editors/editors',[
    "lib/util/view/editors/floateditor"
  , "lib/util/view/editors/inteditor"
  , "lib/util/view/editors/booleditor"
  , "lib/util/view/editors/expressioneditor"
  , "lib/util/view/editors/stringeditor"
  , "lib/util/view/editors/texteditor"
  , "lib/util/view/editors/selectioneditor"
  , "lib/util/view/editors/templateeditor"
  , "lib/util/view/editors/rgcsseditor"
  , "lib/util/view/editors/coloreditor"
  , "lib/util/view/editors/colorlisteditor"
  , "lib/util/view/editors/fileeditor"
],

function() {
  var editors = $.makeArray(arguments),
      types   = ["float", "int", "boolean", "expression", "string", "text", "selection", "template", "rgcss", "color", "colorlist", "file"];

  return {
    create : function(el, type, options){
       var index = types.indexOf(type);
      if(index < 0)
        throw "There is no editor for '" + type + "'";
      return editors[index](el, options);
    }
  };
});
define('lib/model/typeguesser',[],
/*
 continuous
 time
 discrete
 ordinal ?
 category
 data
*/
function() {

  return {
    guess : function(value) {
      if(null === value || "undefined" === typeof value)
        return false;
      if("string" === typeof value) {
        // time, category
        return "category";
      } else if("number" === typeof value) {
        // time, continuous, discrete
        if(Math.round(value) == value)
          return "discrete";
        else
          return "continuous";
      } else if("boolean" === typeof value) {
        return "category";
      } else {
        return "data";
      }
    }
  };
});
define('lib/model/modelguesser',[
  "lib/model/typeguesser"
],
function(type) {
  function appendField(ob, key, value) {
    var t = type.guess(value);
    if(false === value) return;
    ob[key] = t;
  }
  return {
    object : function(ob) {
      var map  = {};
      for(var key in ob) {
        if(!ob.hasOwnProperty(key)) continue;
        appendField(map, key, ob[key]);
      }
      return map;
    },
    increment : function(result, src) {
      for(var key in src) {
        if(!src.hasOwnProperty(key) || "undefined" !== typeof result[key]) continue;
        appendField(result, key, src[key])
      }
    },
    list : function(arr) {
      var len = arr.length;
      if(len === 0) return [];
      var result = this.object(arr[0]);
      for(var i = 1; i < len; i++) {
        this.increment(result, arr[i]);
      }

      var out = [];
      for(var key in result) {
        if(!result.hasOwnProperty(key)) continue;
        out.push({
          name  : key,
          field : key,
          type  : result[key]
        });
      }
      return out;
    }
  };
});

//{ name : "day", field:"time:day", type : "time" };
define('text!templates/form.datasource.html',[],function () { return '<div class="fieldset">\n    <div class="ui-dialog-titlebar ui-widget-header ui-helper-clearfix">create new</div>\n    <dl>\n        <dt>path</dt>\n        <dd class="path">/</dd>\n        <dt>name</dt>\n        <dd class="name"></dd>\n        <dt>type</dt>\n        <dd class="type"></dd>\n        <dd class="error ui-content ui-state-error ui-corner-all"></dd>\n        <dd class="actions"></dd>\n        <dt>fields</dt>\n        <dd class="fields"></dd>\n    </dl>\n</div>';});

define('modules/view/datasourceedit',[
    "jquery"
  , "lib/util/view/editors/editors"
  , "lib/model/dataloader"
  , "lib/model/modelguesser"
  , "lib/util/ui"
  , "text!templates/form.datasource.html"
],

function($, editors, createLoader, guess, ui, tplForm) {
  return function(ctx) {
    var $el, $error, $fields, $actions, $path, fields, loader, dataready = false, nameready = false;
    function init(container) {
      $el = $('<div class="datasource-form"></div>').append(tplForm).appendTo(container);
      $fields = $el.find("dd.fields");
      $error = $el.find("dd.error").hide();
      $path = $el.find("dd.path");
      $actions = $el.find(".actions");

      var $save = ui.button($actions, {
        label : "save",
        text : true,
        disabled : true
      });

      var ename = editors.create($el.find("dd.name"), "string", {
            placeholder : "Data Source Name",
            validate : function(value) {
              if(!value) return "name cannot be empty";
              var deferred = $.Deferred(),
                path = $path.text();
              if(path.substr(-1) !== "/") path += "/";
              path += value;

              ctx.on("response.datasource.path.validated", function(vpath, valid, reason) {
                if(path !== vpath) return;
                if(valid) {
                  deferred.resolve(null);
                  nameready = true;
                  changeSaveState();
                }
                else
                  deferred.resolve(reason);
              });

              ctx.trigger("request.datasource.path.validate", path);

              return deferred;
            }
          }),
          etype = editors.create($('<div class="type"></div>').appendTo($el.find("dd.type")), "selection", {
              default : "",
              values : [{
                value : "url",
                label : "remote service"
              }, {
                value : "text",
                label : "paste data"
              }, {
                value : "file",
                label : "upload file"
              }]
            }),
          $stype = $('<div class="stype"></div>').appendTo($el.find("dd.type")),
          stype;


      ename.value.on("value.validationError", function() {
        ename.el.find("div.error").addClass("ui-state-error ui-corner-all");
        nameready = false;
        changeSaveState();
      });

      function changeSaveState() {
        if(dataready && nameready) {
          $save.button("enable");
        } else {
          $save.button("disable");
        }
      }

      function success(data, type, opt) {
        fields = guess.list(data);
        $fields.html(fields.map(function(field) {
          return field.name;
        }).join(", "));
        ctx.trigger("data.datasource.preview.render", $.extend({ type : type, fields : fields }, opt));
        $save.off("click");
        $save.on("click", function() {
          nameready = false;
          changeSaveState();
          var path = $path.text();
          if(path.substr(-1) !== "/") path += "/";
          var name = ename.value.get();
          ctx.trigger("data.datasource.add", $.extend({
            path   : path + name,
            name   : name,
            type   : type,
            src    : stype.value.get(),
            fields : fields
          }, opt));
        });
        dataready = true;
        changeSaveState();
      }

      function error(msg) {
        dataready = false;
        changeSaveState();
        ctx.trigger("data.datasource.preview.clear");
        $fields.html("-");
        if(msg) {
          $error.html("error loading the data: " + msg);
          $error.show();
        } else {
          $error.hide();
        }
      }

      function clear() {
        dataready = false;
        changeSaveState();
        if(loader) {
          loader.abort();
        }
        $error.hide();
        $fields.html("-");
        changeSaveState();
      }

      function validateJsonString(s) {
        try {
          var json = JSON.parse(s);
          if(!json instanceof Array || "object" !== typeof json[0])
            return "the json string must be an array of objects";
          else
            return null;
        } catch(e) {
          return "invalid json format: " + e;
        }
      }

      etype.value.on("value.change", function(value) {
        clear();
        if(stype) {
          stype.destroy();
        }
        switch(value) {
          case "text":
            stype = editors.create($stype, "text", {
              placeholder : '[{"country:"USA",value:1000}]',
              validate : validateJsonString
            });
            stype.value.on("value.change", function(data) {
              success(JSON.parse(data), "text", { data : data });
            });
            stype.value.on("value.validationError", function() {
              error(null);
            });
            break;
          case "url":
            stype = editors.create($stype, "string", {
              placeholder : "http://www.example.com/data.json"
            });
            stype.value.on("value.change", function(value) {
              clear();
              $fields.html("loading ...");
              if(loader) {
                loader.abort();
              }
              loader = createLoader({
                type : "url",
                src  : value
              });
              loader.on("success", function(data) {
                success(data, "url", { src : value });
                loader = null;
              });
              loader.on("error", function(msg) {
                error(msg);
                loader = null;
              });
              loader.load();
            });
            break;
          case "file":
            stype = editors.create($stype, "file", {

            });
            stype.value.on("value.change", function(file) {
              var reader = new FileReader();
              reader.onload = function(e) {
                var data = e.target.result,
                    validation = validateJsonString(data);
                if(validation) {
                  error(validation);
                } else {
                  success(JSON.parse(data), "text", { data : data });
                }
              };
              reader.readAsText(file);
            });
            break;
        }
        stype.value.on("value.validationError", function() {
          stype.el.find("div.error").addClass("ui-state-error ui-corner-all");
        });
      });
      etype.value.set("url");

    }
    ctx.on("data.folder.select", function(path) {
      $path.text(path);
    });

    ctx.on("view.data.datasource", init);
  }
});
define('modules/view/datasourcetreeactions',[
    "jquery"
  , "lib/util/ui"
],

function($, ui) {
  return function(ctx) {

    function init(bar) {
      var $delete = ui.button(bar, {
            icon : "ui-icon-trash",
            disabled : true
          }),
          $newfolder = ui.button(bar, {
            icon : "ui-icon-new-folder",
            disabled : false
          });

      function deleteFolder(path) {
        return function() {
          if(window.confirm("Are you sure you want to delete the folder \"" + path + "\" and all of its contents?\nThis operation is not undoable."))
            ctx.trigger("data.folder.remove", path);
        }
      }

      function deleteDatasource(path) {
        return function() {
          if(window.confirm("Are you sure you want to delete the datasource at \"" + path + "\"?\nThis operation is not undoable."))
            ctx.trigger("data.datasource.removebypath", path);
        }
      }

      function createFolder(path) {
        return function() {
          var name = window.prompt("Create a new folder at: \"" + path + "\"");
          if(name === null)
            reutrn;
          name = name.trim();
          if(!name) {
            alert("the new folder cannot have an empty name");
          } else {
            var npath = path;
            if(npath.substr(-1) !== "/") npath += "/";
            npath += name;

            ctx.on("response.datasource.path.validated", function(vpath, valid, reason) {
              if(npath !== vpath) return;
              if(valid) {
                ctx.trigger("data.folder.add", npath);
              } else
                alert("Unable to create the folder \""+name+"\": " + reason);
            });

            ctx.trigger("request.datasource.path.validate", npath);
          }
        }
      }

      $newfolder.on("click", createFolder("/"));

      ctx.on("data.folder.select", function(path) {
        $newfolder
          .button("enable")
          .off("click")
          .on("click", createFolder(path))
        ;
      });

      ctx.on("data.folder.deselect", function(path) {
        $newfolder.button("disable");
      });

      ctx.on("data.folder.current", function(path) {
        if(path === "/") {
          $delete.button("disable");
        } else {
          $delete
            .button("enable")
            .off("click")
            .on("click", deleteFolder(path))
          ;
        }
      });

      ctx.on("data.datasource.current", function(path) {
        $delete
          .button("enable")
          .off("click")
          .on("click", deleteDatasource(path))
        ;
      });
    }

    ctx.on("view.data.toolbar-context", init);
  };
});
define('modules/view/reportstreeactions',[
    "jquery"
  , "lib/util/ui"
],

function($, ui) {
  return function(ctx) {

    function init_context(bar) {
      var $open = ui.button(bar, {
            icon : "ui-icon-query",
            disabled : true
          }),
          $import = ui.button(bar, {
            icon : "ui-icon-arrowthickstop-1-n",
            disabled : false
          }),
          $export = ui.button(bar, {
            icon : "ui-icon-arrowthickstop-1-s",
            disabled : true
          }),
          $delete = ui.button(bar, {
            icon : "ui-icon-trash",
            disabled : true
          }),
          $newfolder = ui.button(bar, {
            icon : "ui-icon-new-folder",
            disabled : false
          });

      function delete_folder(path) {
        return function() {
          if(window.confirm("Are you sure you want to delete the folder \"" + path + "\" and all of its contents?\nThis operation is not undoable."))
            ctx.trigger("reports.folder.remove", path);
        }
      }

      function delete_report(path) {
        return function() {
          if(window.confirm("Are you sure you want to delete the report at \"" + path + "\"?\nThis operation is not undoable."))
            ctx.trigger("reports.report.removebypath", path);
        }
      }

      function open_report(path) {
        return function() {
          ctx.trigger("reports.report.openpath", path);
        }
      }

      function import_report(path) {
        return function() {
          ctx.trigger("reports.report.importpath", path);
        }
      }

      function export_report(path) {
        return function() {
          ctx.trigger("reports.report.exportpath", path);
        }
      }

      function create_folder(path) {
        return function() {
          var name = window.prompt("Create a new folder at: \"" + path + "\"");
          if(name === null)
            return;
          name = name.trim();
          if(!name) {
            alert("the new folder cannot have an empty name");
          } else {
            var npath = path;
            if(npath.substr(-1) !== "/") npath += "/";
            npath += name;

            ctx.on("response.report.path.validated", function(vpath, valid, reason) {
              if(npath !== vpath) return;
              if(valid) {
                ctx.trigger("reports.folder.add", npath);
              } else
                alert("Unable to create the folder \""+name+"\": " + reason);
            });

            ctx.trigger("request.report.path.validate", npath);
          }
        }
      }

      $newfolder.on("click", create_folder("/"));
      $import.on("click", import_report("/"));

      ctx.on("reports.folder.select", function(path) {
        $newfolder
          .button("enable")
          .off("click")
          .on("click", create_folder(path))
        ;
        $import.button("enable")
          .off("click")
          .on("click", import_report(path))
        ;
      });

      ctx.on("reports.folder.deselect", function(path) {
        $newfolder.button("disable");
        $import.button("disable");
      });

      ctx.on("reports.folder.current", function(path) {
        if(path === "/") {
          $delete.button("disable");
        } else {
          $delete
            .button("enable")
            .off("click")
            .on("click", delete_folder(path))
          ;
        }
      });

      ctx.on("reports.report.deselect", function(path) {
        $open.button("disable");
        $export.button("disable");
      });

      ctx.on("reports.report.current", function(path) {
        $delete
          .button("enable")
          .off("click")
          .on("click", delete_report(path))
        ;
        $open
          .button("enable")
          .off("click")
          .on("click", open_report(path))
        ;
        $export
          .button("enable")
          .off("click")
          .on("click", export_report(path))
      });
    }

    function init_main(bar) {
      var currentFolder = "/",
          currentPath,
          working = false,
          $save = ui.button(bar, {
            icon : "ui-icon-disk",
            disabled : true
          });

      ctx.on("reports.folder.select", function(path) {
        currentFolder = path;
        if(currentFolder.substr(-1) !== "/")
          currentFolder += "/";
      });

      function enable_state_change() {
        clearTimeout(this.timer);
        this.timer = setTimeout(function() {
          ctx.off("chart.state.change", enable_state_change);
          ctx.on("chart.state.change", state_change);
        }, 750);
      }
      
      function open_path(path) {
        ctx.off("chart.state.change", state_change);
        ctx.on("chart.state.change", enable_state_change);
        currentPath = path;
        $save.button("disable");
      }

      function state_change(state) {
        if(working) return;
        $save.off("click");
        $save.on("click", function() {
          if(!currentPath) {
            var name = window.prompt("Please input a name for the current chart");
            if(null === name) {
              return;
            }
            $save.button("disable");
            working = true;
            ctx.on("response.report.path.validated", function(path, valid, reason) {
              if(path !== currentFolder+name)
                return;
              working = false;
              if(!valid) {
                alert("Invalid report name: " + reason);
                $save.button("enable");
                return;
              }
              currentPath = path;
              ctx.trigger("reports.report.add", currentPath, state);
              ctx.trigger("chart.name.set", name);
            });
            ctx.trigger("request.report.path.validate", currentFolder+name);
          } else {
            $save.button("disable");
            ctx.trigger("reports.report.change", currentPath, state);
          }
        });
        $save.button("enable");
      }

      ctx.on("chart.state.change", state_change);
      ctx.on("reports.report.openpath", open_path);

      ctx.on("chart.state.reset", function() {
        currentPath = null;
        $save.button("disable");
      });
    }

    ctx.on("view.reports.toolbar-context", init_context);
    ctx.on("view.editor.toolbar-context", init_main);
  };
});
define('lib/util/localdownload',[

],
//      window.open("data:Application/octet-stream,"+encodeURIComponent(JSON.stringify(report)));
function() {
  return function(content, filename, contentType) {
    filename = filename || "download";
    contentType = contentType || "application/octet-stream";
    var a = document.createElement("a");
    var blob = new Blob([content], {"type":contentType});
    a.href = window.URL.createObjectURL(blob);
    a.download = filename;
    a.click();
  };
});
define('lib/util/localupload',[
    "jquery"
  , "lib/util/view/editors/fileeditor"
  , "lib/util/ui"
],

function($, createFileEditor, ui) {
  return function(success, title, message, validation, cancel) {
    title = title || "upload file";
    message = message || "please select a file to upload";
    validation = validation || function() { return null; };
    cancel = cancel || function() {};

    // open window
    var $dialog = $('<div><div class="message">'+message+'</div><div class="upload"></div></div>')
          .appendTo("body")
          .dialog({
              title : title
            , modal : true
            , autopen : true
            , resizable : false
            , dialogClass : "rg-el"
            , closeOnEscape: true
            , buttons : [{
                text : "OK",
                click : function() {
                  $dialog.dialog("close");
                  success(editor.value.get());
                  return true;
                },
                ref : "ok"
              }, {
                text : "Cancel",
                click : function() {
                  $dialog.dialog("close");
                  if(cancel)
                    cancel();
                },
                ref : "cancel"
              }]

          }),
        editor = createFileEditor($dialog.find(".upload"), {
          validate : validation
        }),
        $ok = $dialog.dialog("widget").find('button[ref="ok"]').button("disable")
      ;

    editor.value.on("value.validationError", function() {
      editor.el.find(".error").addClass("ui-state-error ui-corner-all");
      $ok.button("disable");
    });
    editor.value.on("value.change", function() {
      $ok.button("enable");
    });
  };
});
define('modules/view/reportsdownloadupload',[
    "jquery"
  , "lib/util/localdownload"
  , "lib/util/localupload"
],

function($, download, upload) {

  return function(ctx) {
    ctx.on("reports.report.export", function(report, path) {
      download(JSON.stringify(report), path.split("/").pop()+".json")
    });

    ctx.on("reports.report.importpath", function(path) {
      upload(
        function(file) {
          // TODO check it works fine for filenames with no extensions
          var name = file.name.split(".").slice(0, -1).join(".");
          var reader = new FileReader();
          reader.onload = function(e) {
            var json = JSON.parse(e.target.result);
            ctx.trigger("reports.report.import", path, name, json);
          };
          reader.readAsBinaryString(file);
        },
        "upload a report",
        "please select a report file",
        function(file) {
          var reader = new FileReader(),
              deferred = new $.Deferred();
          reader.onload = function(e) {
            var content = e.target.result;
            try {
              var json = JSON.parse(content);
              if(!json.chart || "undefined" === typeof json.datasource || !json.dimensions || !json.options) {
                deferred.resolve("the file does not contain the properties required for a report")
              } else {
                deferred.resolve(null);
              }
            } catch(e) {
              deferred.resolve("wrong file format")
            }
          };
          reader.readAsBinaryString(file);
          return deferred;
        });
    });

    ctx.on("reports.report.import", function(opath, name, content) {
      var path = opath;
      if(path.substr(-1) !== "/") path += "/";
      path += name;

      function validated(npath, valid, reason) {
        if(path !== npath) return;
        ctx.off("response.report.path.validated", validated);
        if(valid) {
          ctx.trigger("reports.report.add", path, content);
        } else {
          var result = window.prompt("A report with name '"+name+"' already exists, please try a different name:", name);
          if(result === null) return;
          result = result.trim();
          if(result === "") {
            alert("invalid empty name");
          }
          ctx.trigger("reports.report.import", opath, result, content);
        }
      };

      ctx.on("response.report.path.validated", validated);
      ctx.trigger("request.report.validate", path);
    });
  };
});
define('config/ui',[],

function() {
  return {
    fieldsetGridSnapping : 15
  };
});
define('modules/view/dimensionspane',[
    "jquery"
  , "config/ui"
  , "config/charts"
  , "lib/util/ui"
],

function($, uiconfig, charts, ui) {
  return function(ctx) {
    var el,
        $fields,
        $closer,
        fields,
        fieldsmap,
        axeslist,
        axesmap,
        currentDimensions = {};

    function updateChartType(type) {
      $fields.children("div.pair").remove();
      var chart = charts.map[type];
      dimensionsInfo = {};
      for(var i = 0; i < chart.dimensions.length; i++) {
        appendDimension(chart.dimensions[i]);
      }
      if(fields)
        setTimeout(function() {
          updateFields(fields);
        }, 200);
    }

    function updateFields(fields) {
      if(axeslist) {
        $(axeslist).each(function() {
          var name = this.name;
          if(axesmap[name].$select) {
            axesmap[name].$select.val("");
            axesmap[name].$select.change();
          }
        });
      }
      axesmap = {};
      axeslist = fields.map(function(field) {
        var axis = {
          type : field.type,
          name : field.field,
          $select : null
        };
        axesmap[field.field] = axis;
        return axis;
      });
      fillSelects();
    }

    function updateDataSource(source) {
      fieldsmap = {};
      if(source) {
        fields = source.fields;
        for(var i = 0; i < fields.length; i++) {
          fieldsmap[fields[i].field] = fields[i];
        }
      } else {
        fields = [];
      }
//      var defaultValues = currentDimensions[dimension.name] || [];
      updateFields(fields);
    }

    function fillSelects() {
      $fields.find("select.secondary").remove();
      
      var $select = $fields.find("select");
      $select.find(".value").remove();
      $select.attr("disabled", false);
      fillSelect($select);
    }

    function fillSelect($select) {
      $select.each(function(i) {
        var $current = $(this),
            name  = $current.attr("data-id"),
            pos   = $current.index(),
            value = (currentDimensions[name] || [])[pos];
        $(axeslist).each(function() {
          var $option = $('<option class="value '+this.type+'">'+this.name+'</option>');
          if(value === this.name) {
            $option.attr("selected", true);
            $current.attr("disabled", false);
          }
          $current.append($option);
        });

      });
    }

    function updateSingleSelect($container, dimension) {
      var $principal = $container.find("select.principal");
    }

    function updateMultipleSelect($container, dimension) {

      var $selects   = $container.find('select.secondary'),
          $nonempty  = $selects.filter(function() { return $(this).val() !== ''; }),
          $empty     = $selects.filter(function() { return $(this).val() === ''; }),
          $principal = $container.find("select.principal");

      if($principal.val() === "" && $nonempty.length > 0) {
        var $secondary = $($nonempty.get(0)),
            val = $secondary.val();
        $secondary.val("");
        $principal.val(val);
        return;
      }

      $empty.remove();
      if($nonempty.length + 1 < axeslist.length) {
        createSecondaryDimensionSelector($container, dimension);
      }
    }

    function dimensionInfo(dimension) {
      return {
        optional : dimension.min === 0,
        multiple : dimension.max === null || dimension.max > 1,
        dimension : dimension
      };
    }

    function createSecondaryDimensionSelector($container, dimension) {
      var $select = $('<select class="secondary"></select>').appendTo($container),
          optionality = "optional";
      $select.attr("data-id", dimension.name);
      $select.append('<option value="" class="'+optionality+'">['+optionality+']</option>');
      $select.on("change", createSelectChange($container, $select, true, dimension));

      fillSelect($select);
    }

    function triggerChangeAxis($container, dimension) {
      var types = [];
      $container
        .find("select")
        .filter(function() {
          return $(this).val() !== "";
        })
        .each(function() {
          types.push(fieldsmap[$(this).val()]);
        });
      ctx.off("chart.axis.change", axisChange);
      ctx.trigger("chart.axis.change", types, dimension);
      ctx.on("chart.axis.change", axisChange);
    }

    function createSelectChange($container, $select, multiple, dimension) {
      var lastval;
      return function() {
        var val = $select.val();
        if(lastval && $container.find("select").filter(function() {
          return $select.get(0) !== this && $(this).val() === lastval;
        }).length === 0) {
          axesmap[lastval].$select = null;
        }
        if(val) {
          if(axesmap[val].$select) {
            axesmap[val].$select.val(lastval || "");
            axesmap[val].$select.change();
          }
          axesmap[val].$select = $select;
          if(multiple && $container.find("select.secondary").length + 1 < axeslist.length)
            createSecondaryDimensionSelector($container, dimension);
        }
        lastval = val;
        if(multiple)
          updateMultipleSelect($container, dimension);
        else
          updateSingleSelect($container, dimension);
        triggerChangeAxis($container, dimension);
      };
    }

    function createMainDimensionSelector($container, info) {
      var $select = $('<select class="principal"></select>').appendTo($container),
          optionality = info.optional ? "optional" : "mandatory";
      $select.attr("data-id", info.dimension.name);
      $select.addClass(optionality);
      if(info.multiple)
        $select.addClass("multiple");
      $select.attr("disabled", true);

      $select.append('<option value="" class="'+optionality+'">['+optionality+']</option>');

      $select.on("change", createSelectChange($container, $select, info.multiple, info.dimension));
    }

    function appendDimension(dimension) {
      var $pair = $('<div class="pair ui-widget-header ui-corner-all"></div>');
      $pair.insertBefore($closer);
      var $label = $('<div class="name">'+(dimension.label || dimension.name)+'</div>');
      $pair.append($label);
      var $div = $('<div class="dimension"></div>').appendTo($pair);
      createMainDimensionSelector($div, dimensionInfo(dimension));
    }

    function init(container) {
      el = container;

      $fields = $('<div class="fields"></div>').appendTo(el);
      $closer = $('<div class="clr"></div>').appendTo($fields);

      ctx.on("chart.type.change", updateChartType);
//      ctx.on("chart.dimension.add", appendDimension);
      ctx.on("chart.datasource.change", updateDataSource);
    }

    function axisChange(types, dimension) {
      var t = types.slice(0),
        info = dimensionInfo(dimension);
      function dequeue(rep) {
        if(t.length === 0) return;
        var field = t.shift().field;
        if(axesmap[field]) {
          var select = el.find('select[data-id="'+dimension.name+'"]'),
            $sel = $(select.get(rep));
          $sel.val(field);
          if(info.multiple) // && $sel.parent().find("select.secondary").length + 1 < axeslist.length)
            createSecondaryDimensionSelector($sel.parent(), dimension);
        }
        rep++;
        setTimeout(function() { dequeue(rep + 1); }, 20);
      }

      setTimeout(function() { dequeue(0); }, 20);
      currentDimensions[dimension.name] = types.map(function(v) { return v.field; });
    }

    ctx.on("chart.axis.change", axisChange);

    ctx.on("view.editor.dimensions", init);
  };
});
define('config/optiongroups',[
],

function() {
  return [
      { group : "general",          label : "general" }

    , { group : "axis",             label : "axis" }

    , { group : "barchart",         label : "bar chart" }
    , { group : "funnelchart",      label : "funnel chart" }
    , { group : "heatgrid",         label : "heat grid" }
    , { group : "leaderboard",      label : "leaderboard" }
    , { group : "linechart",        label : "line chart" }
    , { group : "piechart",         label : "pie chart" }
    , { group : "pivottable",       label : "pivot table" }
    , { group : "scattergraph",     label : "scatter graph" }
    , { group : "streamgraph",      label : "stream graph" }
    , { group : "aesthetic",        label : "aesthetic" }

    , { group : "barpadding",       label : "spacing" }
    , { group : "piechartposition", label : "positions" }
    , { group : "displaytotals",    label : "display totals" }
    , { group : "customclasses",    label : "custom classes" }

    , { group : "symbol",           label : "symbols" }
    , { group : "label",            label : "label" }
    , { group : "tickmarks",        label : "tickmarks" }
    , { group : "rules",            label : "rules" }

    , { group : "other",            label : "other" }
  ];
  ;
});
define('modules/view/optionspane',[
    "jquery"
  , "config/ui"
  , "lib/util/ui"
  , "lib/util/view/editors/editors"
  , "config/optiongroups"
],

function($, uiconfig, ui, editors, optiongroups) {

  return function(ctx) {
    var el,
        options = [],
        groups = {},
        defaultGroup;
    function init(container) {
      el = container;

      $(optiongroups).each(function() {
        var $ogroup = $('<fieldset class="ui-widget-content"><div class="group-header ui-widget-content ui-widget-header">'+this.label+'</div><div class="fields"></div></fieldset>').hide();
        el.append($ogroup);
        groups[this.group] = $ogroup;
      });
      defaultGroup = groups[optiongroups[optiongroups.length - 1].group];
      ctx.on("chart.type.change", update);
      ctx.on("chart.option.add", appendOption);
    };

    function update(type) {
      while(options.length > 0) {
        options.pop()();
      }


      el.find('fieldset').hide().find('div.fields').children("*").remove();
    }

    function findRef(container, weight, name) {
      var list = container.find(".option-editor"), t;
      for(var i = 0; i < list.length; i++) {
        var el = $(list[i]);
        t = parseInt(el.attr("data-weight"));
        if(weight < t)
          return el;
        if(weight > t)
          continue;

        t = el.attr("data-name");
        if(name < t)
          return el;
      }
      return null;
    }

    function appendOption(info) {
      var editor,
          index = 0,
          $fieldset = (groups[info.group] || defaultGroup).show(),
          $fields = $fieldset.find(".fields:first"),
          weight = info.weight || 0,
          $ref = findRef($fields, weight, info.name),
          $container = $('<div class="option-editor" data-weight="'+weight+'" data-name="'+info.name+'"></div>'),
          eventName = info.event.split(".").slice(2).join("."),
          current_type,
          menu;

      if($ref) {
        $container.insertBefore($ref);
      } else {
        $fields.append($container);
      }

      if(ctx.debug && !groups[info.group]) {
        console.warn("UNMATCHED GROUP " + info.group + " for " + info.name);
      }

      function ctx_on_handler(v) {
        if(v !== editor.value.get())
          editor.value.set(v);
      }

      function ctx_trigger_handler(v) {
        ctx.trigger(info.event, v);
        if(info.event.substr(0, "options.chart.".length) === "options.chart.")
        {
          ctx.off("chart.option.set", editor_value_set);
          ctx.trigger("chart.option.set", eventName, v, current_type);
          ctx.on("chart.option.set", editor_value_set);
        }
      }

      function editor_value_set(event, v, type) {
        if(event !== eventName) return;
        if(v !== editor.value.get()) {
          var newindex = -1;
          for(var i = 0; i < info.editors.length; i++)
          {
            if(info.editors[i].type === type) {
              newindex = i;
              break;
            }
          }
          if(menu && newindex >= 0 && newindex != index) {
            menu.find("li:eq("+newindex+")").click();
          }
          editor.value.set(v);
        }
      }

      ctx.on("chart.option.set", editor_value_set);

      if(info.editors.length > 1) {
        menu = ui.contextmenu('<div class="rg-widget settings-menu"></div>');
        var $multitrigger = ui.button($container, {
                icon : "ui-icon-gear",
                description : "switch editor",
                className : "swap-option"
              })
              .click(function() {
              var pos = $(this).offset(),
                  h = $(this).outerHeight();
              menu.css({
                position : "absolute",
                top : (pos.top + h) + "px",
                left : pos.left + "px"
              }).show();
            });
        var $ul = menu.find("ul");

        function switch_editor() {
          var newindex = $(this).index();
          if(index === newindex)
            return;
          index = newindex;
          if(editor) {
            // destroy old
            editor.value.off("value.change", ctx_trigger_handler);
            editor.destroy();
            $option.children("*").remove();
          }
          current_type = info.editors[index].type;
          // create new
          editor = editors.create($option, info.editors[index].type, info.editors[index].options);
          editor.value.on("value.change", ctx_trigger_handler);
        }

        for(var i = 0; i < info.editors.length; i++) {
          var ieditor = info.editors[i];
              $li = $('<li class="ui-menu-item" role="presentation"><a href="#">'+(ieditor.label || ieditor.type)+'</a></li>');
          $li.click(switch_editor);
          $ul.append($li);
        }
      }

      var $label = $('<div class="name">'+(("undefined" !== typeof info.label) ? info.label : info.name)+'</div>');
      $container.append($label);
      var $option = $('<div class="option"></div>');
      if(info.className) {
        $container.addClass(info.className);
      }
      $container.append($option);

      editor = editors.create($option, info.editors[index].type, info.editors[index].options);
      editor.value.on("value.change", ctx_trigger_handler);
      current_type = info.editors[index].type;


//      ctx.on(info.event, ctx_on_handler);


      function condition_visible() {
        if(info.condition.visible.apply(info, arguments)) {
          $container.show();
        } else {
          $container.hide();
        }
      }

      if(info.condition) {
        ctx.on(info.condition.event, condition_visible);
        $container.hide();
      }

      options.push(function() {
        if(info.condition) {
          ctx.off(info.condition.event, condition_visible);
        }
        editor.value.off("value.change", ctx_trigger_handler);
//        ctx.off(info.event, ctx_on_handler);
        ctx.off("chart.option.set", editor_value_set);
        editor.destroy();
      });

      $container.append('<div class="clr"></div>');

      setTimeout(function() {
        ctx_trigger_handler(editor.value.get());
      }, 0);
    }

    ctx.on("view.editor.options", init);
  };
});
define('modules/view/chartpane',[
  "jquery",
//  "http://api.reportgrid.com/js/reportgrid-charts.js?authCode=QWWwKQIBDTBblBgGtgUCgQjS4MM%2BR%2B2oSOfdekNAM2xxE0E98ZLtdwaVfrMjShf51Ou3NsUtkv9yvqWH0pbyH0IRc6kvJ7HDZCyA3ObMouvdcyNxmyDS%2FEUcjCIZqxkGrCLcj9w43gMjWBHndW1Pk9429QaRI4voWSvZQMd4boE%3D"
  "http://localhost/rg/js/reportgrid-charts.js?authCode=QWWwKQIBDTBblBgGtgUCgQjS4MM%2BR%2B2oSOfdekNAM2xxE0E98ZLtdwaVfrMjShf51Ou3NsUtkv9yvqWH0pbyH0IRc6kvJ7HDZCyA3ObMouvdcyNxmyDS%2FEUcjCIZqxkGrCLcj9w43gMjWBHndW1Pk9429QaRI4voWSvZQMd4boE%3D"
],

function($) {
  return function(ctx) {
    function init(el) {
      var info,
          timer,
          $chart = $('<div style="margin: 0 auto"></div>').appendTo(el);
//      $(el).css({ width : "600px", height : "400px" });

      function execute(newinfo) {
        info = newinfo;
        delayedRender();
      }

      function delayedRender() {
        clearTimeout(timer);
        timer = setTimeout(render, 500);
      }

      function render() {
        if(!info) return;
        var old = info.options.ready || function() {},
            start;
        info.options.ready = function(){
          var end = +new Date();
          ctx.trigger("chart.render.end", { time : end - start, start : start, end : end });
          old();
        };
        ctx.trigger("chart.render.start", start = +new Date());
        ReportGrid.chart($chart.get(0),  {
            axes    : info.axes,
            load    : info.loader,
            options : info.options
          },
          info.type
        );
      }

      function changeWidth(v) {
        $chart.css("width", v+"px");
        delayedRender();
      }

      function changeHeight(v) {
        $chart.css("height", v+"px");
        delayedRender();
      }

      var loader = $('<div class="loader"><img src="images/loading.gif" alt="loading ..."></div>').appendTo(el).hide();

      function renderStart() {
        loader.show();
      }

      function renderEnd() {
        loader.hide();
      }

      function clear() {
        clearInterval(timer);
        if(ReportGrid.tooltip)
          ReportGrid.tooltip.hide();
        $chart.children("*").remove();
      }
      
      ctx.on("chart.render.execute", execute);
      ctx.on("chart.rgcss.loaded", delayedRender);
      ctx.on("chart.render.clear", clear);
      ctx.on("options.chart.width", changeWidth);
      ctx.on("options.chart.height", changeHeight);

      ctx.on("chart.render.start", renderStart);
      ctx.on("chart.render.end", renderEnd);
    };

    ctx.on("view.editor.chart", init);
  };
});
define('modules/view/changergtheme',[
  "jquery"
],

function($) {

  return function(ctx) {
    var timer, current;
    function poll(callback) {
      clearInterval(timer);
      if($("head").find('link.custom-rg-css').length > 0) {
        setTimeout(callback, 1000);
      } else {
        timer = setTimeout(function() { poll(callback); }, 50);
      }
    }
    function changecharttheme(theme) {
      if(current === theme) return;
      current = theme;
//      $("head").find('link[href="https://api.reportgrid.com/css/rg-charts.css"]').remove();
      $("head").find('link.custom-rg-css').remove();
      $("head").append('<link rel="stylesheet" class="custom-rg-css" href="https://api.reportgrid.com/css/colors/'+theme+'">');
      poll(function() {
        ctx.trigger("chart.rgcss.loaded", theme);
      });
    }
    ctx.on("chart.rgcss.load", changecharttheme);
  }
});
/*global XSLTProcessor: false, ActiveXObject: false, console : false */

/*
File: Helper functions
This file includes some functions that enable CSS manipulations, contextmenus, XSLT transformations and drag'n'drop.
All of those work independently of jstree.
*/

/*
Variable: $.vakata
*object* Holds all helper objects.
*/
(function ($) {
	$.vakata = {};
})(jQuery);

/* 
Group: Miscellaneous
Various small snippets.
*/

/*
Function: $().vakata_reverse
Makes it possible to apply the standard array reverse function to a jQuery collection.

Input:
> <div>1</div><div>2</div><div>3</div>
> $("div").vakata_reverse().each(function () { document.write(this.innerHTML); });

Output: 
>321
*/
(function ($) {
	$.fn.vakata_reverse = [].reverse;
})(jQuery);

(function ($) {
	jQuery.expr[':'].vakata_icontains = function(a,i,m){
		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;
	};
})(jQuery);

/*
Function: $.vakata.array_remove
Makes it possible to remove an item (or a group of items) form an array.
http://ejohn.org/blog/javascript-array-remove/

Input:
> $.vakata.array_remove(['a', 'b', 'c'], 1);

Output: 
>['a', 'c']
*/
(function ($) {
	$.vakata.array_remove = function(array, from, to) {
		var rest = array.slice((to || from) + 1 || array.length);
		array.length = from < 0 ? array.length + from : from;
		array.push.apply(array, rest);
		return array;
	};
})(jQuery);

/*
Function: $.vakata.array_unique
Returns only the unique items from an array.

Input:
> $.vakata.array_unique(['c','a','a','b','c','b']);

Output: 
>['a', 'b', 'c']
*/
(function ($) {
	$.vakata.array_unique = function(array) {
		var a = [], i, j, l;
		for(i = 0, l = array.length; i < l; i++) {
			for(j = 0; j <= i; j++) {
				if(array[i] === array[j]) {
					break;
				}
			}
			if(j === i) { a.push(array[i]); }
		}
		return a;
	};
})(jQuery);

/*
Function: $.vakata.attributes
Collects all attributes from a DOM node.
*/
(function ($) {
	$.vakata.attributes = function(node, with_values) {
		node = $(node)[0];
		var attr = with_values ? {} : [];
		$.each(node.attributes, function (i, v) { 
			if($.inArray(v.nodeName.toLowerCase(),['style','contenteditable','hasfocus','tabindex']) !== -1) { return; }
			if(v.nodeValue !== null && $.trim(v.nodeValue) !== '') { 
				if(with_values) { attr[v.nodeName] = v.nodeValue; }
				else { attr.push(v.nodeName); }
			}
		});
		return attr;
	};
})(jQuery);

/*
Function: $.vakata.get_scrollbar_width
Gets the width of the scrollbar
*/
(function ($) {
	var sb;
	$.vakata.get_scrollbar_width = function () {
		var e1, e2;
		if(!sb) { 
			if(/msie/.test(navigator.userAgent.toLowerCase())) {
				e1 = $('<textarea cols="10" rows="2"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
				e2 = $('<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>').css({ position: 'absolute', top: -1000, left: 0 }).appendTo('body');
				sb = e1.width() - e2.width();
				e1.add(e2).remove();
			} 
			else {
				e1 = $('<div />').css({ width: 100, height: 100, overflow: 'auto', position: 'absolute', top: -1000, left: 0 })
						.prependTo('body').append('<div />').find('div').css({ width: '100%', height: 200 });
				sb = 100 - e1.width();
				e1.parent().remove();
			}
		}
		return sb;
	};
})(jQuery);

/* 
Group: CSS
Functions needed to manipulate stylesheets (add, remove, change)
*/
(function ($) {
	/* 
		Variable: $.vakata.css
		*object* holds all CSS related functions
	*/
	$.vakata.css = {
		/* 
			Function: $.vakata.css.get_css
			Retrieves or deletes a specific rule.

			Parameters:
				rule_name - *string* the rule to search for (any CSS rule)
				delete_flag - *boolean* whether you want to delete or simply retrieve a reference to the rule
				sheet - the sheet to search in (do not specify this to search in all sheets)
			
			Returns either:
				a reference to the rule - if it was found and the delete flag was not set
				true - if the delete flag was set and the rule was successfully removed
				false - if the rule could not be found

			See also:
				<$.vakata.css.remove_css>
		*/
		get_css : function(rule_name, delete_flag, sheet) {
			rule_name = rule_name.toLowerCase();
			var css_rules = sheet.cssRules || sheet.rules,
				j = 0;
			do {
				if(css_rules.length && j > css_rules.length + 5) { return false; }
				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() === rule_name) {
					if(delete_flag === true) {
						if(sheet.removeRule) { sheet.removeRule(j); }
						if(sheet.deleteRule) { sheet.deleteRule(j); }
						return true;
					}
					else { return css_rules[j]; }
				}
			}
			while (css_rules[++j]);
			return false;
		},
		/* 
			Function: $.vakata.css.add_css
			Adds a rule.

			Parameters:
				rule_name - *string* the rule to add
				sheet - a reference to the sheet to add to
			
			Returns either:
				a reference to the rule - if the rule was added
				false - if the rule could not be added, or if such a rule already exists
		*/
		add_css : function(rule_name, sheet) {
			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }
			if(sheet.insertRule) { sheet.insertRule(rule_name + ' { }', 0); } else { sheet.addRule(rule_name, null, 0); }
			return $.vakata.css.get_css(rule_name);
		},
		/* 
			Function: $.vakata.css.remove_css
			Removes a rule, this functions is a shortcut to <$.vakata.css.get_css> with the delete flag set to true.

			Parameters:
				rule_name - *string* the rule to remove
				sheet - the sheet to remove from (you can omit this and all sheets will be searched)
			
			Returns either:
				true - if rule was removed
				false - if the rule could not be removed

			See also:
				<$.vakata.css.get_css>
		*/
		remove_css : function(rule_name, sheet) { 
			return $.vakata.css.get_css(rule_name, true, sheet); 
		},
		/* 
			Function: $.vakata.css.add_sheet
			Adds a whole stylesheet or appends to an existing stylesheet.

			Parameters:
				options - *object*:
				options.url - location of the stylesheet - when this is supplied _options.str_ and _options.title_ should not be set and a new LINK element is always created
				options.str - text content of the stylesheet - when this is supplied _options.url_ is not used. A STYLE element is used.
				options.title - the ID of the added stylesheet (if you pass `foo` the ID will be `foo-stylesheet`), when the stylesheet exists the content is appended and no new stylesheet is created.
			
			Returns: 
				a reference to the stylesheet
		*/
		add_sheet : function(opts) {
			var tmp = false, is_new = true;
			if(opts.str) {
				if(opts.title) { tmp = $("style[id='" + opts.title + "-stylesheet']")[0]; }
				if(tmp) { is_new = false; }
				else {
					tmp = document.createElement("style");
					tmp.setAttribute('type',"text/css");
					if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }
				}
				if(tmp.styleSheet) {
					if(is_new) { 
						document.getElementsByTagName("head")[0].appendChild(tmp); 
						tmp.styleSheet.cssText = opts.str; 
					}
					else {
						tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; 
					}
				}
				else {
					tmp.appendChild(document.createTextNode(opts.str));
					document.getElementsByTagName("head")[0].appendChild(tmp);
				}
				return tmp.sheet || tmp.styleSheet;
			}
			if(opts.url) {
				if(document.createStyleSheet) {
					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }
				}
				else {
					tmp			= document.createElement('link');
					tmp.rel		= 'stylesheet';
					tmp.type	= 'text/css';
					tmp.media	= "all";
					tmp.href	= opts.url;
					document.getElementsByTagName("head")[0].appendChild(tmp);
					return tmp.styleSheet;
				}
			}
		}
	};
})(jQuery);

/* 
Group: Drag'n'drop
Functions needed to drag'n'drop elements
*/
(function ($) {
	// private variable
	var vakata_dnd = {
		element	: false,
		is_down	: false,
		is_drag	: false,
		helper	: false,
		helper_w: 0,
		data	: false,
		init_x	: 0,
		init_y	: 0,
		scroll_l: 0,
		scroll_t: 0,
		scroll_e: false,
		scroll_i: false
	};
	/* 
		Variable: $.vakata.dnd
		*object* holds all DND related functions
	*/
	$.vakata.dnd = {
		/* 
			Variable: $.vakata.dnd.settings
			*object* holds the global settings object for DND. You can easily modify any of the settings.
			>// modification example
			>$.vakata.dnd.settings.threshold = 10;
		*/
		settings : {
			/* 
				Variable: $.vakata.dnd.settings.scroll_speed
				*integer* how fast (pixel count for each step) should a scrollable parent scroll when dragging near the edge. Default is _10_.
			*/
			scroll_speed		: 10,
			/* 
				Variable: $.vakata.dnd.settings.scroll_proximity
				*integer* number of pixels from the edge of a scrollable parent below which the parent will start scrolling. Default is _20_.
			*/
			scroll_proximity	: 20,
			/* 
				Variable: $.vakata.dnd.settings.helper_left
				*integer* number of pixels left of the cursor to move the drag-helper to. Default is _5_;
			*/
			helper_left			: 5,
			/* 
				Variable: $.vakata.dnd.settings.helper_top
				*integer* number of pixels below the cursor to move the drag-helper to. Default is _10_.
			*/
			helper_top			: 10,
			/* 
				Variable: $.vakata.dnd.settings.threshold
				*integer* amount of pixels required to move before the drag is started. Default is _5_.
			*/
			threshold			: 5
		},
		/* 
			Function: $.vakata.dnd._trigger
			Used internally to trigger all necessary events.
		*/
		_trigger : function (event_name, e) {
			var data = $.vakata.dnd._get();
			data.event = e;
			$(document).triggerHandler("dnd_" + event_name + ".vakata", data);
		},
		/* 
			Function: $.vakata.dnd._get
			Used internally to get all items for the drag event. Can be used by foreign code too.
		*/
		_get : function () {
			return { 
				"data"		: vakata_dnd.data,
				"element"	: vakata_dnd.element,
				"helper"	: vakata_dnd.helper
			};
		},
		/* 
			Function: $.vakata.dnd._clean
			Used internally to cleanup after a drop, so that all variables are nulled and ready for the next drag.
		*/
		_clean : function () {
			if(vakata_dnd.helper) { vakata_dnd.helper.remove(); }
			if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
			vakata_dnd = {
				element	: false,
				is_down	: false,
				is_drag	: false,
				helper	: false,
				helper_w: 0,
				data	: false,
				init_x	: 0,
				init_y	: 0,
				scroll_l: 0,
				scroll_t: 0,
				scroll_e: false,
				scroll_i: false
			};
			$(document).unbind("mousemove",	$.vakata.dnd.drag);
			$(document).unbind("mouseup",	$.vakata.dnd.stop);
		},
		/* 
			Function: $.vakata.dnd._scroll
			Used internally to scroll hovered elements.

			Triggers:
			<dnd_scroll>

			Event: dnd_scroll
			Fires when a container is scrolled due to dragging near its edge. Triggered on the document, the event is fired in the *vakata* namespace.

			Parameters:
				data.event - the scrolled element
				data.data - the data you supplied when calling <$.vakata.dnd.start>
				data.element - the origin element
				data.helper - the jquery extended drag-helper node (or false if it is not used)

			Example:
			>$(document).bind("dnd_start.vakata", function (e, data) {
			>	// do something
			>});
		*/
		_scroll : function (init_only) {
			if(!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
				if(vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
				return false; 
			}
			if(!vakata_dnd.scroll_i) { 
				vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100); 
				return false;
			}
			if(init_only === true) { return false; }

			var i = vakata_dnd.scroll_e.scrollTop(), 
				j = vakata_dnd.scroll_e.scrollLeft();
			vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
			vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
			if(i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
				$.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
			}
		},
		/* 
			Function: $.vakata.dnd.start
			Use this function to start a drag (usually with the mousedown event)

			Parameters:
				event - *event* the event which started the drag, when used with the mousedown event text selection is prevented
				data - *mixed* some custom data you want to bind with that particular drag - you will receive this in all events
				html - *mixed* the text for the drag-helper as a *string*, if set to _false_ no helper is shown

			Returns: 
				false

			Example:
			>$("span").bind("mousedown", function (e) {
			>	return $.vakata.dnd.start(e, {}, "Dragging");
			>});
		*/
		start : function (e, data, html) { 
			if(vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
			try {
				e.currentTarget.unselectable = "on";
				e.currentTarget.onselectstart = function() { return false; };
				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }
			} catch(err) { }
			vakata_dnd.init_x	= e.pageX;
			vakata_dnd.init_y	= e.pageY;
			vakata_dnd.data		= data;
			vakata_dnd.is_down	= true;
			vakata_dnd.element	= e.currentTarget;
			if(html !== false) {
				vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
					"display"		: "block", 
					"margin"		: "0",
					"padding"		: "0",
					"position"		: "absolute",
					"top"			: "-2000px",
					"lineHeight"	: "16px",
					"zIndex"		: "10000"
				});
			}
			$(document).bind("mousemove", $.vakata.dnd.drag);
			$(document).bind("mouseup", $.vakata.dnd.stop);
			return false;
		},
		/* 
			Function: $.vakata.dnd.drag
			Used internally to process the mousemove event after <$.vakata.dnd.start> is called.

			Parameters:
				event - *event* the mousemove event

			Triggers:
			<dnd_start>, <dnd_move>
		*/
		drag : function (e) { 
			if(!vakata_dnd.is_down) { return; }
			if(!vakata_dnd.is_drag) {
				if(
					Math.abs(e.pageX - vakata_dnd.init_x) > $.vakata.dnd.settings.threshold || 
					Math.abs(e.pageY - vakata_dnd.init_y) > $.vakata.dnd.settings.threshold
				) { 
					if(vakata_dnd.helper) {
						vakata_dnd.helper.appendTo("body");
						vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
					}
					vakata_dnd.is_drag = true;
					/*
						Event: dnd_start
						Marks the start of the drag. Triggered on the document after a drag is initiated using <$.vakata.dnd.start> and the user has moved more than <$.vakata.dnd.settings.threshold> pixels, the event is fired in the *vakata* namespace.

						Parameters:
							data.event - the mousemove event
							data.data - the data you supplied when calling <$.vakata.dnd.start>
							data.element - the origin element
							data.helper - the jquery extended drag-helper node (or false if it is not used)

						Example:
						>$(document).bind("dnd_start.vakata", function (e, data) {
						>	// do something
						>});
					*/
					$.vakata.dnd._trigger("start", e);
				}
				else { return; }
			}

			var d  = false, w  = false,
				dh = false, wh = false,
				dw = false, ww = false,
				dt = false, dl = false,
				ht = false, hl = false;

			vakata_dnd.scroll_t = 0;
			vakata_dnd.scroll_l = 0;
			vakata_dnd.scroll_e = false;
			var p = $(e.target)
				.parentsUntil("body").andSelf().vakata_reverse()
				.filter(function () { 
					return	(/^auto|scroll$/).test($(this).css("overflow")) && 
							(this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth); 
				})
				.each(function () {
					var t = $(this), o = t.offset();
					if(this.scrollHeight > this.offsetHeight) {
						if(o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
						if(e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_t = -1; }
					}
					if(this.scrollWidth > this.offsetWidth) {
						if(o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
						if(e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity)				{ vakata_dnd.scroll_l = -1; }
					}
					if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) { 
						vakata_dnd.scroll_e = $(this);
						return false; 
					}
				});

			if(!vakata_dnd.scroll_e) {
				d  = $(document); w = $(window);
				dh = d.height(); wh = w.height();
				dw = d.width(); ww = w.width();
				dt = d.scrollTop(); dl = d.scrollLeft();
				if(dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_t = -1;  }
				if(dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_t = 1; }
				if(dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity)		{ vakata_dnd.scroll_l = -1; }
				if(dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity)	{ vakata_dnd.scroll_l = 1; }
				if(vakata_dnd.scroll_t || vakata_dnd.scroll_l) { 
					vakata_dnd.scroll_e = d;
				}
			}
			if(vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

			if(vakata_dnd.helper) {
				ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
				hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
				if(dh && ht + 25 > dh) { ht = dh - 50; }
				if(dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
				vakata_dnd.helper.css({ 
					left	: hl + "px", 
					top		: ht + "px" 
				});
			}
			/*
				Event: dnd_move
				Triggered multiple times while dragging. This event is triggered on the document after the <dnd_start> event when the user moves the mouse, the event is fired in the *vakata* namespace.

				Parameters:
					data.event - the mousemove event
					data.data - the data you supplied when calling <$.vakata.dnd.start>
					data.element - the origin element
					data.helper - the jquery extended drag-helper node (or false if it is not used)

				Example:
				>$(document).bind("dnd_move.vakata", function (e, data) {
				>	// do something
				>});
			*/
			$.vakata.dnd._trigger("move", e);
		},
		/*
			Function: $.vakata.dnd.stop
			Used internally to process the mouseup event (drop) after <$.vakata.dnd.start> is called.

			Parameters:
				event - *event* the mouseup event

			Triggers:
			<dnd_stop>
		*/
		stop : function (e) {
			/* 
				Event: dnd_stop
				Marks the end of the drag. This event is triggered on the document after <dnd_start> (and possibly <dnd_move>) when a drop (mouseup) occurs or when the drag is programatically terminated, the event is fired in the *vakata* namespace.

				Parameters:
					data.event - the mouseup event (or _null_ if stopped programatically using <$.vakata.dnd.stop>())
					data.data - the data you supplied when calling <$.vakata.dnd.start>
					data.element - the origin element
					data.helper - the jquery extended drag-helper node (or false if it is not used)

				Example:
				>$(document).bind("dnd_stop.vakata", function (e, data) {
				>	// do something
				>});
			*/
			if(vakata_dnd.is_drag) {
				$.vakata.dnd._trigger("stop", e);
			}
			$.vakata.dnd._clean();
		}
	};
})(jQuery);

/* 
Group: XSLT
A function used to do XSLT transformations.
*/
(function ($) {
	/*
		Function: $.vakata.xslt
		This functions transforms a XML string using a XSL string. The result is passed to a callback function.

		Parameters:
			xml - *string* the source xml string
			xsl - *string* the xsl string

		Returns:
			the transformed result (or _false_ on failure)

		Example:
		>// simple
		>$.vakata.xslt("<xml-string-here>", "<xsl-string-here>", function (res) { $("#some-container").append(res); });
		>// with scope
		>$.vakata.xslt("<xml-string-here>", "<xsl-string-here>", $.proxy(function (res) { 
		>	this.some_process(res); 
		>}, some_object);
	*/
	$.vakata.xslt = function (xml, xsl) {
		var r = false, p, q, s;
		// IE9
		if(r === false && window.ActiveXObject) {
			try {
				r = new ActiveXObject("Msxml2.XSLTemplate");
				q = new ActiveXObject("Msxml2.DOMDocument");
				q.loadXML(xml);
				s = new ActiveXObject("Msxml2.FreeThreadedDOMDocument");
				s.loadXML(xsl);
				r.stylesheet = s;
				p = r.createProcessor();
				p.input = q;
				p.transform();
				r = p.output;
			}
			catch (e) { }
		}
		xml = $.parseXML(xml);
		xsl = $.parseXML(xsl);
		// FF, Chrome
		if(r === false && typeof (XSLTProcessor) !== "undefined") {
			p = new XSLTProcessor();
			p.importStylesheet(xsl);
			r = p.transformToFragment(xml, document);
			r = $('<div />').append(r).html();
		}
		// OLD IE
		if(r === false && typeof (xml.transformNode) !== "undefined") {
			r = xml.transformNode(xsl);
		}
		return r;
	};
})(jQuery);

/* 
Group: Hotkeys
Copy of the John Resig's fork of http://github.com/tzuryby/hotkeys for consistency
*/
if(typeof jQuery.hotkeys === "undefined") { 
	(function ($) {
			$.vakata_hotkeys = {
				version: "0.8",

				specialKeys: {
					8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause",
					20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home",
					37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del", 
					96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7",
					104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111 : "/", 
					112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 
					120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta"
				},
			
				shiftNums: {
					"`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", 
					"8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": "\"", ",": "<", 
					".": ">",  "/": "?",  "\\": "|"
				}
			};

			function keyHandler( handleObj ) {
				// Only care when a possible input has been specified
				if ( typeof handleObj.data !== "string" ) {
					return;
				}
				
				var origHandler = handleObj.handler,
					keys = handleObj.data.toLowerCase().split(" ");
			
				handleObj.handler = function( event ) {
					// Don't fire in text-accepting inputs that we didn't directly bind to
					if ( this !== event.target && (/textarea|select/i.test( event.target.nodeName ) ||
						event.target.type === "text") ) {
						return;
					}
					
					// Keypress represents characters, not special keys
					var special = event.type !== "keypress" && jQuery.vakata_hotkeys.specialKeys[ event.which ],
						character = String.fromCharCode( event.which ).toLowerCase(),
						key, modif = "", possible = {};

					// check combinations (alt|ctrl|shift+anything)
					if ( event.altKey && special !== "alt" ) {
						modif += "alt+";
					}

					if ( event.ctrlKey && special !== "ctrl" ) {
						modif += "ctrl+";
					}
					
					// TODO: Need to make sure this works consistently across platforms
					if ( event.metaKey && !event.ctrlKey && special !== "meta" ) {
						modif += "meta+";
					}

					if ( event.shiftKey && special !== "shift" ) {
						modif += "shift+";
					}

					if ( special ) {
						possible[ modif + special ] = true;

					} else {
						possible[ modif + character ] = true;
						possible[ modif + jQuery.vakata_hotkeys.shiftNums[ character ] ] = true;

						// "$" can be triggered as "Shift+4" or "Shift+$" or just "$"
						if ( modif === "shift+" ) {
							possible[ jQuery.vakata_hotkeys.shiftNums[ character ] ] = true;
						}
					}

					for ( var i = 0, l = keys.length; i < l; i++ ) {
						if ( possible[ keys[i] ] ) {
							return origHandler.apply( this, arguments );
						}
					}
				};
			}

			jQuery.each([ "keydown", "keyup", "keypress" ], function() {
				jQuery.event.special[ this ] = { add: keyHandler };
			});
	})(jQuery);
}

/* 
Group: Context menu
Functions needed to show a custom context menu.
*/
(function ($) {
	var right_to_left = false, 
		vakata_context = {
			element		: false,
			reference	: false,
			position_x	: 0,
			position_y	: 0,
			items		: [],
			html		: "",
			is_visible	: false
		};
	/* 
		Variable: $.vakata.context
		*object* holds all context menu related functions and variables.
	*/
	$.vakata.context = {
		/* 
			Variable: $.vakata.context.settings
			*object* holds the global settings object for context menus. You can easily modify any of the settings.
			>// modification example
			>$.vakata.context.settings.icons = false;
		*/
		settings : {
			/* 
				Variable: $.vakata.context.settings.hide_onmouseleave
				*integer* the amount of milliseconds to wait before hiding the menu after mouseleave. If set to _0_ the menu won't hide on mouseleave. Default is _0_.
			*/
			hide_onmouseleave	: 0,
			/* 
				Variable: $.vakata.context.settings.icons
				*boolean* whether to show icons or not. Default is _true_.
			*/
			icons				: true
		},
		/* 
			Function: $.vakata.context._trigger
			Used internally to trigger all necessary events.
		*/
		_trigger : function (event_name) {
			$(document).triggerHandler("context_" + event_name + ".vakata", { 
				"reference"	: vakata_context.reference,
				"element"	: vakata_context.element,
				"position"	: { 
					"x" : vakata_context.position_x,
					"y" : vakata_context.position_y
				}
			});
		},
		/* 
			Function: $.vakata.context._execute
			Used internally to execute the action (if any) associated with an item.

			Parameters:
				i - the item's internal index
		*/
		_execute : function (i) {
			i = vakata_context.items[i];
			return i && !i._disabled && i.action ? i.action.call(null, {
						"item"		: i,
						"reference"	: vakata_context.reference,
						"element"	: vakata_context.element,
						"position"	: { 
							"x" : vakata_context.position_x,
							"y" : vakata_context.position_y
						}
					}) : false;
		}, 
		/* 
			Function: $.vakata.context._parse
			Used internally to parse a contextmenu description object to an HTML string.

			Parameters:
				o - *object* the contextmenu description object
				is_callback - *boolean* used internally to indicate a recursive call
			
			Triggers:
			<context_parse>
		*/
		_parse : function (o, is_callback) {
			if(!o) { return false; }
			if(!is_callback) {
				vakata_context.html		= "";
				vakata_context.items	= [];
			}
			var str = "",
				sep = false,
				tmp;

			if(is_callback) { str += "<ul>"; }
			$.each(o, function (i, val) {
				if(!val) { return true; }
				vakata_context.items.push(val);
				if(!sep && val.separator_before) {
					str += "<li class='vakata-context-separator'><a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;</a></li>";
				}
				sep = false;
				str += "<li class='" + (val._class || "") + (val._disabled ? " vakata-contextmenu-disabled " : "") + "'>";
				str += "<a href='#' rel='" + (vakata_context.items.length - 1) + "'>";
				if($.vakata.context.settings.icons) {
					str += "<ins ";
					if(val.icon) {
						if(val.icon.indexOf("/") !== -1)	{ str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
						else								{ str += " class='" + val.icon + "' "; }
					}
					str += ">&#160;</ins><span>&#160;</span>";
				}
				str += val.label + "</a>";
				if(val.submenu) {
					tmp = $.vakata.context._parse(val.submenu, true);
					if(tmp) { str += tmp; }
				}
				str += "</li>";
				if(val.separator_after) {
					str += "<li class='vakata-context-separator'><a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;</a></li>";
					sep = true;
				}
			});
			str  = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/,"");
			if(is_callback) { str += "</ul>"; }
			/*
				Event: context_parse
				Triggered when the context menu is parsed but not yet shown. This event is triggered on the document in the *vakata* namespace.

				Parameters:
					reference - the DOM node used when <$.vakata.context.show> was called
					element - the DOM node of the context menu (not yet populated and shown)
					position - an object consisting of _x_ and _y_ keys, represinting the position of the menu (not yet shown)

				Example:
				>$(document).bind("context_parse.vakata", function (e, data) {
				>	// do something
				>});
			*/
			if(!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
			return str.length > 10 ? str : false;
		},
		/* 
			Function: $.vakata.context._show_submenu
			Used internally to show a submenu
		*/
		_show_submenu : function (o) {
			o = $(o);
			if(!o.length || !o.children("ul").length) { return; }
			var e = o.children("ul"),
				x = o.offset().left + o.outerWidth(),
				y = o.offset().top,
				w = e.width(),
				h = e.height(),
				dw = $(document).width(),
				dh = $(document).height();
			// може да се спести е една проверка - дали няма някой от класовете вече нагоре
			if(right_to_left) {
				o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
			}
			else {
				o[x + w + 10 > dw ? "addClass" : "removeClass"]("vakata-context-right");
			}
			if(y + h + 10 > dh) {
				e.css("bottom","-1px");
			}
			e.show();
		},

		/* 
			Function: $.vakata.context.show
			Shows the context menu. Please note that at least one of _reference_ or _position_ should be specified.

			Parameters:
				reference - *jquery* associate the menu with a DOM element (optional)
				position - *object* should contain _x_ and _y_ properties, those are the coordinates to show the menu at (optional
				data - *object* the contextmenu description object. It should consist of keys, each key should be a <context_menu_item>. If not specified the function will search for $(reference).data('vakata_contextmenu') and use that.

			Triggers:
			<context_show>

			Example:
			>$(document).bind("contextmenu", function (e) {
			>	e.preventDefault();
			>	$.vakata.context.show(false, { x: e.pageX, y:e.pageY }, {
			>		"create" : {
			>			// only specify what you need
			>			"separator_after"	: true,
			>			"label"				: "Create",
			>			"action"			: function (data) { alert("Create"); }
			>		},
			>		"rename" : {
			>			"label"		: "Rename",
			>			"icon"		: "./some-icon.png",
			>			"action"	: function (data) { alert("Rename on " + data.reference); }
			>		},
			>		"edit" : {
			>			"label"	: "Edit", 
			>			// Clicking this won't hide the menu, the same can be achieved with:
			>			// "action" : function () { return false; }
			>			"submenu" : {
			>				"copy"	: { "label" : "Copy", "action" : function () { } },
			>				"cut"	: { "label" : "Cut", "action" : function () { } },
			>				"paste"	: { "label" : "Paste", "_disabled" : true, "action" : function () { } }
			>			}
			>		},
			>		"delete" : {
			>			"separator_before"	: true,
			>			"label"				: "Delete",
			>			"action"			: function (data) { alert("Delete"); }
			>		}
			>	});
			>});

			Variable: context_menu_item
			*object* Used to construct a context menu entry, this structure will always be a part of an object.

				separator_before - *boolean* should there be a separator before the item. Default is _false_.
				separator_after - *boolean* should there be a separator after the item. Default is _false_.
				icon - *string* if supplied this string is used for an icon, if it contains _/_ it is treated as file, otherwise it is applied as a class on an INS object.
				label - *string* the text for this item
				submenu - *object* if supplied this object is used to build a submenu. It should consist of keys, each of which is a <context_menu_item>.
				_class - *string* if supplied this class is applied to the LI node.
				_disabled - *boolean* is this item disabled.
				action - *functon* if supplied it will be executed when this item is clicked / activated. If not supplied or the function returns _false_ the contextmenu won't be hidden after execution. To force a context use _$.proxy_.
				In the function you will receive a single argument which is an object, consisting of four keys:
				_item_ (the <context_menu_item> object), 
				_reference_ (the DOM node used when <$.vakata.context.show> was called), 
				_element_ (the DOM node of the context menu),
				_position_ (an object consisting of _x_ and _y_ keys, represinting the current position of the menu)

			See also: 
				<$.vakata.context.show>
		*/
		show : function (reference, position, data) { 
			if(vakata_context.element && vakata_context.element.length) {
				vakata_context.element.width('');
			}
			switch(!0) {
				case (!position && !reference):
					return false;
				case (!!position && !!reference):
					vakata_context.reference	= reference;
					vakata_context.position_x	= position.x;
					vakata_context.position_y	= position.y;
					break;
				case (!position && !!reference):
					vakata_context.reference	= reference;
					var o = reference.offset();
					vakata_context.position_x	= o.left + reference.outerHeight();
					vakata_context.position_y	= o.top;
					break;
				case (!!position && !reference):
					vakata_context.position_x	= position.x;
					vakata_context.position_y	= position.y;
					break;
			}
			if(!!reference && !data && $(reference).data('vakata_contextmenu')) {
				data = $(reference).data('vakata_contextmenu');
			}
			if($.vakata.context._parse(data)) {
				vakata_context.element.html(vakata_context.html);
			}
			if(vakata_context.items.length) {
				var e = vakata_context.element,
					x = vakata_context.position_x,
					y = vakata_context.position_y,
					w = e.width(),
					h = e.height(),
					dw = $(document).width(),
					dh = $(document).height();

				if(x + w + 20 > dw) {
					x = dw - (w + 20);
				}
				if(y + h + 20 > dh) {
					y = dh - (h + 20);
				}

				vakata_context.element
					.css({ "left" : x, "top" : y })
					.show()
					.width(vakata_context.element.outerWidth()); // for ie6
				vakata_context.is_visible = true;
				/*
					Event: context_show
					Triggered when the context menu is shown. This event is triggered on the document in the *vakata* namespace.

					Parameters:
						reference - the DOM node used when <$.vakata.context.show> was called
						element - the DOM node of the context menu
						position - an object consisting of _x_ and _y_ keys, represinting the position of the menu

					Example:
					>$(document).bind("context_show.vakata", function (e, data) {
					>	// do something
					>});
				*/
				$.vakata.context._trigger("show");
			}
		},
		/* 
			Function: $.vakata.context.hide
			Used internally to hide the contextmenu after a click, or on mouseleave, etc.

			Triggers:
			<context_hide>
		*/
		hide : function () { 
			if(vakata_context.is_visible) {
				vakata_context.element.hide().find("ul").hide();
				vakata_context.is_visible = false;
				/*
					Event: context_hide
					Triggered when the context menu is hidden. This event is triggered on the document in the *vakata* namespace.

					Parameters:
						reference - the DOM node used when <$.vakata.context.show> was called
						element - the DOM node of the context menu
						position - an object consisting of _x_ and _y_ keys, represinting the position of the menu

					Example:
					>$(document).bind("context_hide.vakata", function (e, data) {
					>	// do something
					>});
				*/
				$.vakata.context._trigger("hide");
			}
		}
	};
	$(function () {
		right_to_left = $("body").css("direction") === "rtl";
		var to			= false,
			css_string	= '' + 
			'.vakata-context { display:none; _width:1px; } ' + 
			'.vakata-context, ' + 
			'.vakata-context ul { margin:0; padding:2px; position:absolute; background:#f5f5f5; border:1px solid #979797; ' + 
			'	-moz-box-shadow:5px 5px 4px -4px #666666; -webkit-box-shadow:2px 2px 2px #999999; box-shadow:2px 2px 2px #999999; }'  + 
			'.vakata-context ul { list-style:none; left:100%; margin-top:-2.7em; margin-left:-4px; } ' + 
			'.vakata-context li.vakata-context-right ul { left:auto; right:100%; margin-left:auto; margin-right:-4px; } ' + 
			'.vakata-context li { list-style:none; display:inline; }' + 
			'.vakata-context li a { display:block; padding:0 2em 0 2em; text-decoration:none; width:auto; color:black; white-space:nowrap; line-height:2.4em; ' + 
			'	-moz-text-shadow:1px 1px 0px white; -webkit-text-shadow:1px 1px 0px white; text-shadow:1px 1px 0px white; ' + 
			'	-moz-border-radius:1px; -webkit-border-radius:1px; border-radius:1px; }' + 
			'.vakata-context li a:hover { position:relative; background-color:#e8eff7; ' + 
			'	-moz-box-shadow:0px 0px 2px #0a6aa1; -webkit-box-shadow:0px 0px 2px #0a6aa1; box-shadow:0px 0px 2px #0a6aa1; }' + 
			'.vakata-context li.vakata-context-hover > a { position:relative; background-color:#e8eff7; ' + 
			'	-moz-box-shadow:0px 0px 2px #0a6aa1; -webkit-box-shadow:0px 0px 2px #0a6aa1; box-shadow:0px 0px 2px #0a6aa1; }' + 
			'.vakata-context li a.vakata-context-parent { background-image:url("data:image/gif;base64,R0lGODlhCwAHAIAAACgoKP///yH5BAEAAAEALAAAAAALAAcAAAIORI4JlrqN1oMSnmmZDQUAOw=="); background-position:right center; background-repeat:no-repeat; } ' + 
			'.vakata-context li.vakata-context-separator a, ' + 
			'.vakata-context li.vakata-context-separator a:hover { background:white; border:0; border-top:1px solid #e2e3e3; height:1px; min-height:1px; max-height:1px; padding:0; margin:0 0 0 2.4em; border-left:1px solid #e0e0e0; _overflow:hidden; ' + 
			'	-moz-text-shadow:0 0 0 transparent; -webkit-text-shadow:0 0 0 transparent; text-shadow:0 0 0 transparent; ' + 
			'	-moz-box-shadow:0 0 0 transparent; -webkit-box-shadow:0 0 0 transparent; box-shadow:0 0 0 transparent; ' + 
			'	-moz-border-radius:0; -webkit-border-radius:0; border-radius:0; }' + 
			'.vakata-context li.vakata-contextmenu-disabled a, .vakata-context li.vakata-contextmenu-disabled a:hover { color:silver; background-color:transparent; border:0; box-shadow:0 0 0; }' +
			'' + 
			'.vakata-context li a ins { text-decoration:none; display:inline-block; width:2.4em; height:2.4em; background:transparent; margin:0 0 0 -2em; } ' + 
			'.vakata-context li a span { display:inline-block; width:1px; height:2.4em; background:white; margin:0 0.5em 0 0; border-left:1px solid #e2e3e3; _overflow:hidden; } ' + 
			'' + 
			'.vakata-context-rtl ul { left:auto; right:100%; margin-left:auto; margin-right:-4px; } ' + 
			'.vakata-context-rtl li a.vakata-context-parent { background-image:url("data:image/gif;base64,R0lGODlhCwAHAIAAACgoKP///yH5BAEAAAEALAAAAAALAAcAAAINjI+AC7rWHIsPtmoxLAA7"); background-position:left center; background-repeat:no-repeat; } ' + 
			'.vakata-context-rtl li.vakata-context-separator a { margin:0 2.4em 0 0; border-left:0; border-right:1px solid #e2e3e3;} ' + 
			'.vakata-context-rtl li.vakata-context-left ul { right:auto; left:100%; margin-left:-4px; margin-right:auto; } ' + 
			'.vakata-context-rtl li a ins { margin:0 -2em 0 0; } ' + 
			'.vakata-context-rtl li a span { margin:0 0 0 0.5em; border-left-color:white; background:#e2e3e3; } ' + 
			'';
		$.vakata.css.add_sheet({ str : css_string, title : "vakata-context" });

		vakata_context.element = $("<ul class='vakata-context'></ul>");
		vakata_context.element
			.delegate("li", "mouseenter", function (e) {
				e.stopImmediatePropagation();

				if($.contains(this, e.relatedTarget)) { 
					// премахнато заради delegate mouseleave по-долу
					// $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
					return; 
				}

				if(to) { clearTimeout(to); }
				vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

				$(this)
					.siblings().find("ul").hide().end().end()
					.parentsUntil(".vakata-context", "li").andSelf().addClass("vakata-context-hover");
				$.vakata.context._show_submenu(this);
			})
			// тестово - дали не натоварва?
			.delegate("li", "mouseleave", function (e) {
				if($.contains(this, e.relatedTarget)) { return; }
				$(this).find(".vakata-context-hover").andSelf().removeClass("vakata-context-hover");
			})
			.bind("mouseleave", function (e) {
				$(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
				if($.vakata.context.settings.hide_onmouseleave) {
					to = setTimeout( 
						(function (t) { 
							return function () { $.vakata.context.hide(); };
						})(this), $.vakata.context.settings.hide_onmouseleave);
				}
			})
			.delegate("a", "click", function (e) { 
				e.preventDefault(); 
			})
			.delegate("a", "mouseup", function (e) {
				if(!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
					$.vakata.context.hide();
				}
			})
			.appendTo("body");

		$(document)
			.bind("mousedown", function (e) { 
				if(vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) { $.vakata.context.hide(); } 
			})
			.bind("context_show.vakata", function (e, data) {
				vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
				if(right_to_left) {
					vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
				}
				// also apply a RTL class?
				vakata_context.element.find("ul").hide().end();
			});

		if(typeof $.hotkeys !== "undefined" || typeof $.vakata_hotkeys !== "undefined") {
			$(document)
				.bind("keydown", "up", function (e) { 
					if(vakata_context.is_visible) { 
						var o = vakata_context.element.find("ul:visible").andSelf().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
						if(!o.length) { o = vakata_context.element.find("ul:visible").andSelf().last().children("li:not(.vakata-context-separator)").last(); }
						o.addClass("vakata-context-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "down", function (e) { 
					if(vakata_context.is_visible) { 
						var o = vakata_context.element.find("ul:visible").andSelf().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
						if(!o.length) { o = vakata_context.element.find("ul:visible").andSelf().last().children("li:not(.vakata-context-separator)").first(); }
						o.addClass("vakata-context-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "right", function (e) { 
					if(vakata_context.is_visible) { 
						vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "left", function (e) { 
					if(vakata_context.is_visible) { 
						vakata_context.element.find(".vakata-context-hover").last().parents("li:eq(0)").find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover");
						e.stopImmediatePropagation(); 
						e.preventDefault();
					} 
				})
				.bind("keydown", "esc", function (e) { 
					$.vakata.context.hide(); 
					e.preventDefault();
				})
				.bind("keydown", "space", function (e) { 
					vakata_context.element.find(".vakata-context-hover").last().children("a").click();
					e.preventDefault();
				});
		}
	});
})(jQuery);

/* 
Group: JSON
Functions needed to encode/decode JSON. Based on the jQuery JSON Plugin.
*/
(function ($) {
	// private function for quoting strings
	var _quote = function (str) {
		var escapeable	= /["\\\x00-\x1f\x7f-\x9f]/g,
			meta		= { '\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"' :'\\"','\\':'\\\\' };
		if(str.match(escapeable)) {
			return '"' + str.replace(escapeable, function (a) {
					var c = meta[a];
					if(typeof c === 'string') { return c; }
					c = a.charCodeAt();
					return '\\u00' + Math.floor(c / 16).toString(16) + (c % 16).toString(16);
				}) + '"';
		}
		return '"' + str + '"';
	};
	/* 
		Variable: $.vakata.json
		*object* holds all JSON related functions.
	*/
	$.vakata.json = {
		/*
			Function: $.vakata.json.encode
			A function for encoding data in a JSON notated string.

			Parameters:
				o - *mixed* the data to be encoded

			Returns:
				string - the encoded data
		*/
		encode : function (o) {
			if (o === null) { return "null"; }

			var tmp = [], i;
			switch(typeof(o)) {
				case "undefined": 
					return undefined;
				case "number":
				case "boolean":
					return o + "";
				case "string":
					return _quote(o);
				case "object":
					if($.isFunction(o.toJSON)) {
						return $.vakata.json.encode(o.toJSON());
					}
					if(o.constructor === Date) {
						return '"' + 
							o.getUTCFullYear() + '-' + 
							String("0" + (o.getUTCMonth() + 1)).slice(-2) + '-' + 
							String("0" + o.getUTCDate()).slice(-2) + 'T' + 
							String("0" + o.getUTCHours()).slice(-2) + ':' + 
							String("0" + o.getUTCMinutes()).slice(-2) + ':' + 
							String("0" + o.getUTCSeconds()).slice(-2) + '.' + 
							String("00" + o.getUTCMilliseconds()).slice(-3) + 'Z"'; 
					}
					if(o.constructor === Array) {
						for(i = 0; i < o.length; i++) {
							tmp.push( $.vakata.json.encode(o[i]) || "null" );
						}
						return "[" + tmp.join(",") + "]";
					}

					$.each(o, function (i, v) {
						if($.isFunction(v)) { return true; }
						i = typeof i === "number" ? '"' + i + '"' : _quote(i);
						v = $.vakata.json.encode(v);
						tmp.push(i + ":" + v);
					});
					return "{" + tmp.join(", ") + "}";
			}
		},
		/* 
			Function: $.vakata.json.decode
			Exists for consistency and is a simple wrapper for jQuery.parseJSON.

			Parameters:
				json - the string to be decoded

			Returns:
				Same as jQuery.parseJSON
		*/
		decode : function (json) {
			return $.parseJSON(json);
		}
	};
})(jQuery);

/* 
Group: Cookie
A copy of the jQuery cookie plugin.
*/
(function ($) {
	/*
		Function: $.vakata.cookie
		A function for getting and setting cookies.

		Parameters:
			Same as the original plugin

		Returns:
			string - the encoded data
	*/
	$.vakata.cookie = function (key, value, options) {
		var days, t, result, decode;
		if (arguments.length > 1 && String(value) !== "[object Object]") {
			options = $.extend({}, options);
			if(value === null || value === undefined) { options.expires = -1; }
			if(typeof options.expires === 'number') { days = options.expires; t = options.expires = new Date(); t.setDate(t.getDate() + days); }
			value = String(value);
			return (document.cookie = [
				encodeURIComponent(key), '=',
				options.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', 
				options.path ? '; path=' + options.path : '',
				options.domain ? '; domain=' + options.domain : '',
				options.secure ? '; secure' : ''
			].join(''));
		}
		options = value || {};
		decode = options.raw ? function (s) { return s; } : decodeURIComponent;
		return (result = new RegExp('(?:^|; )' + encodeURIComponent(key) + '=([^;]*)').exec(document.cookie)) ? decode(result[1]) : null;
	};
})(jQuery);

/* 
Group: LocalStorage
Functions for dealing with localStorage with fallback to userData or cookies. A slight modification of jstorage.
*/

(function ($) {
	var _storage = {},
		_storage_service = {jStorage:"{}"},
		_storage_elm = null,
		_storage_size = 0,
		json_encode = $.vakata.json.encode,
		json_decode = $.vakata.json.decode,
		_backend = false,
		_ttl_timeout = false;

	function _init() {
		var localStorageReallyWorks = false;
		if("localStorage" in window){
			try {
				window.localStorage.setItem('_tmptest', 'tmpval');
				localStorageReallyWorks = true;
				window.localStorage.removeItem('_tmptest');
			} catch(BogusQuotaExceededErrorOnIos5) {
				// Thanks be to iOS5 Private Browsing mode which throws
				// QUOTA_EXCEEDED_ERRROR DOM Exception 22.
			}
		}

		if(localStorageReallyWorks){
			try {
				if(window.localStorage) {
					_storage_service = window.localStorage;
					_backend = "localStorage";
				}
			} catch(E3) {/* Firefox fails when touching localStorage and cookies are disabled */}
		}
		else if("globalStorage" in window) {
			try {
				if(window.globalStorage) {
					_storage_service = window.globalStorage[window.location.hostname];
					_backend = "globalStorage";
				}
			} catch(E4) {/* Firefox fails when touching localStorage and cookies are disabled */}
		}
		else {
			_storage_elm = document.createElement('link');
			if(_storage_elm.addBehavior) {
				_storage_elm.style.behavior = 'url(#default#userData)';
				document.getElementsByTagName('head')[0].appendChild(_storage_elm);
				try {
					_storage_elm.load("jStorage");
					var data = "{}";
					data = _storage_elm.getAttribute("jStorage");
					_storage_service.jStorage = data;
					_backend = "userDataBehavior";
				} catch(E5) {}
			}
			if(
				!_backend && (
					!!$.vakata.cookie('__vjstorage') || 
					($.vakata.cookie('__vjstorage', '{}', { 'expires' : 365 }) && $.vakata.cookie('__vjstorage') === '{}')
				)
			) { 
				_storage_elm = null;
				_storage_service.jStorage = $.vakata.cookie('__vjstorage');
				_backend = "cookie";
			}

			if(!_backend) {
				_storage_elm = null;
				return;
			}
		}
		_load_storage();
		_handleTTL();
	}

	function _load_storage() {
		if(_storage_service.jStorage) {
			try {
				_storage = json_decode(String(_storage_service.jStorage));
			} catch(E6) { _storage_service.jStorage = "{}"; }
		} else {
			_storage_service.jStorage = "{}";
		}
		_storage_size = _storage_service.jStorage ? String(_storage_service.jStorage).length : 0;
	}

	function _save() {
		try {
			_storage_service.jStorage = json_encode(_storage);
			if(_backend === 'userDataBehavior') {
				_storage_elm.setAttribute("jStorage", _storage_service.jStorage);
				_storage_elm.save("jStorage");
			}
			if(_backend === 'cookie') {
				$.vakata.cookie('__vjstorage', _storage_service.jStorage, { 'expires' : 365 });
			}
			_storage_size = _storage_service.jStorage?String(_storage_service.jStorage).length:0;
		} catch(E7) { /* probably cache is full, nothing is saved this way*/ }
	}

	function _checkKey(key) {
		if(!key || (typeof key !== "string" && typeof key !== "number")){
			throw new TypeError('Key name must be string or numeric');
		}
		if(key === "__jstorage_meta") {
			throw new TypeError('Reserved key name');
		}
		return true;
	}

	function _handleTTL() {
		var curtime = +new Date(), 
			i, 
			TTL, 
			nextExpire = Infinity, 
			changed = false;

		if(_ttl_timeout !== false) {
			clearTimeout(_ttl_timeout);
		}
		if(!_storage.__jstorage_meta || typeof _storage.__jstorage_meta.TTL !== "object"){
			return;
		}
		TTL = _storage.__jstorage_meta.TTL;
		for(i in TTL) {
			if(TTL.hasOwnProperty(i)) {
				if(TTL[i] <= curtime) {
					delete TTL[i];
					delete _storage[i];
					changed = true;
				}
				else if(TTL[i] < nextExpire) {
					nextExpire = TTL[i];
				}
			}
		}

		// set next check
		if(nextExpire !== Infinity) {
			_ttl_timeout = setTimeout(_handleTTL, nextExpire - curtime);
		}
		// save changes
		if(changed) {
			_save();
		}
	}

	/* 
		Variable: $.vakata.storage
		*object* holds all storage related functions and properties.
	*/
	$.vakata.storage = {
		/* 
			Variable: $.vakata.storage.version
			*string* the version of jstorage used
		*/
		version: "0.1.6.1",
		/* 
			Function: $.vakata.storage.set
			Set a key to a value

			Parameters:
				key - the key
				value - the value

			Returns:
				_value_
		*/
		set : function (key, value) {
			_checkKey(key);
			_storage[key] = value;
			_save();
			return value;
		},
		/* 
			Function: $.vakata.storage.get
			Get a value by key.

			Parameters:
				key - the key
				def - the value to return if _key_ is not found

			Returns:
				The found value, _def_ if key not found or _null_ if _def_ is not supplied.
		*/
		get : function (key, def) {
			_checkKey(key);
			if(key in _storage){
				return _storage[key];
			}
			return typeof(def) === 'undefined' ? null : def;
		},
		/* 
			Function: $.vakata.storage.del
			Remove a key.

			Parameters:
				key - the key

			Returns:
				*boolean*
		*/
		del : function (key) {
			_checkKey(key);
			if(key in _storage) {
				delete _storage[key];

				if(_storage.__jstorage_meta && typeof _storage.__jstorage_meta.TTL === "object" && key in _storage.__jstorage_meta.TTL) {
					delete _storage.__jstorage_meta.TTL[key];
				}
				_save();
				return true;
			}
			return false;
		},

		setTTL: function(key, ttl){
			var curtime = +new Date();

			_checkKey(key);
			ttl = Number(ttl) || 0;
			if(key in _storage){
				if(!_storage.__jstorage_meta){
					_storage.__jstorage_meta = {};
				}
				if(!_storage.__jstorage_meta.TTL) {
					_storage.__jstorage_meta.TTL = {};
				}
				if(ttl > 0) {
					_storage.__jstorage_meta.TTL[key] = curtime + ttl;
				}
				else {
					delete _storage.__jstorage_meta.TTL[key];
				}
				_save();
				_handleTTL();
				return true;
			}
			return false;
		},

		/* 
			Function: $.vakata.storage.flush
			Empty the storage.

			Returns:
				_true_
		*/
		flush : function(){
			_storage = {};
			_save();
			// try{ window.localStorage.clear(); } catch(E8) { }
			return true;
		},
		/* 
			Function: $.vakata.storage.storageObj
			Get a read only copy of the whole storage.

			Returns:
				*object* 
		*/
		storageObj : function(){
			function F() {}
			F.prototype = _storage;
			return new F();
		},
		/* 
			Function: $.vakata.storage.index
			Get an array of all the set keys in the storage.

			Returns:
				*array* 
		*/
		index : function(){
			var index = [], i;
			$.each(_storage, function (i, v) { if(i !== "__jstorage_meta") { index.push(i); } });
			return index;
		},
		/* 
			Function: $.vakata.storage.storageSize
			Get the size of all items in the storage in bytes.

			Returns:
				*number* 
		*/
		storageSize : function(){
			return _storage_size;
		},
		/* 
			Function: $.vakata.storage.currentBackend
			Get the current backend used.

			Returns:
				*string* 
		*/
		currentBackend : function(){
			return _backend;
		},
		/* 
			Function: $.vakata.storage.storageAvailable
			See if storage functionality is available.

			Returns:
				*boolean* 
		*/
		storageAvailable : function(){
			return !!_backend;
		}
	};
	_init();
})(jQuery);

/* 
Group: PrettyDate
Modifies time elements to a more human readable value. Taken from: https://github.com/zachleat/Humane-Dates/blob/master/src/humane.js
*/
(function ($) {
	/* 
		Variable: $.vakata.pretty_date
		*object* holds all pretty-date related functions and properties.
	*/
	$.vakata.pretty_date = {
		/* 
			Variable: $.vakata.pretty_date.lang
			*object* the localization to use.
		*/
		lang : {
			ago: 'Ago',
			from: 'From Now',
			now: 'Just Now',
			minute: 'Minute',
			minutes: 'Minutes',
			hour: 'Hour',
			hours: 'Hours',
			day: 'Day',
			days: 'Days',
			week: 'Week',
			weeks: 'Weeks',
			month: 'Month',
			months: 'Months',
			year: 'Year',
			years: 'Years'
		},
		/* 
			Function: $.vakata.pretty_date.parse
			Parses the difference between to dates to a human readable string.

			Parameters:
				date - the date to calculate from (а string in this YYYY-MM-DDTHH:MM:SSZ format - UTC)
				comareTo - the date to compare to (as date), if left empty the current date is used

			Returns:
				*mixed* - the formatted string on success or _null_ on error
		*/
		parse : function (date, compareTo) {
			// remove the timezone (always use gmdate on server side)
			date = new Date(date.replace(/-/g,"/").replace(/[TZ]/g," ").replace(/\+\d\d\:\d\d$/,''));
			compareTo = compareTo || new Date();
			var lang		= $.vakata.pretty_date.lang,
				formats		= [
					[60, lang.now],
					[3600, lang.minute, lang.minutes, 60], // 60 minutes, 1 minute
					[86400, lang.hour, lang.hours, 3600], // 24 hours, 1 hour
					[604800, lang.day, lang.days, 86400], // 7 days, 1 day
					[2628000, lang.week, lang.weeks, 604800], // ~1 month, 1 week
					[31536000, lang.month, lang.months, 2628000], // 1 year, ~1 month
					[Infinity, lang.year, lang.years, 31536000] // Infinity, 1 year
				],
				seconds		= (compareTo - date + compareTo.getTimezoneOffset() * 60000) / 1000,
				normalize	= function (val, single) {
								var margin = 0.1;
								if(val >= single && val <= single * (1+margin)) {
									return single;
								}
								return val;
							},
				token;

			if(seconds < 0) {
				seconds = Math.abs(seconds);
				token = ' ' + lang.from;
			}
			else {
				token = ' ' + lang.ago;
			}

			for(var i = 0, format = formats[0]; formats[i]; format = formats[++i]) {
				if(seconds < format[0]) {
					if(i === 0) {
						return format[1];
					}
					var val = Math.ceil(normalize(seconds, format[3]) / (format[3]));
					return val +
							' ' +
							(val !== 1 ? format[2] : format[1]) +
							(i > 0 ? token : '');
				}
			}
		},
		/* 
			Function: $.vakata.pretty_date.init
			Parses all time elements in the document and keeps reparsing them every few seconds.

			Parameters:
				i - the interval for reparsing (in milliseconds). Default is 60000.
				format - the format to use, example: _Published %{s}._. Default is _%{s}_.
		*/
		init : function (i, format) {
			$("time, [datetime]").vakata_pretty_date(format);
			setInterval(function(){ $("time, [datetime]").vakata_pretty_date(format); }, i || 60000);
		}
	};
	/*
	Function: $().vakata_pretty_date
	Sets the HTML of every element to the parsed difference of its _datetime_ attribute and the compare parameter.

		Parameters:
			format - makes it possible to modify the parsed string, example: _Published %{s}._. Default is _%{s}_.
			compare - the date to compare to. Default is the current date.
	*/
	$.fn.vakata_pretty_date = function (format, compare) {
		if(!format) { format = '%{s}'; }
		return this.each(function() {
			var $t = jQuery(this),
				date = $.vakata.pretty_date.parse($t.attr('datetime'), compare);
			if(date) {
				date = format.replace('%{s}', date);
				if($t.html() !== date) {
					$t.html(date);
				}
			}
		});
	};
})(jQuery);

/* 
Group: Selection
Selection related functions
*/
(function ($) {
	/* 
		Variable: $.vakata.selection
		*object* holds all selection related functions and properties.
	*/
	$.vakata.selection = {
		/* 
			Function: $.vakata.selection.get
			Gets the current selection.

			Parameters:
				as_text - a boolean - if set to _true_ selection is returned as text, otherwise as HTML

			Returns:
				*string* - the current selection
		*/
		get : function (as_text) {
			if(window.getSelection) {
				if(as_text) {
					return window.getSelection().toString();
				}
				var userSelection	= window.getSelection(),
					range			= userSelection.getRangeAt && userSelection.rangeCount ? userSelection.getRangeAt(0) : document.createRange(),
					div				= document.createElement('div');
				if(!userSelection.getRangeAt) {
					range.setStart(userSelection.anchorNode, userSelection.anchorOffset);
					range.setEnd(userSelection.focusNode, userSelection.focusOffset);
				}
				div.appendChild(range.cloneContents());
				return div.innerHTML;
			}
			if(document.selection) {
				return document.selection.createRange()[ as_text ? 'text' : 'htmlText' ];
			}
			return '';
		},
		/* 
			Function: $.vakata.selection.elm_get
			Gets the selection inside an input element or textarea.

			Parameters:
				e - the actual DOM element or the ID of the element

			Returns:
				*object* - the current selection (start, end, length, text)
		*/
		elm_get : function (e) {
			e = typeof e === 'string' ? document.getElementById(e) : e;
			if(e.jquery) { e = e.get(0); }
			if('selectionStart' in e) { // Mozilla and DOM 3.0
				return { 
					'start'		: e.selectionStart, 
					'end'		: e.selectionEnd, 
					'length'	: (e.selectionEnd - e.selectionStart), 
					'text'		: e.value.substr(e.selectionStart, (e.selectionEnd - e.selectionStart)) 
				};
			}
			else if(document.selection) { // IE
				e.focus();
				var tr0 = document.selection.createRange(),
					tr1 = false,
					tr2 = false,
					len, text_whole, the_start, the_end;
				if(tr0 && tr0.parentElement() === e) {
					len = e.value.length;
					text_whole = e.value.replace(/\r\n/g, "\n");

					tr1 = e.createTextRange();
					tr1.moveToBookmark(tr0.getBookmark());
					tr2 = e.createTextRange();
					tr2.collapse(false);

					if(tr1.compareEndPoints("StartToEnd", tr2) > -1) {
						the_start = the_end = len;
					} 
					else {
						the_start  = -tr1.moveStart("character", -len);
						the_start += text_whole.slice(0, the_start).split("\n").length - 1;
						if (tr1.compareEndPoints("EndToEnd", tr2) > -1) {
							the_end = len;
						} else {
							the_end  = -tr1.moveEnd("character", -len);
							the_end += text_whole.slice(0, the_end).split("\n").length - 1;
						}
					}
					text_whole = e.value.slice(the_start, the_end);
					return { 
						'start'		: the_start, 
						'end'		: the_end, 
						'length'	: text_whole.length, 
						'text'		: text_whole
					};
				}
			}
			else { // not supported
				return { 
					'start'		: e.value.length, 
					'end'		: e.value.length, 
					'length'	: 0, 
					'text'		: '' 
				};
			}
		},
		/* 
			Function: $.vakata.selection.elm_set
			Sets the selection inside an input element or textarea.

			Parameters:
				e - the actual DOM element or the ID of the element
				beg - the char to start the selection
				end - the char to end the selection

			Returns:
				*object* - the current selection (start, end, length, text)
		*/
		elm_set : function (e, beg, end) {
			e = typeof e === 'string' ? document.getElementById(e) : e;
			if(e.jquery) { e = e.get(0); }
			if('selectionStart' in e) { // Mozilla and DOM 3.0
				e.focus();
				e.selectionStart	= beg;
				e.selectionEnd		= end;
			}
			else if(document.selection) { // IE
				e.focus();
				var tr	= e.createTextRange(), 
					tx	= e.value.replace(/\r\n/g, "\n");

				beg -= tx.slice(0, beg).split("\n").length - 1;
				end -= tx.slice(0, end).split("\n").length - 1;

				tr.collapse(true);
				tr.moveEnd('character', end);
				tr.moveStart('character', beg); 
				tr.select();
			}
			return $.vakata.selection.elm_get(e);
		},
		/* 
			Function: $.vakata.selection.elm_replace
			Replace the selection inside an input element or textarea.

			Parameters:
				e - the actual DOM element or the ID of the element
				replace - the string to replace the selection with

			Returns:
				*object* - the current selection (start, end, length, text)
		*/
		elm_replace : function (e, replace) {
			e = typeof e === 'string' ? document.getElementById(e) : e;
			if(e.jquery) { e = e.get(0); }
			var sel = $.vakata.selection.elm_get(e),
				beg = sel.start,
				end = beg + replace.length;
			e.value = e.value.substr(0, beg) + replace + e.value.substr(sel.end, e.value.length);
			$.vakata.selection.elm_set(e, beg, end);
			return { 
				'start'		: beg, 
				'end'		: end, 
				'length'	: replace.length, 
				'text'		: replace
			};
		},
		/* 
			Function: $.vakata.selection.elm_get_caret
			Returns the caret position in the element.

			Parameters:
				e - the actual DOM element or the ID of the element

			Returns:
				*number* - the current caret position
		*/
		elm_get_caret : function (e) {
			return $.vakata.selection.elm_get(e).end;
		},
		/* 
			Function: $.vakata.selection.elm_set_caret
			Sets the caret position in the element.

			Parameters:
				e - the actual DOM element or the ID of the element
				pos - the position to move the caret to

			Returns:
				*object* - the current selection
		*/
		elm_set_caret : function (e, pos) {
			return $.vakata.selection.elm_set(e, pos, pos);
		},
		/* 
			Function: $.vakata.selection.elm_get_caret_position
			Returns the caret position in pixels relative to the element.

			Parameters:
				e - the actual DOM element or the ID of the element

			Returns:
				*object* - the current position (with _left_ and _top_ values)
		*/
		elm_get_caret_position : function (e) {
			e = typeof e === 'string' ? document.getElementById(e) : e;
			if(e.jquery) { e = e.get(0); }
			var p = $.vakata.selection.elm_get_caret(e),
				s = e.value.substring(0, p).replace(/&/g,'&amp;').replace(/</ig,'&lt;').replace(/>/ig,'&gt;').replace(/\r/g, '').replace(/\t/g,'&#10;').replace(/\n/ig, '<br />'),
				b = $.vakata.get_scrollbar_width(),
				w = $(e).width(),
				h = $(e).height();
			if(e.scrollHeight > h) { w -= b; }
			if(e.scrollWidth > w)  { h -= b; }
			e = $(e);
			e = $('<div />').html(s).css({
						'background': 'red',
						'width'		: w + 'px',
						'height'	: 'auto',
						'position'	: 'absolute',
						'left'		: '0px',
						'top'		: '-10000px',

						'fontSize'		: e.css('fontSize'),
						'fontFamily'	: e.css('fontFamily'),
						'fontWeight'	: e.css('fontWeight'),
						'fontVariant'	: e.css('fontVariant'),
						'fontStyle'		: e.css('fontStyle'),
						'textTransform'	: e.css('textTransform'),
						'lineHeight'	: e.css('lineHeight'),
						'whiteSpace'	: 'pre-wrap'
					});
			e.append('<span class="caret">&nbsp;</span>').appendTo('body');
			s = e.find('span.caret');
			p = s.offset();
			p.top = p.top + 10000 + s.height();
			e.remove();
			return p;
		}
	};
})(jQuery);



(function ($) {
	/*
		Function: $.vakata_highlight
		Hightlight words in the matched elements

		Parameters:
			settings - if a string is passed, it is used to search and highlight, if an array of strings is passed, each string is highlighted, you can also pass an object, containing a _words_ string or array, a _color_ string or array, a _css_class_ string.
	*/
	$.fn.vakata_highlight = function (settings) {
		var _return = this;
		if(typeof settings === 'string') { 
			settings = [ settings ]; 
		}
		if($.isArray(settings)) {
			settings = { 'words' : settings };
		}
		settings = $.extend(true, {}, { 'css_class' : 'vakata-highlight', 'words' : [], 'color' : '#99ccff' }, settings);
		if(settings.words.length) {
			this.each(function () {
				var t = $(this);
				$.each(settings.words, function (i,v) {
					var color = false;
					if(typeof settings.color === 'string') {
						color = settings.color;
					}
					if($.isArray(settings.color) && typeof settings.color[i] === 'string') {
						color = settings.color[i];
					}
					t
						.find(':vakata_icontains("' + v.replace(/\"/ig,'') + '")')
						.filter('strong, span, li, p, h1, h2, h3, h4, h5, h6, div, u, em, i, dt, dd')
						.contents()
						.filter(function() { return this.nodeType === 3; })
						.each(function () {
							if(this.nodeValue.toLowerCase().indexOf(v.toLowerCase()) >= 0) {
								this.nodeValue = this.nodeValue.replace(new RegExp('(' + v.replace(/([\-.*+?\^${}()|\[\]\/\\])/g,"\\$1") + ')', 'ig'), '|{{{$1}}}|');
								var o = $(this).parent();
								o.html(o.html().replace(/\|\{\{\{/g,'<span class="' + settings.css_class + ' ' + settings.css_class + '-' + i + '" ' + ( typeof color === 'string' ? ' style="background:' + color + ';" ' : '' ) + '>').replace(/\}\}\}\|/g,'</span>'));
							}
						});
				});
			});
		}
		return _return;
	};
})(jQuery);
define("ext/jstree/vakata", function(){});

/*
 * jsTree 1.0.0
 * http://jstree.com/
 *
 * Copyright (c) 2011 Ivan Bozhanov (vakata.com)
 *
 * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 */

/*global jQuery */

/* File: jstree.js
The only required part of jstree it consists of a few functions bound to the $.jstree object, the actual plugin function and a few core functions for manipulating a tree.
*/
(function () { 
	"use strict";
	if(!jQuery) { throw "jsTree: jQuery not included."; }
	if(jQuery.jstree) { return; } // prevent another load? maybe there is a better way?

/* Group: $.jstree. 
Some static functions and variables, unless you know exactly what you are doing do not use these, but <$().jstree> instead.
*/
(function ($) {
	var instances			= [],
		focused_instance	= -1,
		plugins				= {},
		functions			= {};
	/* 
		Variable: $.jstree
		*object* Contains all static functions and variables used by jstree, some plugins also append variables.
	*/
	$.jstree = { 
		/* 
			Variable: $.jstree.VERSION
				*string* the version of jstree
		*/
		VERSION : '1.0.0',

		/* 
			Variable: $.jstree.IS_IE6
				*boolean* indicating if the client is running Internet Explorer 6
		*/
		IS_IE6 : (jQuery.browser.msie && parseInt(jQuery.browser.version,10) === 6),

		/* 
			Variable: $.jstree.IS_IE7
				*boolean* indicating if the client is running Internet Explorer 7
		*/
		IS_IE7 : (jQuery.browser.msie && parseInt(jQuery.browser.version,10) === 6),

		/*
			Variable: $.jstree.IS_FF2
				*boolean* indicating if the client is running Firefox 2
		*/
		IS_FF2 : (jQuery.browser.mozilla && parseFloat(jQuery.browser.version,10) < 1.9),

		/* 
			Function: $.jstree.__construct
				Creates a new jstree instance, any arguments after the first one are merged and used to configure the tree.

				`.data("jstree")` is also called on the container and is used for configuration (keep in mind you can specify this data using a "data-jstree" attribute)

			Parameters:
				container - *mixed* the container of the tree (this should not be the UL node, but a wrapper) - DOM node, jQuery object or selector
		*/
		__construct	: function (container) {
			var s = {}, // settings
				d = {}, // data
				p = [], // plugins
				t = [], // plugins temp
				i = 0;  // index
			container = $(container);
			if($.jstree._reference(container)) { $.jstree.__destruct(container); }
			$.extend.apply(null, [true, s].concat(Array.prototype.slice.call(arguments, 1), (container.data("jstree") || {}) ));
			p = $.isArray(s.plugins) ? s.plugins : $.jstree.defaults.plugins.slice();
			p = $.vakata.array_unique(p);
			s = $.extend(true, {}, $.jstree.defaults, s);
			$.each(plugins, function (i, val) { 
				if(i !== "core" && $.inArray(i, p) === -1) { s[i] = null; delete s[i]; } 
				else { t.push(i); d[i] = {}; }
			});
			s.plugins = t;
			i = parseInt(instances.push({}),10) - 1;
			container
				.data("jstree_instance_id", i)
				.addClass("jstree jstree-" + i);

			this.data				= d;
			this.get_index			= function () { return i; };
			this.get_container		= function () { return container; };
			this.get_container_ul	= function () { return container.children("ul:eq(0)"); };
			this.get_settings		= function (writable) { return writable ? s : $.extend(true, {}, s); };
			this.__trigger			= function (ev, data) { 
				if(!ev) { return; }
				if(!data) { data = {}; }
				if(typeof ev === "string") { ev = ev.replace(".jstree","") + ".jstree"; }
				data.inst = this;
				this.get_container().triggerHandler(ev, data);
			};
			instances[i] = this;
			$.each(t, function (j, val) { if(plugins[val]) { plugins[val].__construct.apply(instances[i]); } });
			this.__trigger("__construct");
			$.jstree._focus(i);
			return this;
		},
		/*
			Group: $.jstree. 

			Function: $.jstree.__destruct
				Destroys an instance, and also clears `jstree-` prefixed classes and all events in the `jstree` namespace

			Parameters:
				instance - *mixed* the instance to destroy (this argument is passed to <$.jstree._reference> to get the instance)

			See also:
				<$.jstree._reference>
		*/
		__destruct	: function (instance) {
			instance = $.jstree._reference(instance);
			if(!instance) { return false; }
			var s = instance.get_settings(),
				n = instance.get_index(),
				i = 0;
			if(focused_instance === n) {
				for(i in instances) { 
					if(instances.hasOwnProperty(i) && i !== n) { 
						$.jstree._focus(i);
						break; 
					} 
				}
				if(focused_instance === n) { $.jstree._focus(false); }
			}
			$.each(s.plugins, function (i, val) {
				try { plugins[val].__destruct.apply(instance); } catch(err) { }
			});
			instance.__trigger("__destruct");
			instance.get_container()
				.unbind(".jstree")
				.undelegate(".jstree")
				.removeData("jstree_instance_id")
				.find("[class^='jstree']")
					.andSelf()
					.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,''); });
			$(document)
				.unbind(".jstree-" + n)
				.undelegate(".jstree-" + n);
			delete instances[n];
			return true;
		},
		/* 
			Function: $.jstree.__call
				Call a function on the instance and return the result

			Parameters:
				instance - *mixed* the instance to destroy (this argument is passed to <$.jstree._reference> to get the instance)
				operation - *string* the operation to execute
				args - *array* the arguments to pass to the function

			See also:
				<$.jstree._reference>
		*/
		__call		: function (instance, operation, args) {
			instance = $.jstree._reference(instance);
			if(!instance || !$.isFunction(instance[operation])) { return; }
			return instance[operation].apply(instance, args);
		},
		/* 
			Function: $.jstree._reference
				Returns an instance

			Parameters:
				needle - *mixed* - integer, DOM node contained inside a jstree container, ID string, jQuery object, selector
		*/
		_reference	: function (needle) { 
			if(instances[needle]) { return instances[needle]; }
			var o = $(needle); 
			if(!o.length && typeof needle === "string") { o = $("#" + needle); }
			if(!o.length) { return null; }
			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; 
		},
		/*
			Function: $.jstree._focused
				Returns the currently focused instance (by default once an instance is created it is focused)
		*/
		_focused	: function () {
			return instances[focused_instance] || null; 
		},
		/*
			Function: $.jstree._focus
				Make an instance focused (which defocuses the previously focused instance)

			Parameters:
				instance - *mixed* the instance to focus (this argument is passed to <$.jstree._reference> to get the instance)

			See also:
				<$.jstree._reference>
		*/
		_focus		: function (instance) {
			if(instance === false) {
				instances[focused_instance].get_container().removeClass("jstree-focused");
				instances[focused_instance].__trigger("_defocus");
				focused_instance = -1;
				return false;
			}
			instance = $.jstree._reference(instance);
			if(!instance || instance.get_index() === focused_instance) { return false; }
			if(focused_instance !== -1) {
				instances[focused_instance].get_container().removeClass("jstree-focused");
				instances[focused_instance].__trigger("_defocus");
			}
			focused_instance = instance.get_index();
			instance.get_container().addClass("jstree-focused");
			instance.__trigger("_focus");
			return true;
		},
		/*
			Function: $.jstree.plugin
				Register a plugin

			Parameters:
				plugin_name - *string* the name of the new plugin (it will be used as a key in an object - make sure it is valid)
				plugin_data - *object* consists of 4 keys. Default is:
				>{ 
				>	__construct	: $.noop,	// this function will be executed when a new instance is created
				>	__destuct	: $.noop,	// this function will be executed when an instance is destroyed
				>	_fn			: { },		// each key of this object should be a function that will extend the jstree prototype
				>	defaults	: false		// the default configuration for the plugin (if any)
				>}
		*/
		plugin		: function (plugin_name, plugin_data) {
			plugin_data = $.extend({}, {
					__construct	: $.noop, 
					__destuct	: $.noop,
					_fn			: { },
					defaults	: false
				}, plugin_data);
			plugins[plugin_name]			= plugin_data;
			$.jstree.defaults[plugin_name]	= plugin_data.defaults;
			$.each(plugin_data._fn, function (i, val) {
				val.plugin		= plugin_name;
				val.old			= functions[i];
				functions[i]	= function () {
					var rslt,
						func = val,
						args = Array.prototype.slice.call(arguments),
						evnt = new $.Event("before.jstree"),
						plgn = this.get_settings(true).plugins;

					do {
						if(func && func.plugin && $.inArray(func.plugin, plgn) !== -1) { break; }
						func = func.old;
					} while(func);
					if(!func) { return; }

					if(i.indexOf("_") === 0) {
						rslt = func.apply(this, args);
					}
					else {
						rslt = this.__trigger(evnt, { "func" : i, "args" : args, "plugin" : func.plugin });
						if(rslt === false) { return; }
						rslt = func.apply(
							$.extend({}, this, { 
								__callback : function (data) { 
									this.__trigger( i, { "args" : args, "rslt" : data, "plugin" : func.plugin });
									return data;
								},
								__call_old : function (replace_arguments) {
									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );
								}
							}), args);
					}
					return rslt;
				};
				functions[i].old	= val.old;
				functions[i].plugin	= plugin_name;
			});
		},
		/*
			Variable: $.jstree.defaults
				*object* storing all the default configuration options for every plugin and the core. 
				If this is modified all instances created after the modification, which do not explicitly specify some other value will use the new default.
			
			Example:
			>// this instance will use the _default_ theme
			>$("#div0").jstree({ plugins : ["themes"] }); 
			>$.jstree.defaults.themes.theme = "classic";
			>// this instance will use the _classic_ theme
			>$("#div1").jstree({ plugins : ["themes"] }); 
			>// this instance will use the _apple_ theme
			>$("#div2").jstree({ themes : { "theme" : "apple" }, plugins : ["themes"] }); 
		*/
		defaults	: { 
			plugins : []
		}
	};
	/* Group: $().jstree()
		The actual plugin wrapper, use this to create instances or execute functions on created instances.

		Function: $().jstree

		Creates an instance using the specified objects for containers, or executes a command on an instance, specified by a container.

		Parameters:
			settings - *mixed* 
			
			- if you pass an *object* a new instance will be created (using <$.jstree.__construct>) 
			for each of the objects in the jquery collection, 
			if an instance already exists on the container it will be destroyed first
			
			- if you pass a *string* it will be executed using <$.jstree.__call> on each instance

		Examples:
			> // this creates an instance
			> $("#some-id").jstree({ 
			>	plugins : [ "html_data", "themes", "ui" ]
			> });
			>
			> // this executes a function on the instance
			> $("#some-id").jstree("select_node", "#the-id-to-select");

		See also:
			<$.jstree.__construct>, 
			<$.jstree.__destruct>, 
			<$.jstree.__call>
	*/
	$.fn.jstree = function (settings) {
		var _is_method	= (typeof settings === 'string'), 
			_arguments	= Array.prototype.slice.call(arguments, 1), 
			_return		= this;
		this.each(function () {
			if(_is_method) {
				var val = $.jstree.__call(this, settings, _arguments);
				if(typeof val !== "undefined" && (settings.indexOf("is_" === 0) || (val !== true && val !== false))) {
					_return = val;
					return false;
				}
			}
			else {
				_is_method = new $.jstree.__construct(this, settings);
			}
		});
		return _return;
	};
	functions = $.jstree.__construct.prototype;
	
	$.expr[':'].jstree = function(a,i,m) {
		return typeof ($(a).data("jstree_instance_id")) !== 'undefined';
	};
})(jQuery);

(function ($) {
	var ccp_node = false, 
		ccp_mode = false;

	$(function() { $.jstree.SCROLLBAR_WIDTH = $.vakata.get_scrollbar_width(); });

	$.jstree.plugin("core", {
		__construct : function () {
			this.data.core.rtl = (this.get_container().css("direction") === "rtl");
			if(this.data.core.rtl) { this.get_container().addClass("jstree-rtl"); }
			this.data.core.ready = false;

			this.get_container()
				.bind("__construct.jstree", $.proxy(function () {
						// defer, so that events bound AFTER creating the instance (like __ready) are still handled
						setTimeout($.proxy(function () { if(this) { this.init(); } }, this), 0);
					}, this))
				.bind("before.jstree", $.proxy(function (e, data) {
						if(!/^is_locked|unlock$/.test(data.func) && this.data.core.locked) {
							e.stopImmediatePropagation();
							return false;
						}
					}, this))
				.bind("create_node.jstree", $.proxy(function (e, data) {
						this.clean_node(data.rslt.obj);
					}, this))
				.bind("load_node.jstree", $.proxy(function (e, data) {
						// data.rslt.status
						this.clean_node(data.rslt.obj === -1 ? this.get_container_ul().children('li') : data.rslt.obj.find('> ul > li'));
						if(!this.data.core.ready && !this.get_container_ul().find('.jstree-loading:eq(0)').length) {
							this.data.core.ready = true;
							this.__trigger("__ready");
						}
					}, this))
				.bind("__loaded.jstree", $.proxy(function (e, data) {
						data.inst.get_container_ul().children('li').each(function () {
							data.inst.correct_node(this);
						});
					}, this))
				.bind("open_node.jstree", $.proxy(function (e, data) {
						data.rslt.obj.find('> ul > li').each(function () {
							data.inst.correct_node(this);
						});
					}, this))
				.bind("mousedown.jstree", $.proxy(function () { 
						$.jstree._focus(this.get_index());
					}, this))
				.bind("dblclick.jstree", function () { 
						if(document.selection && document.selection.empty) { document.selection.empty(); }
						else { if(window.getSelection) { var sel = window.getSelection(); try { sel.removeAllRanges(); sel.collapse(); } catch (er) { } } }
					})
				.delegate("li > ins", "click.jstree", $.proxy(function (e) {
						// var trgt = $(e.target);
						// if(trgt.is("ins") && e.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }
						this.toggle_node(e.target);
					}, this));
		},
		__destruct : function () { 
			
		},
		/* Class: jstree */
		/*
			Variable: data
			*object* Provides storage for plugins (aside from private variables). Every plugin has an key in this object.
			> this.data.<plugin_name>;
			This is useful for detecting if some plugin is included in the instance (plugins also use this for dependencies and enhancements).

			Function: get_index
			Returns an *integer*, which is the instance's index. Every instance on the page has an unique index, when destroying an intance the index will not be reused.

			Function: get_container
			Returns the jQuery extended container of the tree (the element you used when constructing the tree).

			Function: get_container_ul
			Returns the jQuery extended first UL node inside the container of the tree.

			Function: get_settings
			Returns the settings for the tree.

			Parameters:
				writable - *boolean* whether to return a copy of the settings object or a reference to it.

			Example:
			> $("#div1").jstree("get_settings"); // will return a copy
			> $.jstree._reference("#div1").get_settings(); // same as above
			> $.jstree._focused().get_settings(true); // a reference. BE CAREFUL!

			Function: __trigger
			Used internally to trigger events on the container node.

			Parameters:
				event_name - the name of the event to trigger (the *jstree* namespace will be appended to it)
				data - the additional object to pass along with the event. By default _data.inst_ will be the current instance, so when you bind to the event, you can access the instance easily.
				> $("div").bind("some-event.jstree", function (e, data) { data.inst.some_function(); });
		*/
		/* 
			Group: CORE options

			Variable: config.core.strings
			*mixed* used to store all localization strings. Default is _false_.

			Example 1: 
			>$("div").jstree({
			>	core : { 
			>		strings : function (s) {
			>			if(s === "Loading ...") { s = "Please wait ..."; }
			>			return s;
			>		}
			>	}
			>});

			Example 2: 
			>$("div").jstree({
			>	core : { 
			>		strings : {
			>			"Loading ..." : "Please wait ..."
			>		}
			>	}
			>});

			See also:
			<_get_string>
		*/
		defaults : { 
			strings : false
		},
		_fn : { 
			/* 
				Group: CORE functions

				Function: _get_string
				Used to get the common string in the tree. 

				If <config.core.strings> is set to a function, that function is called with a single parameter (the needed string), the response is returned.

				If <config.core.strings> is set to an object, the key named as the needed string is returned.

				If <config.core.strings> is not set, the the needed string is returned.

				Parameters:
					needed_string - *string* the needed string
			*/
			_get_string : function (s) { 
				var a = this.get_settings(true).core.strings;
				if($.isFunction(a)) { return a.call(this, s); }
				if(a && a[s]) { return a[s]; }
				return s; 
			},
			/* 
				Function: init
				Used internally. This function is called once the core plugin is constructed.

				Triggers:
				<__loaded>

				Event: __loaded
				This event is triggered in the *jstree* namespace when data is first rendered in the tree. It won't be triggered after a refresh. Fires only once.

				Parameters:
					data.inst - the instance
				
				Example:
				> $("div").bind("__loaded.jstree", function (e, data) { data.inst.do_something(); });

				Event: __ready
				This event is triggered in the *jstree* namespace when all initial loading is done. It won't be triggered after a refresh. Fires only once.

				Parameters:
					data.inst - the instance
			*/
			init : function () { 
				this.data.core.original_container_html = this.get_container().find(" > ul > li").clone(true);
				this.data.core.original_container_html.find("li").andSelf().contents().filter(function() { return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue)); }).remove();
				this.get_container().html("<ul><li class='jstree-loading'><a href='#'>" + this._get_string("Loading ...") + "</a></li></ul>");
				this.clean_node(-1);
				this.data.core.li_height = this.get_container_ul().children("li:eq(0)").height() || 18;
				this.load_node(-1, function () { 
					this.__trigger("__loaded");
				});
			},
			/* 
				Function: lock
				Used to lock the tree. When the tree is in a locked state, no functions can be called on the instance (except <is_locked> and <unlock>).
				Additionally a _jstree-locked_ class is applied on the container.

				Triggers:
				<lock>

				Event: lock
				This event is triggered in the *jstree* namespace when the tree is locked.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - _null_
				
				Example:
				> $("div").bind("lock.jstree", function (e, data) { data.inst.do_something(); });
			*/
			lock : function () { 
				this.data.core.locked = true; 
				this.get_container().addClass("jstree-locked"); 
				this.__callback(); 
			},
			/* 
				Function: unlock
				Used to unlock the tree. Instance can be used normally again. The _jstree-locked_ class is removed from the container.

				Triggers:
				<unlock>

				Event: unlock
				This event is triggered in the *jstree* namespace when the tree is unlocked.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - _null_
				
				Example:
				> $("div").bind("unlock.jstree", function (e, data) { data.inst.do_something(); });
			*/
			unlock : function () { 
				this.data.core.locked = false; 
				this.get_container().removeClass("jstree-locked"); 
				this.__callback(); 
			},
			/* 
				Function: is_locked
				Used to get the locked status of the tree.

				Returns:
					locked - *boolean* _true_ if tree is locked, _false_ otherwise
			*/
			is_locked : function () { 
				return this.data.core.locked; 
			},
			/* 
				Function: get_node
				Get a hold of the LI node (which represents the jstree node).

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
				
				Returns:
					jquery collection - node was found, the collection contains the LI node
					-1 - the tree container was referenced
					false - on failure (obj is not part of a tree, or does not exists in the DOM)
			*/
			get_node : function (obj) { 
				var $obj = $(obj, this.get_container()); 
				if($obj.is(".jstree") || obj === -1) { return -1; } 
				$obj = $obj.closest("li", this.get_container()); 
				return $obj.length ? $obj : false; 
			},
			/* 
				Function: get_next
				Get the next sibling of a node

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					strict - *boolean* if set to _true_ jstree will only return immediate siblings, otherwise, if _obj_ is the last child of its parent, the parent's next sibling is returned.

				Returns:
					jquery collection - node was found, the collection contains the LI node
					-1 - the tree container was referenced
					false - node was not found, or failure (obj is not part of a tree, or does not exists in the DOM)
			*/
			get_next : function (obj, strict) {
				obj = this.get_node(obj);
				if(obj === -1) { return this.get_container_ul().children("li:eq(0)"); }
				if(!obj || !obj.length) { return false; }
				if(strict) { return (obj.nextAll("li").size() > 0) ? obj.nextAll("li:eq(0)") : false; }
				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }
				else if(obj.nextAll("li").size() > 0) { return obj.nextAll("li:eq(0)"); }
				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }
			},
			/* 
				Function: get_prev
				Get the previous sibling of a node

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					strict - *boolean* if set to _true_ jstree will only return immediate siblings, otherwise, if _obj_ is the first child of its parent, the parent's previous sibling is returned.

				Returns:
					jquery collection - node was found, the collection contains the LI node
					-1 - the tree container was referenced
					false - node was not found, or failure (obj is not part of a tree, or does not exists in the DOM)
			*/
			get_prev : function (obj, strict) {
				obj = this.get_node(obj);
				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }
				if(!obj || !obj.length) { return false; }
				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }
				if(obj.prev("li").length) {
					obj = obj.prev("li").eq(0);
					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }
					return obj;
				}
				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }
			},
			/* 
				Function: get_parent
				Get the parent of a node

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					jquery collection - node was found, the collection contains the LI node
					-1 - when _obj_ was a root node
					false - on failure (obj is not part of a tree, or does not exists in the DOM)
			*/
			get_parent : function (obj) {
				obj = this.get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				var o = obj.parentsUntil(".jstree", "li:eq(0)");
				return o.length ? o : -1;
			},
			/* 
				Function: get_children
				Get all the children of a node

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. If _-1_ is used all root nodes are returned.

				Returns:
					jquery collection - node was found, the collection contains the LI nodes of all immediate children
					false - on failure (obj is not part of a tree, or does not exists in the DOM)
			*/
			get_children	: function (obj) {
				obj = this.get_node(obj);
				if(obj === -1) { return this.get_container_ul().children("li"); }
				if(!obj || !obj.length) { return false; }
				return obj.find("> ul > li");
			},
			/* 
				Function: is_parent
				Check if a node is a parent.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ has children or is closed (will be loaded)
					false - _obj_ is not a valid node or has no children (leaf node)
			*/
			is_parent	: function (obj) { obj = this.get_node(obj); return obj && obj !== -1 && (obj.find("> ul > li:eq(0)").length || obj.hasClass("jstree-closed")); },
			/* 
				Function: is_loaded
				Check if a node is loaded.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ has children or is leaf
					false - _obj_ is currently loading or is not a leaf, but has no children
			*/
			is_loaded	: function (obj) { obj = this.get_node(obj); return obj && ( (obj === -1 && !this.get_container().find("> ul > li.jstree-loading").length) || ( obj !== -1 && !obj.hasClass('jstree-loading') && (obj.find('> ul > li').length || obj.hasClass('jstree-leaf')) ) ); },
			/* 
				Function: is_loading
				Check if a node is currently loading.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ is currently loading
					false - _obj_ is not currently loading
			*/
			is_loading	: function (obj) { obj = this.get_node(obj); return obj && ( (obj === -1 && this.get_container().find("> ul > li.jstree-loading").length) || (obj !== -1 && obj.hasClass("jstree-loading")) ); },
			/* 
				Function: is_open
				Check if a node is currently open.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ is currently open
					false - _obj_ is not currently open
			*/
			is_open		: function (obj) { obj = this.get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },
			/* 
				Function: is_closed
				Check if a node is currently closed.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ is currently closed
					false - _obj_ is not currently closed
			*/
			is_closed	: function (obj) { obj = this.get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },
			/* 
				Function: is_leaf
				Check if a node is a leaf node (has no children).

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.

				Returns:
					true - _obj_ is a leaf node
					false - _obj_ is not a leaf node
			*/
			is_leaf		: function (obj) { obj = this.get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },
			/* 
				Function: load_node
				Load the children of a node.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. Use -1 to load the root nodes.
					callback - a function to be executed in the tree's scope. Receives two arguments: _obj_ (the same node used to call load_node), _status_ (a boolean indicating if the node was loaded successfully.

				Returns:
					true - _obj_ is a valid node and will try loading it
					false - _obj_ is not a valid node

				Triggers:
					<load_node>

				See also:
					<_load_node>

				Event: load_node
				This event is triggered in the *jstree* namespace when a node is loaded (succesfully or not).

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - *object* which contains two keys _obj_ (the loaded node) and _status_ - whether the node was loaded successfully.
				
				Example:
				> $("div").bind("load_node.jstree", function (e, data) { if(data.rslt.status) { data.inst.open_node(data.rslt.obj); } });
			*/
			load_node	: function (obj, callback) {
				obj = this.get_node(obj);
				if(!obj) { callback.call(this, obj, false); return false; }
				// if(this.is_loading(obj)) { return true; }
				if(obj !== -1) { obj.addClass("jstree-loading"); }
				this._load_node(obj, $.proxy(function (status) {
					if(obj !== -1) { obj.removeClass("jstree-loading"); }
					this.__callback({ "obj" : obj, "status" : status });
					if(callback) { callback.call(this, obj, status); }
				}, this));
				return true;
			},
			/* 
				Function: _load_node
				Load the children of a node, but as opposed to <load_node> does not change any visual properties or trigger events. This function is used in <load_node> internally. The idea is for data source plugins to overwrite this function. 
				This implementation (from the *core*) only uses markup found in the tree container, and does not load async.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. Use -1 to load the root nodes.
					callback - a function to be executed in the tree's scope. Receives one argument: _status_ (a boolean indicating if the node was loaded successfully).
			*/
			_load_node	: function (obj, callback) {
				// if using async - empty the node first
				if(obj === -1) {
					this.get_container_ul().empty().append(this.data.core.original_container_html.clone(true));
				}
				callback.call(null, true);
			},
			/* 
				Function: open_node
				Open a node so that its children are visible. If the node is not loaded try loading it first.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					callback - a function to be executed in the tree's scope. Receives two arguments: _obj_ (the node being opened) and _status_ (a boolean indicating if the node was opened successfully).
					animation - the duration in miliseconds of the slideDown animation. If not supplied the jQuery default is used. Please note that on IE6 a _0_ is enforced here due to performance issues.
				
				Triggers:
					<open_node>, <__after_open>

				Event: open_node
				This event is triggered in the *jstree* namespace when a node is successfully opened (but if animation is used this event is triggered BEFORE the animation completes). See <__after_open>.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - *object* which contains a single key: _obj_ (the opened node).
				
				Example:
				> $("div").bind("open_node.jstree", function (e, data) { 
				>   data.rslt.obj.find('> ul > .jstree-closed').each(function () { 
				>     data.inst.open_node(this); 
				>   }
				> });

				Event: __after_open
				This event is triggered in the *jstree* namespace when a node is successfully opened AFTER the animation completes). See <open_node>.

				Parameters:
					data.inst - the instance
					data.rslt - *object* which contains a single key: _obj_ (the opened node).
				
				Example:
				> $("div").bind("__after_open.jstree", function (e, data) { 
				>   data.rslt.obj.find('> ul > .jstree-closed').each(function () { 
				>     data.inst.open_node(this); 
				>   }
				> });
			*/
			open_node : function (obj, callback, animation) { 
				obj = this.get_node(obj);
				if(obj === -1 || !obj || !obj.length) { return false; }
				if(!this.is_closed(obj)) { if(callback) { callback.call(this, obj, false); } return false; }
				if(!this.is_loaded(obj)) { // TODO: is_loading?
					this.load_node(obj, function (o, ok) { 
						return ok ? this.open_node(o, callback, animation) : callback ? callback.call(this, o, false) : false;
					});
				}
				else {
					var t = this;
					obj
						.children("ul").css("display","none").end()
						.removeClass("jstree-closed").addClass("jstree-open") 
						// .children("ins").text("-").end()
						.children("ul").stop(true, true).slideDown( ($.jstree.IS_IE6 ? 0 : animation), function () { 
								this.style.display = ""; 
								t.__trigger("__after_open", { "rslt" : { "obj" : obj } }); 
							}); 
					if(callback) { callback.call(this, obj, true); }
					this.__callback({ "obj" : obj });
				}
			},
			/* 
				Function: close_node
				Close a node so that its children are not visible.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					animation - the duration in miliseconds of the slideDown animation. If not supplied the jQuery default is used. Please note that on IE6 a _0_ is enforced here due to performance issues.
				
				Triggers:
					<close_node>, <__after_close>

				Event: close_node
				This event is triggered in the *jstree* namespace when a node is closed (but if animation is used this event is triggered BEFORE the animation completes). See <__after_close>.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - *object* which contains a single key: _obj_ (the closed node).
				
				Example:
				> $("div").bind("close_node.jstree", function (e, data) { 
				>   data.rslt.obj.children('ul').remove();
				> });

				Event: __after_close
				This event is triggered in the *jstree* namespace when a node is closed AFTER the animation completes). See <close_node>.

				Parameters:
					data.inst - the instance
					data.rslt - *object* which contains a single key: _obj_ (the opened node).
				
				Example:
				> $("div").bind("__after_close.jstree", function (e, data) { 
				>   data.rslt.obj.children('ul').remove();
				> });
			*/
			close_node : function (obj, animation) { 
				obj = this.get_node(obj);
				if(!obj || !obj.length || !this.is_open(obj)) { return false; }
				var t = this;
				obj
					.children("ul").attr("style","display:block !important").end()
					.removeClass("jstree-open").addClass("jstree-closed")
					// .children("ins").text("+").end()
					.children("ul").stop(true, true).slideUp( ($.jstree.IS_IE6 ? 0 : animation), function () { 
						this.style.display = ""; 
						t.__trigger("__after_close", { "rslt" : { "obj" : obj } }); 
					});
				this.__callback({ "obj" : obj });
			},
			/* 
				Function: toggle_node
				If a node is closed - open it, if it is open - close it.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
			*/
			toggle_node : function (obj) { 
				if(this.is_closed(obj)) { return this.open_node(obj); }
				if(this.is_open(obj)) { return this.close_node(obj); }
			},
			/* 
				Function: open_all
				Open all nodes from a certain node down.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. If _-1_ is used or is omitted all nodes in the tree are opened.
					animation - the duration of the slideDown animation when opening the nodes. If not set _0_ is enforced for performance issues.
					original_obj - used internally to keep track of the recursion - do not set manually!
				
				Triggers:
					<open_all>

				Event: open_all
				This event is triggered in the *jstree* namespace when an open_all call completes.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - *object* which contains a single key: _obj_ (the node used in the call).
				
				Example:
				> $("div").bind("open_all.jstree", function (e, data) { 
				>   alert('DONE');
				> });
			*/
			open_all : function (obj, animation, original_obj) {
				obj = obj ? this.get_node(obj) : -1;
				obj = !obj || obj === -1 ? this.get_container_ul() : obj;
				original_obj = original_obj || obj;
				var _this = this;
				obj = this.is_closed(obj) ? obj.find('li.jstree-closed').andSelf() : obj.find('li.jstree-closed');
				obj.each(function () { 
					_this.open_node(
						this, 
						_this.is_loaded(this) ? 
							false : 
							function(obj) { this.open_all(obj, animation, original_obj); }, 
						animation || 0
					); 
				});
				if(original_obj.find('li.jstree-closed').length === 0) { this.__callback({ "obj" : original_obj }); }
			},
			/* 
				Function: close_all
				Close all nodes from a certain node down.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. If _-1_ is used or is omitted all nodes in the tree are closed.
					animation - the duration of the slideDown animation when closing the nodes. If not set _0_ is enforced for performance issues.
				
				Triggers:
					<close_all>

				Event: close_all
				This event is triggered in the *jstree* namespace when a close_all call completes.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else).
					data.rslt - *object* which contains a single key: _obj_ (the node used in the call).
				
				Example:
				> $("div").bind("close_all.jstree", function (e, data) { 
				>   alert('DONE');
				> });
			*/
			close_all : function (obj, animation) {
				obj = obj ? this._get_node(obj) : -1;
				var $obj = !obj || obj === -1 ? this.get_container_ul() : obj,
					_this = this;
				$obj = this.is_open($obj) ? $obj.find('li.jstree-open').andSelf() : $obj.find('li.jstree-open');
				$obj.each(function () { _this.close_node(this, animation || 0); });
				this.__callback({ "obj" : obj });
			},
			/* 
				Function: clean_node
				This function converts inserted nodes to the required by jsTree format. It takes care of converting a simple unodreder list to the internally used markup. 
				The core calls this function automatically when new data arrives (by binding to the <load_node> event).
				Each plugin may override this function to include its own source, but keep in mind to do it like that:
				> clean_node : function(obj) {
				>  obj = this.__call_old();
				>  obj.each(function () { 
				>    // do your stuff here
				>  });
				> }

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. If _-1_ is used or is omitted all nodes in the tree are cleaned.

				Returns:
					jQuery collection - the cleaned children of the original node.
			*/
			clean_node : function (obj) {
				// DETACH maybe inside the "load_node" function? But what about animations, etc?
				obj = this.get_node(obj);
				obj = !obj || obj === -1 ? this.get_container().find("li") : obj.find("li").andSelf();
				var _this = this;
				return obj.each(function () {
					var t = $(this),
						d = t.data("jstree"),
						s = (d && d.opened) || t.hasClass("jstree-open") ? "open" : (d && d.closed) || t.children("ul").length ? "closed" : "leaf";
					if(d && d.opened) { delete d.opened; }
					if(d && d.closed) { delete d.closed; }
					t.removeClass("jstree-open jstree-closed jstree-leaf jstree-last");
					if(!t.children("a").length) { 
						// allow for text and HTML markup inside the nodes
						t.contents().filter(function() { return this.nodeType === 3 || this.tagName !== 'UL'; }).wrapAll('<a href="#"></a>');
						// TODO: make this faster
						t.children('a').html(t.children('a').html().replace(/[\s\t\n]+$/,''));
					}
					else {
						if(!$.trim(t.children('a').attr('href'))) { t.children('a').attr("href","#"); }
					}
					if(!t.children("ins.jstree-ocl").length) { 
						t.prepend("<ins class='jstree-icon jstree-ocl'>&#160;</ins>");
					}
					if(t.is(":last-child")) { 
						t.addClass("jstree-last"); 
					}
					switch(s) {
						case 'leaf':
							t.addClass('jstree-leaf'); 
							break;
						case 'closed':
							t.addClass('jstree-open'); 
							_this.close_node(t, 0);
							break;
						case 'open':
							t.addClass('jstree-closed');
							_this.open_node(t, false, 0); 
							break;
					}
				});
			},
			/* 
				Function: correct_node
				This function corrects the open/closed/leaf state as data changes (as the user interacts with the tree).
				The core calls this function automatically when a node is opened, deleted or moved.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc. If _-1_ is used or is omitted the root nodes are processed.

				Returns:
					jQuery collection - the processed children of the original node.
			*/
			/* PROCESS SINGLE NODE (OR USE BOOLEAN single PARAM), CALL FROM CLEAN_NODE, LOSE THE EVENTS ABOVE */
			correct_node : function (obj, deep) { 
				obj = this.get_node(obj);
				if(!obj || (obj === -1 && !deep)) { return false; }
				if(obj === -1) { obj = this.get_container().find('li'); }
				else { obj = deep ? obj.find('li').andSelf() : obj; }
				obj.each(function () {
					var obj = $(this);
					switch(!0) {
						case obj.hasClass("jstree-open") && !obj.find("> ul > li").length:
							obj.removeClass("jstree-open").addClass("jstree-leaf").children("ul").remove(); // children("ins").html("&#160;").end()
							break;
						case obj.hasClass("jstree-leaf") && !!obj.find("> ul > li").length:
							obj.removeClass("jstree-leaf").addClass("jstree-closed"); //.children("ins").html("+");
							break;
					}
					obj[obj.is(":last-child") ? 'addClass' : 'removeClass']("jstree-last");
				});
				return obj;
			},
			/* 
				Function: scroll_to_node
				This function scrolls the container to the desired node (if needed).

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
			*/
			scroll_to_node : function (obj) {
				var c = this.get_container()[0], t;
				if(c.scrollHeight > c.offsetHeight) {
					obj = this.get_node(obj);
					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }
					t = obj.offset().top - this.get_container().offset().top;
					if(t < 0) { 
						c.scrollTop = c.scrollTop + t - 1; 
					}
					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? $.jstree.SCROLLBAR_WIDTH : 0) > c.offsetHeight) { 
						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? $.jstree.SCROLLBAR_WIDTH : 0)); 
					}
				}
			},
			/* 
				Function: get_state
				This function returns the current state of the tree (as collected from all active plugins). 
				Plugin authors: pay special attention to the way this function is extended for new plugins. In your plugin code write:
				> get_state : function () {
				>   var state = this.__call_old();
				>   state.your-plugin-name = <some-value-you-collect>;
				>   return state;
				> }

				Returns:
					object - the current state of the instance
			*/
			get_state : function () { // TODO: scroll position, theme
				var state	= { 'open' : [], 'scroll' : { 'left' : this.get_container().scrollLeft(), 'top' : this.get_container().scrollTop() } };
				this.get_container_ul().find('.jstree-open').each(function () { if(this.id) { state.open.push(this.id); } });
				return state;
			},
			/* 
				Function: set_state
				This function returns sets the state of the tree. 
				Plugin authors: pay special attention to the way this function is extended for new plugins. In your plugin code write:
				> set_state : function (state, callback) {
				>   if(this.__call_old()) {
				>     if(state.your-plugin-name) {
				>       
				>       // restore using `state.your-plugin-name`
				>       // if you need some async activity so that you return to this bit of code
				>       // do not delete state.your-plugin-name and return false (see core's function for example)
				>       
				>       delete state.your-plugin-name;
				>       this.set_state(state, callback);
				>       return false;
				>     }
				>     return true;
				>   }
				>   return false;
				> }

				Parameters:
					state - *object* the state to restore to
					callback - *function* this will be executed in the instance's scope once restoring is done

				Returns:
					boolean - the return value is used to determine the phase of restoration

				Triggers:
					<set_state>

				Event: set_state
				This event is triggered in the *jstree* namespace when a set_state call completes.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
			*/
			set_state : function (state, callback) {
				if(state) {
					if($.isArray(state.open)) {
						var res = true, 
							t = this;
						//this.close_all();
						$.each(state.open.concat([]), function (i, v) {
							v = document.getElementById(v);
							if(v) { 
								if(t.is_loaded(v)) { 
									if(t.is_closed(v)) {
										t.open_node(v, false, 0); 
									}
									$.vakata.array_remove(state.open, i); 
								}
								else { 
									if(!t.is_loading(v)) {
										t.open_node(v, $.proxy(function () { this.set_state(state); }, t), 0); 
									}
									// there will be some async activity - so wait for it
									res = false; 
								}
							}
						});
						if(res) {
							delete state.open; 
							this.set_state(state, callback); 
						}
						return false;
					}
					if(state.scroll) {
						if(state.scroll && typeof state.scroll.left !== 'undefined') { 
							this.get_container().scrollLeft(state.scroll.left); 
						}
						if(state.scroll && typeof state.scroll.top !== 'undefined') { 
							this.get_container().scrollTop(state.scroll.top); 
						}
						delete state.scroll;
						delete state.open;
						this.set_state(state, callback);
						return false;
					}
					if($.isEmptyObject(state)) {
						if(callback) { callback.call(this); }
						this.__callback();
						return false;
					}
					return true;
				}
				return false;
			},
			/* 
				Function: refresh
				This function saves the current state, reloads the complete tree and returns it to the saved state. 

				Triggers:
					<refresh>

				Event: refresh
				This event is triggered in the *jstree* namespace when a refresh call completes.

				Parameters:
					data.inst - the instance
			*/
			refresh : function () {
				this.data.core.state = this.get_state();
				this.load_node(-1, function (o, s) { 
					if(s) {
						this.set_state($.extend(true, {}, this.data.core.state), function () { this.__trigger('refresh'); });
					}
					this.data.core.state = null;
				});
			},
			/* 
				Function: get_text
				This function returns the title of the node. 

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					remove_html - *boolean* set to _true_ to return plain text instead of HTML

				Returns:
					string - the title of the node, specified by _obj_
			*/
			get_text : function (obj, remove_html) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj = obj.children("a:eq(0)").clone();
				obj.children(".jstree-icon").remove();
				return obj[ remove_html ? 'text' : 'html' ]();
			},
			/* 
				Function: set_text
				This function sets the title of the node. This is a low-level function, you'd be better off using <rename>.

				Parameters:
					obj - *mixed* this is used as a jquery selector - can be jQuery object, DOM node, string, etc.
					val - *string* the new title of the node (can be HTMl too)

				Returns:
					boolean - was the rename successfull

				Triggers:
					<set_text>

				Event: set_text
				This event is triggered in the *jstree* namespace when a set_text call completes.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a two keys: _obj_ (the node) and _val_ (the new title).
				
				Example:
				> $("div").bind("set_text.jstree", function (e, data) { 
				>   alert("Renamed to: " + data.rslt.val);
				> });
			*/
			set_text : function (obj, val) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj = obj.children("a:eq(0)");
				var tmp = obj.children("INS").clone();
				obj.html(val).prepend(tmp);
				this.__callback({ "obj" : obj, "text" : val });
				return true;
			},
			/* 
				Function: parse_json
				This function returns a jQuery node after parsing a JSON object (a LI node for single elements or an UL node for multiple). This function will use the default title from <jstree.config.core.strings> if none is specified.

				Parameters:
					node - *mixed* the input to parse
					> // can be a string
					> "The title of the parsed node"
					> // array of strings
					> [ "Node 1", "Node 2" ]
					> // an object
					> { "title" : "The title of the parsed node" }
					> // you can manipulate the output
					> { "title" : "The title of the parsed node", "li_attr" : { "id" : "id_for_li" }, "a_attr" : { "href" : "http://jstree.com" } }
					> // you can supply metadata, which you can later access using $(the_li_node).data()
					> { "title" : "The title of the parsed node", "data" : { <some-values-here> } }
					> // you can supply children (they can be objects too)
					> { "title" : "The title of the parsed node", "children" : [ "Node 1", { "title" : "Node 2" } ] }

				Returns:
					jQuery - the LI (or UL) node which was produced from the JSON
			*/
			parse_json : function (node) {
				var li, a, ul, t;
				if($.isArray(node)) {
					ul	= $("<ul />");
					t	= this;
					$.each(node, function (i, v) {
						ul.append(t.parse_json(v));
					});
					return ul;
				}
				if(typeof node === "undefined") { node = {}; }
				if(typeof node === "string") { node = { "title" : node }; }
				if(!node.li_attr) { node.li_attr = {}; }
				if(!node.a_attr) { node.a_attr = {}; }
				if(!node.a_attr.href) { node.a_attr.href = '#'; }
				if(!node.title) { node.title = this._get_string("New node"); }

				li	= $("<li />").attr(node.li_attr);
				a	= $("<a />").attr(node.a_attr).html(node.title);
				ul	= $("<ul />");
				if(node.data && !$.isEmptyObject(node.data)) { li.data(node.data); }
				if(
					node.children === true ||
					$.isArray(node.children) || 
					(li.data('jstree') && $.isArray(li.data('jstree').children))
				) {
					if(!li.data('jstree')) {
						li.data('jstree', {});
					}
					li.data('jstree').closed = true;
				}
				li.append(a);
				if($.isArray(node.children)) {
					$.each(node.children, $.proxy(function (i, n) {
						ul.append(this.parse_json(n));
					}, this));
					li.append(ul);
				}
				return li;
			},
			/* 
				Function: get_json
				This function returns the whole tree (or a single node) in JSON format.
				Each plugin may override this function to include its own source, but keep in mind to do it like that:
				> get_json : function(obj, is_callback) {
				>  var r = this.__call_old();
				>  if(is_callback) {
				>   if(<some-condition>) { r.data.jstree.<some-key> = <some-value-this-plugin-will-process>; }
				>  }
				>  return r;
				> }

				Parameters:
					obj - *mixed* the input to parse
					is_callback - do not modify this, jstree uses this parameter to keep track of the recursion

				Returns:
					Array - an array consisting of objects (one for each node)
			*/
			get_json : function (obj, is_callback) {
				obj = typeof obj !== 'undefined' ? this.get_node(obj) : false;
				if(!is_callback) {
					if(!obj || obj === -1) { obj = this.get_container_ul().children("li"); }
				}
				var r, t, li_attr = {}, a_attr = {}, tmp = {};
				if(!obj || !obj.length) { return false; }
				if(obj.length > 1 || !is_callback) {
					r = [];
					t = this;
					obj.each(function () {
						r.push(t.get_json($(this), true));
					});
					return r;
				}
				tmp = $.vakata.attributes(obj, true);
				$.each(tmp, function (i, v) {
					if(i === 'id') { li_attr[i] = v; return true; }
					v = $.trim(v.replace(/\bjstree[^ ]*/ig,'').replace(/\s+$/ig," "));
					if(v.length) { li_attr[i] = v; }
				});
				tmp = $.vakata.attributes(obj.children('a'), true);
				$.each(tmp, function (i, v) {
					if(i === 'id') { a_attr[i] = v; return true; }
					v = $.trim(v.replace(/\bjstree[^ ]*/ig,'').replace(/\s+$/ig," "));
					if(v.length) { a_attr[i] = v; }
				});
				r = { 
					'title'		: this.get_text(obj), 
					'data'		: $.extend(true, {}, obj.data() || {}), 
					'children'	: false, 
					'li_attr'	: li_attr, 
					'a_attr'	: a_attr 
				};

				if(!r.data.jstree) { r.data.jstree = {}; }
				if(this.is_open(obj)) { r.data.jstree.opened = true; }
				if(this.is_closed(obj)) { r.data.jstree.closed = true; }

				obj = obj.find('> ul > li');
				if(obj.length) {
					r.children = [];
					t = this;
					obj.each(function () {
						r.children.push(t.get_json($(this), true));
					});
				}
				return r;
			},
			/* 
				Function: create_node
				This function creates a new node.

				Parameters:
					parent - *mixed* the parent for the newly created node. This is used as a jquery selector, can be jQuery object, DOM node, string, etc. Use -1 to create a new root node.
					node - *mixed* the input to parse, check <parse_json> for description
					position - *mixed* where to create the new node. Can be one of "before", "after", "first", "last", "inside" or a numerical index.
					callback - optional function to be executed once the node is created
					is_loaded - used internally when a node needs to be loaded - do not pass this

				Returns:
					jQuery - the LI node which was produced from the JSON (may return _undefined_ if the parent node is not yet loaded, but will create the node)

				Triggers:
					<create_node>

				Event: create_node
				This event is triggered in the *jstree* namespace when a new node is created.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a three keys: _obj_ (the node), _parent_ (the parent) and _position_ which is the numerical index.
				
				Example:
				> $("div").bind("create_node.jstree", function (e, data) { 
				>   alert("Created `" + data.inst.get_text(data.rslt.obj) + "` inside `" + (data.rslt.parent === -1 ? 'the main container' : data.inst.get_text(data.rslt.parent)) + "` at index " + data.rslt.position);
				> });
			*/
			create_node : function (par, node, pos, callback, is_loaded) {
				par = this.get_node(par);
				pos = typeof pos === "undefined" ? "last" : pos;

				if(par !== -1 && !par.length) { return false; }
				if(!pos.match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) { 
					return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); }); 
				}

				var li = this.parse_json(node),
					tmp = par === -1 ? this.get_container() : par;

				if(par === -1) {
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before": 
						pos = par.index();
						par = this.get_parent(par);
						break;
					case "after" : 
						pos = par.index() + 1;
						par = this.get_parent(par); 
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = tmp.children('ul').children('li').length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}
				if(!this.check("create_node", li, par, pos)) { return false; }

				tmp = par === -1 ? this.get_container() : par;
				if(!tmp.children("ul").length) { tmp.append("<ul />"); }
				if(tmp.children("ul").children("li").eq(pos).length) {
					tmp.children("ul").children("li").eq(pos).before(li);
				}
				else { 
					tmp.children("ul").append(li); 
				}
				this.correct_node(par, true);
				if(callback) { callback.call(this, li); }
				this.__callback({ "obj" : li, "parent" : par, "position" : li.index() });
				return li;
			},
			/*
				Function: rename_node
				This function renames a new node.

				Parameters:
					obj - *mixed* the node to rename. This is used as a jquery selector, can be jQuery object, DOM node, string, etc.
					val - *string* the new title

				Triggers:
					<rename_node>

				Event: rename_node
				This event is triggered in the *jstree* namespace when a node is renamed.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a three keys: _obj_ (the node), _title_ (the new title), _old_ (the old title)
				
				Example:
				> $("div").bind("rename_node.jstree", function (e, data) { 
				>   alert("Node rename from `" + data.rslt.old + "` to `" + data.rslt.title "`");
				> });
			*/
			rename_node : function (obj, val) {
				obj = this.get_node(obj);
				var old = this.get_text(obj);
				if(!this.check("rename_node", obj, this.get_parent(obj), val)) { return false; }
				if(obj && obj.length) {
					this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments)) 
					this.__callback({ "obj" : obj, "title" : val, "old" : old }); 
				}
			},
			/*
				Function: delete_node
				This function deletes a node.

				Parameters:
					obj - *mixed* the node to remove. This is used as a jquery selector, can be jQuery object, DOM node, string, etc.

				Returns:
					mixed - the removed node on success, _false_ on failure

				Triggers:
					<delete_node>

				Event: delete_node
				This event is triggered in the *jstree* namespace when a node is deleted.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a three keys: _obj_ (the removed node), _prev_ (the previous sibling of the removed node), _parent_ (the parent of the removed node)
				
				Example:
				> $("div").bind("delete_node.jstree", function (e, data) { 
				>   alert("Node deleted!");
				> });
			*/
			delete_node : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				var par = this.get_parent(obj), 
					pre = this.get_prev(obj);
				if(!this.check("delete_node", obj, par, obj.index())) { return false; }
				obj = obj.detach();
				this.correct_node(par);
				this.correct_node(pre);
				this.__callback({ "obj" : obj, "prev" : pre, "parent" : par });
				return obj;
			},
			/*
				Function: check
				This function checks if a structure modification is valid. 

				Parameters:
					chk - *string* what are we checking (copy_node, move_node, rename_node, create_node, delete_node)
					obj - *mixed* the node. 
					par - *mixed* the parent (if dealing with a move or copy - the new parent).
					pos - *mixed* the index among the parent's children (or the new name if dealing with a rename)
					is_copy - *boolean* is this a copy or a move call

				Returns:
					boolean - _true_ if the modification is valid, _false_ otherwise
			*/
			check : function (chk, obj, par, pos) {
				var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj;
				tmp = tmp === -1 ? this.get_container().data('jstree') : tmp.data('jstree');
				if(tmp && tmp.functions && tmp.functions[chk]) {
					tmp = tmp.functions[chk];
					if($.isFunction(tmp)) { 
						tmp = tmp.call(this, chk, obj, par, pos); 
					}
					if(tmp === false) {
						return false;
					}
				}
				switch(chk) {
					case "create_node":
						break;
					case "rename_node":
						break;
					case "move_node":
						tmp = par === -1 ? this.get_container() : par;
						tmp = tmp.children('ul').children('li');
						if(tmp.length && tmp.index(obj) !== -1 && (pos === obj.index() || pos === obj.index() + 1)) {
							return false;
						}
						if(par !== -1 && par.parentsUntil('.jstree', 'li').andSelf().index(obj) !== -1) { 
							return false; 
						}
						break;
					case "copy_node":
						break;
					case "delete_node":
						break;
				}
				return true;
			},
			/*
				Function: move_node
				This function moves a node.

				Parameters:
					obj - *mixed* the node to move. This is used as a jquery selector, can be jQuery object, DOM node, string, etc.
					parent - *mixed* the new parent. This is used as a jquery selector, can be jQuery object, DOM node, string, etc. Use -1 to promote to a root node.
					position - *mixed* where to create the new node. Can be one of "before", "after", "first", "last", "inside" or a numerical index.
					callback - optional function to be executed once the node is moved
					is_loaded - used internally when a node needs to be loaded - do not pass this

				Returns:
					boolean - indicating if the move was successfull (may return _undefined_ if the parent node is not yet loaded, but will move the node)


				Triggers:
					<move_node>

				Event: move_node
				This event is triggered in the *jstree* namespace when a node is moved.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a five keys: _obj_ (the node), _parent_ (the new parent) and _position_ which is the numerical index, _old_parent_ (the old parent) and is_multi (a boolean indicating if the node is coming from another tree instance)
				
				Example:
				> $("div").bind("move_node.jstree", function (e, data) { 
				>   alert("Moved `" + data.inst.get_text(data.rslt.obj) + "` inside `" + (data.rslt.parent === -1 ? 'the main container' : data.inst.get_text(data.rslt.parent)) + "` at index " + data.rslt.position);
				> });
			*/
			move_node : function (obj, par, pos, callback, is_loaded) {
				obj = this.get_node(obj);
				par = this.get_node(par);
				pos = typeof pos === "undefined" ? 0 : pos;

				if(!obj || obj === -1 || !obj.length) { return false; }
				if(par !== -1 && !par.length) { return false; }
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) { 
					return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true); }); 
				}

				var old_par = this.get_parent(obj),
					new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
					old_ins = $.jstree._reference(obj),
					new_ins = par === -1 ? this : $.jstree._reference(par),
					is_multi = (old_ins.get_index() !== new_ins.get_index());
				if(new_par === -1) {
					par = new_ins.get_container();
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before": 
						pos = par.index();
						break;
					case "after" : 
						pos = par.index() + 1;
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = par.children('ul').children('li').length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}
				if(!this.check("move_node", obj, new_par, pos)) { return false; }

				if(!par.children("ul").length) { par.append("<ul />"); }
				if(par.children("ul").children("li").eq(pos).length) {
					par.children("ul").children("li").eq(pos).before(obj);
				}
				else { 
					par.children("ul").append(obj); 
				}

				if(is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
					obj.find('.jstree-icon, .jstree-ocl').remove();
					this.clean_node(obj);
				}
				old_ins.correct_node(old_par, true);
				new_ins.correct_node(new_par, true);
				if(callback) { callback.call(this, obj, new_par, obj.index()); }
				this.__callback({ "obj" : obj, "parent" : new_par, "position" : obj.index(), "old_parent" : old_par, "is_multi" : is_multi, 'old_instance' : old_ins, 'new_instance' : new_ins });
				return true;
			},
			/*
				Function: copy_node
				This function copies a node.

				Parameters:
					obj - *mixed* the node to copy. This is used as a jquery selector, can be jQuery object, DOM node, string, etc.
					parent - *mixed* the new parent. This is used as a jquery selector, can be jQuery object, DOM node, string, etc. Use -1 to promote to a root node.
					position - *mixed* where to create the new node. Can be one of "before", "after", "first", "last", "inside" or a numerical index.
					callback - optional function to be executed once the node is moved
					is_loaded - used internally when a node needs to be loaded - do not pass this

				Returns:
					boolean - indicating if the move was successfull (may return _undefined_ if the parent node is not yet loaded, but will move the node)


				Triggers:
					<copy_node>

				Event: copy_node
				This event is triggered in the *jstree* namespace when a node is copied.

				Parameters:
					data.inst - the instance
					data.args - *array* the arguments passed to the function
					data.plugin - *string* the function's plugin (here it will be _"core"_ but if the function is extended it may be something else)
					data.rslt - *object* which contains a five keys: _obj_ (the node), _parent_ (the new parent) and _position_ which is the numerical index, _original_ (the original object), is_multi (a boolean indicating if the node is coming from another tree instance, _old_instance_ (the source instance) and _new_instance_ (the receiving instance))
				
				Example:
				> $("div").bind("copy_node.jstree", function (e, data) { 
				>   alert("Copied `" + data.inst.get_text(data.rslt.original) + "` inside `" + (data.rslt.parent === -1 ? 'the main container' : data.inst.get_text(data.rslt.parent)) + "` at index " + data.rslt.position);
				> });
			*/
			copy_node : function (obj, par, pos, callback, is_loaded) {
				obj = this.get_node(obj);
				par = this.get_node(par);
				pos = typeof pos === "undefined" ? "last" : pos;

				if(!obj || obj === -1 || !obj.length) { return false; }
				if(par !== -1 && !par.length) { return false; }
				if(!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) { 
					return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true); }); 
				}
				var org_obj = obj,
					old_par = this.get_parent(obj),
					new_par = (!pos.toString().match(/^(before|after)$/) || par === -1) ? par : this.get_parent(par),
					old_ins = $.jstree._reference(obj),
					new_ins = par === -1 ? this : $.jstree._reference(par),
					is_multi = (old_ins.get_index() !== new_ins.get_index());

				obj = obj.clone(true);
				obj.find("*[id]").andSelf().each(function () {
					if(this.id) { this.id = "copy_" + this.id; }
				});
				if(new_par === -1) {
					par = new_ins.get_container();
					if(pos === "before") { pos = "first"; }
					if(pos === "after") { pos = "last"; }
				}
				switch(pos) {
					case "before": 
						pos = par.index();
						break;
					case "after" : 
						pos = par.index() + 1;
						break;
					case "inside":
					case "first":
						pos = 0;
						break;
					case "last":
						pos = par.children('ul').children('li').length;
						break;
					default:
						if(!pos) { pos = 0; }
						break;
				}

				if(!this.check("copy_node", org_obj, new_par, pos)) { return false; }

				if(!par.children("ul").length) { par.append("<ul />"); }
				if(par.children("ul").children("li").eq(pos).length) {
					par.children("ul").children("li").eq(pos).before(obj);
				}
				else { 
					par.children("ul").append(obj); 
				}
				if(is_multi) { // if multitree - clean the node recursively - remove all icons, and call deep clean_node
					obj.find('.jstree-icon, .jstree-ocl').remove();
				}
				new_ins.clean_node(obj); // always clean so that selected states, etc. are removed
				new_ins.correct_node(new_par, true); // no need to correct the old parent, as nothing has changed there
				if(callback) { callback.call(this, obj, new_par, obj.index(), org_obj); }
				this.__callback({ "obj" : obj, "parent" : new_par, "old_parent" : old_par, "position" : obj.index(), "original" : org_obj, "is_multi" : is_multi, 'old_instance' : old_ins, 'new_instance' : new_ins });
				return true;
			},

			cut : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				ccp_node = obj;
				ccp_mode = 'move_node';
				this.__callback({ "obj" : obj });
			},
			copy : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				ccp_node = obj;
				ccp_mode = 'copy_node';
				this.__callback({ "obj" : obj });
			},
			can_paste : function () {
				return ccp_mode !== false && ccp_node !== false;
			},
			paste : function (obj) { 
				obj = this.get_node(obj);
				if(!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
				this[ccp_mode](ccp_node, obj);
				this.__callback({ "obj" : obj, "nodes" : ccp_node, "mode" : ccp_mode });
				ccp_node = false;
				ccp_mode = false;
			},

			edit : function (obj, default_text) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj.parentsUntil(".jstree",".jstree-closed").each($.proxy(function (i, v) { 
					this.open_node(v, false, 0);
				}, this));
				var rtl = this.data.core.rtl,
					w  = this.get_container().width(),
					a  = obj.children('a:eq(0)'),
					oi = obj.children("ins"),
					ai = a.children("ins"),
					w1 = oi.width() * oi.length,
					w2 = ai.width() * ai.length,
					t  = typeof default_text === 'string' ? default_text : this.get_text(obj),
					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),
					h2 = obj.css("position","relative").append(
						$("<input />", { 
							"value" : t,
							"class" : "jstree-rename-input",
							// "size" : t.length,
							"css" : {
								"padding" : "0",
								"border" : "1px solid silver",
								"position" : "absolute",
								"left"  : (rtl ? "auto" : (w1 + w2 + 4) + "px"),
								"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),
								"top" : "0px",
								"height" : (this.data.core.li_height - 2) + "px",
								"lineHeight" : (this.data.core.li_height - 2) + "px",
								"width" : "150px" // will be set a bit further down
							},
							"blur" : $.proxy(function () {
								var i = obj.children(".jstree-rename-input"),
									v = i.val();
								if(v === "") { v = t; }
								h1.remove();
								i.remove();
								this.rename_node(obj, v);
								obj.css("position", "");
							}, this),
							"keyup" : function (event) {
								var key = event.keyCode || event.which;
								if(key === 27) { this.value = t; this.blur(); return; }
								else if(key === 13) { this.blur(); return; }
								else { h2.width(Math.min(h1.text("pW" + this.value).width(),w)); }
							},
							"keypress" : function(event) {
								var key = event.keyCode || event.which;
								if(key === 13) { return false; }
							}
						})
					).children(".jstree-rename-input"),
					fn = {
							fontFamily		: a.css('fontFamily')		|| '',
							fontSize		: a.css('fontSize')			|| '',
							fontWeight		: a.css('fontWeight')		|| '',
							fontStyle		: a.css('fontStyle')		|| '',
							fontStretch		: a.css('fontStretch')		|| '',
							fontVariant		: a.css('fontVariant')		|| '',
							letterSpacing	: a.css('letterSpacing')	|| '',
							wordSpacing		: a.css('wordSpacing')		|| ''
					};
				this.set_text(obj, "");
				h1.css(fn);
				h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();
			}
		}
	});
	
	// add core CSS
	$(function() {
		var css_string = '' + 
				'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } ' + 
				'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } ' + 
				'.jstree-rtl li { margin-left:0; margin-right:18px; } ' + 
				'.jstree > ul > li { margin-left:0px; } ' + 
				'.jstree-rtl > ul > li { margin-right:0px; } ' + 
				'.jstree .jstree-icon { display:inline-block; text-decoration:none; margin:0; padding:0; vertical-align:top; } ' + 
				'.jstree .jstree-ocl { width:18px; height:18px; text-align:center; line-height:18px; cursor:default; vertical-align:top; } ' + 
				'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; padding:1px 2px; margin:0; } ' + 
				'.jstree a:focus { outline: none; } ' + 
				'li.jstree-open > ul { display:block; } ' + 
				'li.jstree-closed > ul { display:none; } ';
		// Correct IE 6 (does not support the > CSS selector)
		if($.jstree.IS_IE6) { 
			try { document.execCommand("BackgroundImageCache", false, true); } catch (err) { } // prevents flickers
			css_string += '' + 
				'.jstree li { height:18px; margin-left:0; margin-right:0; } ' + 
				'.jstree li li { margin-left:18px; } ' + 
				'.jstree-rtl li li { margin-left:0px; margin-right:18px; } ' + 
				'li.jstree-open ul { display:block; } ' + 
				'li.jstree-closed ul { display:none !important; } ' + 
				'.jstree li a { dis-play:inline; border-width:0 !important; padding:0px 2px !important; } ';
		}
		// Correct IE 7 (shifts anchor nodes onhover)
		if($.jstree.IS_IE7) { 
			css_string += '.jstree li a { border-width:0 !important; padding:0px 2px !important; } ';
		}
		// Correct ff2 lack of display:inline-block
		if($.jstree.IS_FF2) {
			css_string += '' + 
				'.jstree .jstree-icon { display:-moz-inline-box; } ' + 
				'.jstree li { line-height:12px; } ' + // WHY??
				'.jstree a { display:-moz-inline-box; } ';
				/* за темите
				'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } ';
				*/
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
})(jQuery);

})();
define("ext/jstree/jstree", function(){});

/* File: jstree.sort.js 
Sorts items alphabetically (or using any other function)
*/
/* Group: jstree sort plugin */
(function ($) {
	$.jstree.plugin("sort", {
		__construct : function () {
			this.get_container()
				.bind("load_node.jstree", $.proxy(function (e, data) {
						var obj = this.get_node(data.rslt.obj);
						obj = obj === -1 ? this.get_container_ul() : obj.children("ul");
						this._sort(obj, true);
					}, this))
				.bind("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
						this._sort(data.rslt.obj.parent(), false);
					}, this))
				.bind("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
						var m = data.rslt.parent === -1 ? this.get_container_ul() : data.rslt.parent.children('ul');
						this._sort(m, false);
					}, this));
		},
		defaults : function (a, b) { return this.get_text(a, true) > this.get_text(b, true) ? 1 : -1; },
		_fn : { 
			_sort : function (obj, deep) {
				var s = this.get_settings(true).sort,
					t = this;
				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));
				obj.children('li').each(function () { t.correct_node(this, false); });
				if(deep) {
					obj.find("> li > ul").each(function() { t._sort($(this)); });
					t.correct_node(obj.children('li'), true);
				}
			}
		}
	});
	// include the sort plugin by default
	$.jstree.defaults.plugins.push("sort");
})(jQuery);
define("ext/jstree/jstree.sort", function(){});

/* File: jstree.ui.js 
This plugin enables selecting, deselecting and hovering tree items.
*/
/* Group: jstree UI plugin */
(function ($) {
	$.jstree.plugin("ui", {
		__construct : function () { 
			this.data.ui.selected = $(); 
			this.data.ui.hovered = null;
			this.data.ui.last_selected = false; 

			this.get_container() // TODO: configurable event (click/dblclick/etc)
				.delegate("a", "click.jstree", $.proxy(function (e) {
						e.preventDefault();
						e.currentTarget.blur();
						var s			= this.get_settings(true).ui,
							obj			= this.get_node(e.currentTarget),
							is_selected	= this.is_selected(obj),
							is_multiple	= s.select_multiple_modifier === "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"]),
							is_range	= s.select_multiple_modifier === "on" || (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]);

						switch(!0) {
							case (is_range && this.data.ui.last_selected !== false):
								this.select_range(obj);
								break;
							case (is_range && this.data.ui.last_selected === false):
								this.select_one(obj);
								break;
							case (is_selected && is_multiple):
								this.deselect_node(obj);
								break;
							default:
								this.select_one(obj, is_multiple);
								break;
						}
					}, this))
				.delegate("a", "mouseenter.jstree", $.proxy(function (e) {
						this.hover_node(e.target);
					}, this))
				.delegate("a", "mouseleave.jstree", $.proxy(function (e) {
						this.dehover_node(e.target);
					}, this))
				.bind("delete_node.jstree", $.proxy(function (event, data) { 
						var o = this.get_node(data.rslt.obj),
							n = (o && o.length) ? o.find("a.jstree-clicked") : $(),
							t = this;
						n.each(function () { t.deselect_node(this); });
					}, this))
				.bind("move_node.jstree", $.proxy(function (event, data) { 
						if(data.rslt.cy) { 
							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");
						}
					}, this));
		},
		defaults : {
			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt, or false
			select_range_modifier : "shift", // on, or ctrl, shift, alt, or false
			disable_nested_selection : true
		},
		_fn : { 
			get_node : function (obj, allow_multiple) {
				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }
				return this.__call_old();
			},

			hover_node : function (obj) {
				obj = this.get_node(obj);
				if(!obj || !obj.length || this.is_loading(obj)) { return false; }
				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }
				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();
				this.scroll_to_node(obj);
				this.__callback({ "obj" : obj });
			},
			dehover_node : function () {
				var obj = this.data.ui.hovered, p;
				if(!obj || !obj.length) { return false; }
				p = obj.children("a").removeClass("jstree-hovered").parent();
				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }
				this.__callback({ "obj" : obj });
			},
			select_node : function (obj) {
				var t = this;
				obj = this.get_node(obj);
				if(obj === -1 || !obj || !obj.length || this.is_loading(obj)) { return false; }
				obj.children("a").addClass("jstree-clicked");
				this.data.ui.last_selected = obj;
				this.data.ui.selected = this.data.ui.selected.add(obj);
				// this.scroll_to_node(obj.eq(0));
				obj.parents(".jstree-closed").each(function () { t.open_node(this, false, 0); });
				this.__callback({ "obj" : obj });
			},
			deselect_node : function (obj) {
				obj = this.get_node(obj);
				if(!obj || !obj.length) { return false; }
				if(this.is_selected(obj)) {
					obj.children("a").removeClass("jstree-clicked");
					this.data.ui.selected = this.data.ui.selected.not(obj);
					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }
					this.__callback({ "obj" : obj });
				}
			},
			deselect_all : function (context) {
				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();
				ret.children("a.jstree-clicked").removeClass("jstree-clicked");
				this.data.ui.selected = $();
				this.data.ui.last_selected = false;
				this.__callback({ "obj" : ret });
			},
			is_selected : function (obj) { return this.data.ui.selected.index(this.get_node(obj)) >= 0; },
			get_selected : function (context) { return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; },

			select_range : function (obj, start_node, keep_old_selection) {
				var _this = this, i, s;
				obj = this.get_node(obj);
				if(!start_node) { s = true; start_node = this.data.ui.last_selected; }
				start_node = this.get_node(start_node);
				if(obj === -1 || !obj || !obj.length || this.is_loading(obj)) { return false; }
				if(start_node === -1 || !start_node || !start_node.length || this.is_loading(start_node)) { return false; }

				if(!keep_old_selection) { this.deselect_all(); }
				i = (obj.index() < start_node.index());
				start_node.addClass("jstree-last-selected");
				obj = obj[ i ? "nextUntil" : "prevUntil" ](".jstree-last-selected").andSelf().add(".jstree-last-selected");
				start_node.removeClass("jstree-last-selected");
				if(!i) { obj = obj.vakata_reverse(); }
				if(!obj.length) { return false; }
				obj.each(function () { _this.select_node(this); });
				if(s) { this.data.ui.last_selected = start_node; }
				this.__callback({ "obj" : obj });
				return true;
			},
			select_one : function (obj, keep_old_selection) {
				obj = this.get_node(obj);
				if(obj === -1 || !obj || !obj.length || this.is_loading(obj)) { return false; }
				if(!keep_old_selection) { this.deselect_all(); }
				else { 
					if(
						this.get_settings(true).ui.disable_nested_selection && 
						(
							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked:eq(0)").length) ||
							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)
						)
					) {
						return false;
					}
				}
				this.select_node(obj);
				// obj.each(function () { t.select_node(this); });
				this.__callback({ "obj" : obj });
				return true;
			},

			clean_node : function(obj) {
				obj = this.__call_old();
				var _this = this;
				return obj.each(function () {
					var t = $(this),
						d = t.data("jstree");
					t.find('.jstree-clicked').removeClass('jstree-clicked');
					if(d && d.selected) {
						_this.select_node(t);
						delete d.selected;
					}
				});
			},
			get_state : function () {
				var state = this.__call_old();
				state.selected = [];
				this.data.ui.selected.each(function () { state.selected.push(this.id); });
				return state;
			},
			set_state : function (state, callback) {
				if(this.__call_old()) {
					if(state.selected) {
						var _this = this;
						this.deselect_all();
						$.each(state.selected, function (i, v) {
							_this.select_node(document.getElementById(v));
						});
						delete state.selected;
						this.set_state(state, callback);
						return false;
					}
					return true;
				}
				return false;
			},
			get_json : function (obj, is_callback) {
				var r = this.__call_old();
				if(is_callback) {
					if(this.is_selected(obj)) { 
						r.data.jstree.selected = true; 
					}
				}
				return r;
			}
		}
	});
	// include the selection plugin by default
	$.jstree.defaults.plugins.push("ui");
})(jQuery);
define("ext/jstree/jstree.ui", function(){});

/* File: jstree.themes.js
Controls the looks of jstree, without this plugin you will get a functional tree, but it will look just like an ordinary UL list
*/
(function ($) {
	var themes_loaded = [];
	/*
		Group: $.jstree. 

		Variable: $.jstree.THEMES_DIR
		The location of all themes, this is used when setting a theme without supplying an URL (only by name). 
		Default is _false_. If left as _false_ the path will be autodetected when the DOM is ready. 
		The location of _jstree.js_ is used for the autodetection.
		Normally you won't need to modify this (provided you leave the _themes_ folder in the same folder as _jquery.jstree.js_ and do not rename the file).
		If you decide to move the folder or rename the file, but still want to load themes by name, simply set this to the new location of the _themes_ folder.
		> <script type="text/javascript" src="jstree.js"></script>
		> <script type="text/javascript">$.jstree.THEMES_DIR = "some/path/with-a-trailing-slash/";</script>
	*/
	$.jstree.THEMES_DIR = false;

	$.jstree.plugin("themes", {
		__construct : function () {
			this.get_container()
				.bind("__construct.jstree", $.proxy(function () {
						var s = this.get_settings(true).themes;
						this.data.themes.dots	= s.dots; 
						this.data.themes.icons	= s.icons; 

						if(s.url === false && s.theme === false) { 
							s.theme = this.data.core.rtl ? 'default-rtl' : 'default'; 
						}
						this.set_theme(s.theme, s.url);

						this[ this.data.themes.dots ? "show_dots" : "hide_dots" ]();
						this[ this.data.themes.icons ? "show_icons" : "hide_icons" ]();
					}, this));
		},
		/* Class: jstree */
		/*
			Group: THEMES options

			Variable: config.themes.theme
			*string* the name of the theme you want to use. Default is _default_.

			Variable: config.themes.url
			*mixed* the URL of the stylesheet of the theme you want to use. Default is _false_. If left as _false_ the location will be autodetected using <$.jstree.THEMES_DIR>.

			Variable: config.themes.dots
			*boolean* whether to show dots or not. Default is _true_. The chosen theme should support this option.

			Variable: config.themes.icons
			*boolean* whether to show icons or not. Default is _true_.
		*/
		defaults : { 
			theme	: false, 
			url		: false,
			dots	: true,
			icons	: true
		},
		_fn : {
			/*
				Group: THEMES functions

				Function: set_theme
				Sets the tree theme. This function is automatically called at construction with the settings specified in <config.themes.theme> and <config.themes.theme.url>.

				Parameters:
					theme_name - the name of the theme to apply
					theme_url - the URL of the stylesheet - leave this blank for autodetect
					
				Example:
				>// Set the theme and autodetect the location
				>$("#div1").jstree("set_theme","classic");
				>// A custom theme. Please note that if you place your own theme in the _themes_ folder ot will be autodetected too.
				>$("#div2").jstree("set_theme","custom-theme","/some/path/theme.css");
			*/
			set_theme : function (theme_name, theme_url) {
				if(!theme_name) { return false; }
				if(!theme_url) { theme_url = $.jstree.THEMES_DIR + theme_name + '/style.css'; }
				if($.inArray(theme_url, themes_loaded) === -1) {
					$.vakata.css.add_sheet({ "url" : theme_url });
					themes_loaded.push(theme_url);
				}
				if(this.data.themes.theme !== theme_name) {
					this.get_container().removeClass('jstree-' + this.data.themes.theme);
					this.data.themes.theme = theme_name;
				}
				this.get_container().addClass('jstree-' + theme_name);
				this.__callback(theme_name);
			},
			get_theme		: function () { return this.data.themes.theme; },
			show_dots		: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },
			hide_dots		: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },
			toggle_dots		: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
			show_icons		: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },
			hide_icons		: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },
			toggle_icons	: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },

			set_icon : function (obj, icon) { 
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj = obj.find("> a > .jstree-themeicon");
				if(icon === false) {
					this.hide_icon(obj);
				}
				else if(icon.indexOf("/") === -1) {
					obj.addClass(icon).attr("rel",icon);
				}
				else { 
					obj.css("background", "url('" + icon + "') center center no-repeat").attr("rel",icon);
				}
				return true;
			},
			get_icon : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return null; }
				obj = obj.find("> a > .jstree-themeicon");
				if(obj.hasClass('jstree-themeicon-hidden')) { return false; }
				obj = obj.attr("rel");
				return (obj && obj.length) ? obj : null;
			},
			hide_icon : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj.find('> a > .jstree-themeicon').addClass('jstree-themeicon-hidden');
				return true;
			},
			show_icon : function (obj) {
				obj = this.get_node(obj);
				if(!obj || obj === -1 || !obj.length) { return false; }
				obj.find('> a > .jstree-themeicon').removeClass('jstree-themeicon-hidden');
				return true;
			},

			clean_node : function(obj) {
				obj = this.__call_old();
				var t = this;
				return obj.each(function () {
					var o = $(this),
						d = o.data("jstree");
					if(!o.find("> a > ins.jstree-themeicon").length) { 
						o.children("a").prepend("<ins class='jstree-icon jstree-themeicon'>&#160;</ins>");
					}
					if(d && typeof d.icon !== 'undefined') {
						t.set_icon(o, d.icon);
						delete d.icon;
					}
				});
			},
			get_state : function () {
				var state = this.__call_old();
				state.themes = { 'theme' : this.get_theme(), 'icons' : this.data.themes.icons, 'dots' : this.data.themes.dots };
				return state;
			},
			set_state : function (state, callback) {
				if(this.__call_old()) {
					if(state.themes) {
						if(state.themes.theme) {
							this.set_theme(state.themes.theme);
						}
						if(typeof state.themes.dots !== 'undefined') {
							this[ state.themes.dots ? "show_dots" : "hide_dots" ]();
						}
						if(typeof state.themes.icons !== 'undefined') {
							this[ state.themes.icons ? "show_icons" : "hide_icons" ]();
						}
						delete state.themes;
						this.set_state(state, callback);
						return false;
					}
					return true;
				}
				return false;
			},
			get_json : function (obj, is_callback) {
				var r = this.__call_old(), i;
				if(is_callback) {
					i = this.get_icon(obj);
					if(typeof i !== 'undefined' && i !== null) { 
						r.data.jstree.icon = i; 
					}
				}
				return r;
			}
		}
	});
	$(function () {
		// autodetect themes path
		if($.jstree.THEMES_DIR === false) {
			$("script").each(function () { 
				if(this.src.toString().match(/jstree[^\/]*?\.js(\?.*)?$/)) { 
					$.jstree.THEMES_DIR = this.src.toString().replace(/jstree[^\/]*?\.js(\?.*)?$/, "") + 'themes/'; 
					return false; 
				}
			});
		}
		if($.jstree.THEMES_DIR === false) { $.jstree.THEMES_DIR = "themes/"; }
		// add themes specific CSS
		var css_string = '' + 
				'.jstree a { text-decoration:none; } ' + 
				'.jstree a > .jstree-themeicon { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl a > .jstree-themeicon { margin-left:3px; margin-right:0; } ' + 
				'.jstree .jstree-no-icons .jstree-themeicon, .jstree .jstree-themeicon-hidden { display:none; } '; 
		// Correct IE 6 (does not support the > CSS selector)
		if($.jstree.IS_IE6) { 
			css_string += '' + 
				'.jstree li a .jstree-themeicon { height:16px; width:16px; margin-right:3px; } ' + 
				'.jstree-rtl li a .jstree-themeicon { margin-right:0px; margin-left:3px; } ';
		}
		// the default stylesheet
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
	// include the themes plugin by default
	$.jstree.defaults.plugins.push("themes");
})(jQuery);
//*/;
define("ext/jstree/jstree.themes", function(){});

/* File: jstree.dnd.js 
Enables drag'n'drop.
*/
/* Group: jstree drag'n'drop plugin */

(function ($) {
	$.jstree.plugin("dnd", {
		__construct : function () {
			this.get_container()
				.delegate('a', 'mousedown', $.proxy(function (e) { 
					var obj = this.get_node(e.target);
					if(obj && obj !== -1 && obj.length && e.which === 1) { // TODO: think about e.which
						this.get_container().trigger('mousedown.jstree');
						return $.vakata.dnd.start(e, { 'jstree' : true, 'origin' : this, 'obj' : obj }, '<div id="jstree-dnd" class="' + (this.data.themes ? 'jstree-' + this.get_theme() : '') + '"><ins class="jstree-icon jstree-er">&#160;</ins>' + this.get_text(e.currentTarget, true) + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
					}
				}, this));
		},
		// TODO: is check_timeout or is it OK as is?
		// TODO: drag foreign items / drop foreign items (pretty easy with dnd events, but need to move marker placement in a function)
		defaults : {
			copy_modifier : 'ctrl',
			open_timeout : 500
		}
	});

	$(function() {
		// bind only once for all instances
		var lastmv = false,
			opento = false,
			marker = $('<div id="jstree-marker">&#160;</div>').hide().appendTo('body');

		$(document)
			.bind('dnd_start.vakata', function (e, data) { 
				lastmv = false;
			})
			.bind('dnd_move.vakata', function (e, data) { 
				if(opento) { clearTimeout(opento); }
				if(!data.data.jstree) { return; }

				// if we are hovering the marker image do nothing (can happen on "inside" drags)
				if(data.event.target.id && data.event.target.id === 'jstree-marker') {
					return;
				}

				var ins = $.jstree._reference(data.event.target),
					ref = false,
					off = false,
					rel = false,
					l, t, h, p, i, o;
				// if we are over an instance
				if(ins && ins.data && ins.data.dnd) {
					marker.attr('class', (ins.data.themes ? 'jstree-' + ins.get_theme() : ''));
					data.helper
						.children().attr('class', (ins.data.themes ? 'jstree-' + ins.get_theme() : ''))
						.find('.jstree-copy:eq(0)')[ data.event[data.data.origin.get_settings().dnd.copy_modifier + "Key"] ? 'show' : 'hide' ]();


					// if are hovering the container itself add a new root node
					if(data.event.target === ins.get_container()[0] || data.event.target === ins.get_container_ul()[0]) {
						if(ins.check( (data.event[data.data.origin.get_settings().dnd.copy_modifier + "Key"] ? "copy_node" : "move_node"), data.data.obj, -1, 'last')) {
							lastmv = { 'ins' : ins, 'par' : -1, 'pos' : 'last' };
							marker.hide();
							data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');
							return;
						}
					}
					else { 
						// if we are hovering a tree node
						ref = $(data.event.target).closest('a');
						if(ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
							off = ref.offset();
							rel = data.event.pageY - off.top;
							h = ref.height();
							if(rel < h / 3) { 
								o = ['b', 'i', 'a'];
							}
							else if(rel > h - h / 3) {
								o = ['a', 'i', 'b'];
							}
							else {
								o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
							}
							$.each(o, function (j, v) {
								switch(v) {
									case 'b':
										l = off.left - 6;
										t = off.top - 5;
										p = ins.get_parent(ref);
										i = ref.parent().index();
										break;
									case 'i':
										l = off.left - 2;
										t = off.top - 5 + h / 2 + 1;
										p = ref.parent();
										i = 0;
										break;
									case 'a':
										l = off.left - 6;
										t = off.top - 5 + h + 2;
										p = ins.get_parent(ref);
										i = ref.parent().index() + 1;
										break;
								}
								/*
								// TODO: moving inside, but the node is not yet loaded?
								// the check will work anyway, as when moving the node will be loaded first and checked again
								if(v === 'i' && !ins.is_loaded(p)) { }
								*/
								if(ins.check((data.event[data.data.origin.get_settings().dnd.copy_modifier + "Key"] ? "copy_node" : "move_node"),data.data.obj, p, i)) {
									if(v === 'i' && ref.parent().is('.jstree-closed') && ins.get_settings(true).dnd.open_timeout) {
										opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; })(ins, ref), ins.get_settings(true).dnd.open_timeout);
									}
									lastmv = { 'ins' : ins, 'par' : p, 'pos' : i };
									marker.css({ 'left' : l + 'px', 'top' : t + 'px' }).show();
									data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-er').addClass('jstree-ok');
									o = true;
									return false;
								}
							});
							if(o === true) { return; }
						}
					}
				}
				lastmv = false;
				data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
				marker.hide();
			})
			.bind('dnd_scroll.vakata', function (e, data) { 
				if(!data.data.jstree) { return; }
				marker.hide();
				lastmv = false;
				data.helper.find('.jstree-icon:eq(0)').removeClass('jstree-ok').addClass('jstree-er');
			})
			.bind('dnd_stop.vakata', function (e, data) { 
				if(opento) { clearTimeout(opento); }
				if(!data.data.jstree) { return; }
				marker.hide();
				if(lastmv) {
					lastmv.ins[ data.event[data.data.origin.get_settings().dnd.copy_modifier + "Key"] ? 'copy_node' : 'move_node' ]
						(data.data.obj, lastmv.par, lastmv.pos);
				}
			})
			.bind('keyup keydown', function (e, data) {
				data = $.vakata.dnd._get();
				if(data.data && data.data.jstree) {
					data.helper.find('.jstree-copy:eq(0)')[ e[data.data.origin.get_settings().dnd.copy_modifier + "Key"] ? 'show' : 'hide' ]();
				}
			});

		// add DND CSS
		var css_string = '' + 
				'#jstree-marker { position: absolute; top:0; left:0; margin:0; padding:0; border-right:0; border-top:5px solid transparent; border-bottom:5px solid transparent; border-left:5px solid; width:0; height:0; font-size:0; line-height:0; _border-top-color:pink; _border-botton-color:pink; _filter:chroma(color=pink); } ' + 
				'#jstree-dnd { line-height:16px; margin:0; padding:4px; } ' + 
				'#jstree-dnd .jstree-icon, #jstree-dnd .jstree-copy { display:inline-block; text-decoration:none; margin:0 2px 0 0; padding:0; width:16px; height:16px; } ' + 
				'#jstree-dnd .jstree-ok { background:green; } ' + 
				'#jstree-dnd .jstree-er { background:red; } ' + 
				'#jstree-dnd .jstree-copy { margin:0 2px 0 2px; }';
		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });
	});
	// include the dnd plugin by default
	$.jstree.defaults.plugins.push("dnd");
})(jQuery);
define("ext/jstree/jstree.dnd", function(){});

define('lib/util/view/widgets/treepane',[
    "jquery"
  , "lib/util/compare"
  , 'ext/jstree/vakata'
  , 'ext/jstree/jstree'
  , 'ext/jstree/jstree.sort'
  , 'ext/jstree/jstree.ui'
  , 'ext/jstree/jstree.themes'
  , 'ext/jstree/jstree.dnd'
],

function($, compare) {

  return function(el, fs, o) {
    o = o || {};
    o.icons = o.icons || {};
    var types = { },
        treepane = {
          toggle : function(node) {
            node = findNode(node.path, node.type);
            if(!node) return;
            tree.jstree("toggle_node", node);
          },
          getParent : function(node) {
            node = findNode(node.path, node.type);
            if(!node) return null;
            var el = tree.jstree("get_parent", node.get(0));
            if(!el) return null;
            if(-1 === el) return { type : "folder", path : "/" };
            return getNodeFromElement(el);
          }
        },
        names = fs.typeNames();
    for(var i = 0; i < names.length; i++) {
      var name = names[i],
          children = fs.typeChildren(name);
      types[name] = { valid_children : children ? children : "none" };
      if(o.icons[name])
        types[name].icon = o.icons[name];
      else
        types[name].icon = 'tree-icon tree-icon-' + name;
    }

    var tree = el
          .jstree({
            plugins : [
              "themes", "ui", "sort"
            ],
            sort : function (a, b) {
              var comp = compare(fs.typeOrder($(a).attr("rel")), fs.typeOrder($(b).attr("rel")));
              return comp !== 0 ? comp : compare($(a).attr("data-path").toLowerCase(), $(b).attr("data-path").toLowerCase());
            },
            ui : {
                select_limit : 1
              , selected_parent_close : "deselect"
              , select_multiple_modifier : false
              , select_range_modifier : false
            },
            types : types
          }),
        root
      ;

    tree.bind("create_node.jstree", function(e, data) {
      var r = data.rslt,
          el = $(r.obj[0]),
          path = el.attr("data-path"),
          type = el.attr("rel");

      if(type !== "folder")
        result = tree.jstree("set_icon", el, types[type].icon);
      $(treepane).trigger("node.created", [el, { type : type, path : path }]);
    });

    function getNodeFromElement(el) {
      return { type : el.attr("rel"), path : el.attr("data-path") };
    }

    var selected;
    tree.bind("click.jstree", function() {
      var el = tree.jstree("get_selected"),
          current = getNodeFromElement(el);
      if(selected && selected.type === current.type && selected.path === current.path)
        return;
      if(selected) {
        $(treepane).trigger("node.deselected", selected);
      }
      selected = current;
      $(treepane).trigger("node.selected", selected);
    });
    tree.bind("create_node.jstree", function(e, data) {
      var el = $(data.rslt.obj[0]);
      el.dblclick(function(e) {
        var node = { type : el.attr("rel"), path : el.attr("data-path") };
        $(treepane).trigger("node.trigger", node);
        e.preventDefault(); return false;
      });
    });

    function pollInit() {
      if(!el.find("ul").length) {
        setTimeout(pollInit, 15);
        return;
      }
      init();
    }

    pollInit();

    function createNode(title, path, type, parent, callback)
    {
      return tree.jstree("create_node"
        , parent || -1
        , {
            title : title
          , a_attr : {
              rel : type
            , "data-path" : path
          }
          , li_attr : {
              rel : type
            , "data-path" : path
          }
        }
        , "last"
        , function(el) {
          if(path === "/") {
            el.addClass("root-node");
            el.find("ul").addClass("root-container");
            setTimeout(function() {
              tree.jstree("select_node", el);
              tree.jstree("toggle_node", el);
              el.children("ins").hide();
              initFileSystem();
            }, 0);
          }
          if(callback)
            callback(el);
        }
      )
    }

    function createNodeByPath(path, type, callback) {
      var parts = path.substr(1).split("/"),
          name = parts.pop(),
          parent = parts.length === 0 ? -1 : findNode("/" + parts.join("/"), fs.typeContainerFor(type));
      createNode(name, path, type, parent, callback);
    }

    function removeNodeByPath(path, type) {
      var node = findNode(path, type);
      if(node === null)
        return;
      tree.jstree("delete_node", node);
    }

    function findNode(path, type) {
      return tree.find('li[data-path="'+path+'"][rel="'+type+'"]');
    }

    function initFileSystem() {
      var queue = fs.all();

      function dequeue() {
        if(queue.length === 0)
          return;
        var next = queue.shift();
        createNodeByPath(next.path, next.type, dequeue);
      }

      // wire events
      $(fs).on("added", function(e, path, type) {
        queue.push({ path : path, type : type });
        if(queue.length > 1) return;
        dequeue()
      });

      $(fs).on("removed", function(e, path, type) {
        removeNodeByPath(path, type);
      });

      dequeue();
    }

    $(treepane).on("node.trigger", function(e, node) {
      if(fs.typeIsContainer(node.type))
        treepane.toggle(node);
    });

    function init()
    {
      root = createNode("/", "/", "folder");
    }
    
    return treepane;
  };
});
define('modules/view/datasourcetree',[
  "jquery"
  , "lib/util/view/widgets/treepane"
  , "ext/jquery-ui/jquery.ui"
],

function($, createTree) {
  return function(ctx) {

    function init(container, fs) {
      var map = {
        folder : "/"
      };
      function activateNode(data, type, parentType) {
        if(!data) return;
        if(data.type === type) {
          if(data.path === map[type])
            return;
          if(map[type])
            ctx.trigger("data."+type+".deselect", map[type]);
          ctx.trigger("data."+type+".select", data.path);
          ctx.trigger("data."+type+".current", data.path);
          map[type] = data.path;
        } else if(data.type === parentType) {
          if(map[type]) {
            ctx.trigger("data."+type+".deselect", map[type]);
            map[type] = null;
          }
        } else {
          activateNode(tree.getParent(data), type, parentType);
        }
      }

      var tree = createTree(container, fs, {
        icons : {
            datasource : "images/datasource.png"
          , continuous : "images/continuous.png"
          , time       : "images/time.png"
          , discrete   : "images/discrete.png"
          , ordinal    : "images/ordinal.png"
          , category   : "images/category.png"
        }
      });

      $(tree).on("node.created", function(e, el, node) {
        var a = $(el).find("a").first()
              .attr("data-node", JSON.stringify(node));
      });
      $(tree).on("node.selected", function(_, data) { activateNode(data, "folder", null); });
      $(tree).on("node.selected", function(_, data) { activateNode(data, "datasource", "folder"); });

      ctx.on("data.folder.remove", function(path) {
        fs.remove(path, "folder");
      });

      ctx.on("data.folder.add", function(path) {
        fs.add(path, "folder");
      });
    }

    $.when(ctx.on("view.data.tree"), ctx.on("data.system.ready")).then(function(viewargs, systemargs) {
      init(viewargs[0], systemargs[0]);
    });
  };
});
define('modules/view/reportstree',[
  "jquery"
  , "lib/util/view/widgets/treepane"
  , "ext/jquery-ui/jquery.ui"
],

function($, createTree) {
  return function(ctx) {

    function init(container, fs) {
      var map = {
            folder : "/"
          },
          current;
      function activateNode(data, type, parentType) {
        if(!data) return;
        if(data.type === type) {
          if(data.path === current)
            return;
          if(map[type])
            ctx.trigger("reports."+type+".deselect", map[type]);
          ctx.trigger("reports."+type+".select", data.path);
          ctx.trigger("reports."+type+".current", data.path);
          current = map[type] = data.path;
        } else if(data.type === parentType) {
          if(map[type]) {
            ctx.trigger("reports."+type+".deselect", map[type]);
            map[type] = null;
          }
        } else {
          activateNode(tree.getParent(data), type, parentType);
        }
      }

      var tree = createTree(container, fs, {
        icons : {
            report : "images/report.png"
        }
      });

      $(tree).on("node.created", function(e, el, node) {
        var a = $(el).find("a").first()
              .attr("data-node", JSON.stringify(node));
      });
      $(tree).on("node.selected", function(_, data) { activateNode(data, "folder", null); });
      $(tree).on("node.selected", function(_, data) { activateNode(data, "report", "folder"); });
      $(tree).on("node.trigger", function(_, data)  {
        if(data.type === "report") {
          ctx.trigger("reports.report.openpath", data.path);
        }
      });

      ctx.on("reports.folder.remove", function(path) {
        fs.remove(path, "folder");
      });

      ctx.on("reports.folder.add", function(path) {
        fs.add(path, "folder");
      });
    }

    $.when(ctx.on("view.reports.tree"), ctx.on("reports.system.ready")).then(function(viewargs, systemargs) {
      init(viewargs[0], systemargs[0]);
    });
  };
});
define('text!templates/dialog.export.html',[],function () { return '<div class="rg-dialog-export">\n    <div class="rg-toolbar rg-actions"></div>\n    <div class="rg-toolbar rg-options"></div>\n    <form method="POST">\n        <div class="rg-export">\n            <textarea name="code" class="ui-widget-content"></textarea>\n            <input type="hidden" name="name" value="">\n        </div>\n    </form>\n</div>';});

define('lib/util/view/widgets/dialogexport',[
    "jquery"
  , "text!templates/dialog.export.html"
  , "lib/util/localdownload"
  , "lib/util/ui"
  , "lib/util/dom"
  , "lib/util/notification"
  , 'ext/jquery-ui/jquery.ui'
//  , 'ext/zclip/jquery.zclip'
],

function($, tplDialog, download, ui, dom, notification) {
  var elText, elDialog, elActions, elOptions, elForm,
//      clip,
      formCallback, currentAction, filename;

  function selectCode() {
    setTimeout(function() { dom.selectText(elText.get(0)); }, 100);
  }

  function reposition() {
    elDialog.dialog("option", "position", "center");
  }
  function init() {
    var buttons = [];
    /*
    buttons.push({
      text : "Copy",
      click : function() {
        elDialog.dialog("close");
        return true;
      }
    });
    */
    buttons.push({
      text : "Download",
      click : function() {
        download(""+elText.val(), filename);
      }
    });
    elDialog = $('body')
      .append(tplDialog)
      .find('.rg-dialog-export')
      .dialog({
        modal : true
        , autoOpen : false
        , resizable : false
        , width : 820
        , height : 480
        , dialogClass : "rg-el"
        , closeOnEscape: true
        , buttons : buttons
      }),
      elActions = elDialog.find(".rg-actions"),
      elOptions = elDialog.find(".rg-options"),
      elText = elDialog.find(".rg-export textarea"),
      elForm = elDialog.find("form");

    elForm.submit(function(e) {
      // TODO NEED TO USE THE LOCAL DOWNLOAD
      if(formCallback)
        return formCallback.call(this, elText.text(), currentAction);
      else
        return true;
    });

    elText.click(function() {
      selectCode();
    });

    elDialog.bind("dialogopen", function() { $(window).on("resize", reposition); });
    elDialog.bind("dialogclose", function() { $(window).off("resize", reposition); });
  }

  var inited = false;
  return function(title, actions, code, selected, callback) {
    formCallback = callback;
    if(!inited) {
      init();
      inited = true;
    }
    elActions.find("*").remove();
    elOptions.find("*").remove();

    function execute(action) {
      elDialog.find("input[name=name]").val("precog." + action.token);
      elOptions.find("*").remove();
      if(action.buildOptions) {
        action.buildOptions(elOptions, function() {
          elText.text(action.handler(code, action.options));
          selectCode();
        });
      }
      elText.text(action.handler(code, action.options));
      selectCode();
      filename = action.options.filename || "file";
    }

    selected = selected || actions[0].token;
    ui.radios(elActions, $(actions).map(function(i, action) {
      if(action.token === selected)
        currentAction = action;
      return {
        label : action.name
        , handler : function() {
          currentAction = action;
          execute(action);
          return true;
        }
        , group : "actions"
        , checked : action.token === selected
      };
    }));

    elActions.find(".ui-button:first").click();

    elDialog.dialog("option", "position", "center");
    elDialog.dialog("option", "title", title);
    elDialog.dialog("open");
/*
    if(clip) {
      $(window).trigger("resize"); // triggers reposition of the Flash overlay
    } else {
      clip = elDialog.dialog("widget").find('.ui-dialog-buttonpane button.ui-button:first')
        .css({ zIndex : 1000000 })
        .zclip({
          path:'js/ext/zclip/ZeroClipboard.swf',
          copy : function(){
            var val = ""+elText.val();
            // TODO for some reason it doesn't seem to work with HTML
            return val;
          },
          afterCopy : function() {

          }
        });
    }
*/
  };
});
define('lib/util/template',[
],

function() {
  var helpers = {
    indent : function(text, size, space, skip_first) {
      skip_first = skip_first === false || true;
      size = size || 2;
      space = space || " ";

      var s = "";
      while(size > 0) {
        s += space;
        size--;
      }
      var lines = text.split(/\r\n|\n|\r/);
      for(var i = skip_first ? 1 : 0; i < lines.length; i++) {
        lines[i] = s + lines[i];
      }
      return lines.join("\n");
    }
  };

  var patterns = {},
      helper_pattern = /\$([a-z_]+[0-1a-z_]*)\(([^)]*)\)/gi;

  function helper_replacer(params){
    return function(match, f, args) {
      var args = args.split(",").map(function(s) { return s.trim(); }).map(function(s) {
        var t;
        if(""+(t = parseFloat(s)) === s) {
          return t;
        } else if(s === "true" || s === "false") {
          return s === "true"
        } else if((t = s.substr(0, 1)) === '"' || t === "'") {
          return s;
        } else {
          return params[s];
        }
      });
      return helpers[f].apply(params, args);
    };
  };

  return function(template, params) {
    for(var key in params) {
      if(!params.hasOwnProperty(key)) continue;
      var pattern = patterns[key] || (patterns[key] = new RegExp("\\$"+key+"\\b", "g"));
      template = template.replace(pattern, params[key]);
    }
    template = template.replace(helper_pattern, helper_replacer(params));
    return template;
  };
});
define('lib/model/exports/exportarray',[

],

function() {
  return function(datasource) {
    return "ReportGrid.query.data("+JSON.stringify(datasource.src)+")";
  };
});
define('lib/model/exports/exporttext',[

],

function() {
  return function(datasource) {
    return "ReportGrid.query.data("+JSON.stringify(JSON.parse(datasource.src))+")";
  };
});
define('lib/model/exports/exporturl',[

],

function() {

  return function(datasource) {
    var src = datasource.src,
        hasprotocol = false;
    ["http://", "https://", "file:"].forEach(function(v) { if(src.substr(0, v.length) === v) hasprotocol = true; })
    if(!hasprotocol) {
      var base = window.location.href.split("/").slice(0,-1).join("/");
      if(base.substr(-1) !== "/" && src.substr(0, 1) !== "/")
        base += "/";
      src = base + src;
    }
    return 'ReportGrid.request("'+src+'")';
  };
});
define('lib/model/exports/datasource2load',[
    "lib/model/exports/exportarray"
  , "lib/model/exports/exporttext"
  , "lib/model/exports/exporturl"
],

function(earray, etext, eurl){
  var converters = {
    array : earray,
    text  : etext,
    url   : eurl
  };
  return function(datasource) {
    var type = datasource.type.toLowerCase();
    if(!converters[type])
      throw "a datasource of type '" + datasource.type + "' is not supported (yet)";
    return converters[type](datasource);
  };
});
define('text!templates/html.chart.export.html',[],function () { return '<!DOCTYPE html>\n<html>\n<head>\n<meta charset="UTF-8">\n<title>$title</title>\n<link rel="stylesheet" href="https://api.reportgrid.com/css/rg-charts.css">\n<script src="https://api.reportgrid.com/js/reportgrid-charts.js"></script>\n<script>\nfunction init() {\n\n  ReportGrid.$chart_type("#chart", {\n    axes : $axes,\n    load : $load,\n    options : $indent(options, 4)\n  });\n\n}\n</script>\n</head>\n<body onload="init()">\n    <div id="chart"></div>\n</body>\n</html>';});

define('lib/model/exports/chart2html',[
    "jquery"
  , "lib/util/template"
  , "config/charts"
  , "lib/model/exports/datasource2load"
  , "text!templates/html.chart.export.html"
],

function($, template, charts, datasource2load, tplHtml) {
  return function(chart, options) {
    var chart_options = $.extend({}, {width:500,height:250}, chart.options)
    var params = {
            title      : "ReportGrid Chart - Generated by The Builder"
          , chart_type : charts.map[chart.type].method
          , axes       : JSON.stringify(chart.axes)
          , options    : JSON.stringify(chart_options, null, 2)
          , load       : datasource2load(chart.datasource)
//          , script     : JSON.stringify(chart, null, 2)
        };
    return template(tplHtml, params);
  };
});
define('modules/view/exporthtml',[
    "jquery"
  , "lib/util/ui"
  , "lib/util/view/widgets/dialogexport"
  , "lib/model/exports/chart2html"
],

function($, ui, openExportDialog, chart2html) {
  return function(ctx) {
    var current_chart,
        current_name = "index.html";
    function init(el) {
      $export = ui.button(el, {
        icon : "ui-icon-arrowthickstop-1-s",
        description : "export chart",
        enabled : false,
        handler : function() {
          openExportDialog("Export Chart", [{
            name : "HTML",
            token : "html",
            options : {
              filename : current_name
            },
            handler : chart2html
          }], current_chart);
        }
      });

      function renderable(chart) {
        current_chart = chart;
        $export.button("enable");
      }

      function unrenderable() {
        $export.button("disable");
      }

      function name_set(name) {
        current_name = (name || "index") + ".html";
      }

      ctx.on("chart.render.execute", renderable);
      ctx.on("chart.render.clear", unrenderable);
      ctx.on("chart.name.set", name_set);
    };

    ctx.on("view.editor.toolbar-context", init);
  };
});
requirejs.config({
  shim : {
      'ext/jquery-ui/jquery.ui'         : ['jquery']
    , 'ext/jquery-layout/jquery.layout' : ['ext/jquery-ui/jquery.ui']
    , 'ext/jstree/jstree' : ['ext/jstree/vakata']
    , 'ext/jstree/jstree.sort' : ['ext/jstree/jstree']
    , 'ext/jstree/jstree.themes' : ['ext/jstree/jstree']
    , 'ext/jstree/jstree.ui' : ['ext/jstree/jstree']
    , 'ext/jstree/jstree.dnd' : ['ext/jstree/jstree']
  }
});
require([
    "jquery"
  , "modules/context"
  , "modules/model/config"
  , "modules/model/examples"
  , "modules/model/dimensionstyper"
  , "modules/model/chartbuilder"
  , "modules/model/datasourcebroker"
  , "modules/model/datasourcefilesystem"
  , "modules/model/datasourcelocalstorage"
  , "modules/model/reportsbroker"
  , "modules/model/reportsfilesystem"
  , "modules/model/reportslocalstorage"
  , "modules/model/chartstate"
  , "modules/view/brand"
  , "modules/view/theme"
  , "modules/view/datasourcewindow"
  , "modules/view/thememenu"
  , "modules/view/layout"
  , "modules/view/editor/tabs"
  , "modules/view/editorpane"
  , "modules/view/chartselector"
  , "modules/view/datasourceselector"
  , "modules/view/datasourcepreview"
  , "modules/view/datasourceedit"
  , "modules/view/datasourcetreeactions"
  , "modules/view/reportstreeactions"
  , "modules/view/reportsdownloadupload"
  , "modules/view/dimensionspane"
  , "modules/view/optionspane"
  , "modules/view/chartpane"
  , "modules/view/changergtheme"
  , "modules/view/datasourcetree"
  , "modules/view/reportstree"
  , "modules/view/exporthtml"
],
function($, createContext) {
  var modules = $(arguments).slice(2);

  function builder() {
    var ctx = createContext(true);

    $(modules).each(function() {
      this(ctx);
    });

    ctx.trigger("modules.ready");
    ctx.trigger("view.container.ready", $(this));
    ctx.trigger("app.ready");

    // DEBUG
    window.ctx = ctx;
  }

  $(function() {
    var selection = $("body");
    selection.each(builder);
  });
});
define("main", function(){});
